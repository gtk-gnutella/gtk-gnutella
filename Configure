#! /bin/sh
#
# If these # comments don't work, trim them. Don't worry about any other
# shell scripts, Configure will trim # comments from them for you.
#
# (If you are trying to port this package to a machine without sh,
# I would suggest you have a look at the prototypical config_h.SH file
# and edit it to reflect your system. Some packages may include samples
# of config.h for certain machines, so you might look for one of those.)
#
# Yes, you may rip this off to use in other distribution packages. This
# script belongs to the public domain and cannot be copyrighted.
#
# Note: this Configure script was generated automatically. Rather than
# working with this copy of Configure, you may wish to get metaconfig.
# The dist package (which contains metaconfig) is available via git:
#     git clone git@github.com:rmanfredi/dist.git

# $Id$
#
# Generated on Wed Dec 28 18:44:06 CET 2022 [metaconfig 3.5-255]

cat >c1$$ <<EOF
ARGGGHHHH!!!!!

SCO csh still thinks true is false.  Write to SCO today and tell them that next
year Configure ought to "rm /bin/csh" unless they fix their blasted shell. :-)

(Actually, Configure ought to just patch csh in place.  Hmm.  Hmmmmm.  All
we'd have to do is go in and swap the && and || tokens, wherever they are.)

[End of diatribe. We now return you to your regularly scheduled programming...]
EOF
cat >c2$$ <<EOF

OOPS!  You naughty creature!  You didn't run Configure with sh!
I will attempt to remedy the situation by running sh for you...
EOF

true || cat c1$$ c2$$
true || exec sh $0 $argv:q

(exit $?0) || cat c2$$
(exit $?0) || exec sh $0 $argv:q
rm -f c1$$ c2$$

: compute my invocation name
me=$0
case "$0" in
*/*)
	me=`echo $0 | sed -e 's!.*/\(.*\)!\1!' 2>/dev/null`
	test "$me" || me=$0
	;;
esac

: Proper separator for the PATH environment variable
p_=:
: On OS/2 this directory should exist if this is not floppy only system ":-]"
if test -d c:/. ; then
	if test -n "$OS2_SHELL"; then
		p_=\;
		PATH=`cmd /c "echo %PATH%" | tr '\\\\' / `
		OS2_SHELL=`cmd /c "echo %OS2_SHELL%" | tr '\\\\' / | tr '[A-Z]' '[a-z]'`
	elif test -n "$DJGPP"; then
		case "X${MACHTYPE:-nonesuchmach}" in
		*cygwin|*msys) ;;
		*) p_=\; ;;
		esac
	fi
fi

: Proper PATH setting
paths='/bin /usr/bin /usr/local/bin /usr/ucb /usr/local /usr/lbin'
paths="$paths /opt/bin /opt/local/bin /opt/local /opt/lbin"
paths="$paths /usr/5bin /etc /usr/gnu/bin /usr/new /usr/new/bin /usr/nbin"
paths="$paths /opt/gnu/bin /opt/new /opt/new/bin /opt/nbin"
paths="$paths /sys5.3/bin /sys5.3/usr/bin /bsd4.3/bin /bsd4.3/usr/ucb"
paths="$paths /bsd4.3/usr/bin /usr/bsd /bsd43/bin /usr/ccs/bin"
paths="$paths /etc /usr/lib /usr/ucblib /lib /usr/ccs/lib"
paths="$paths /sbin /usr/sbin /usr/libexec"
paths="$paths /system/gnu_library/bin"

for p in $paths
do
	case "$p_$PATH$p_" in
	*$p_$p$p_*) ;;
	*) test -d $p && PATH=$PATH$p_$p ;;
	esac
done

PATH=.$p_$PATH
export PATH

: shall we be using ksh?
inksh=''
needksh=''
avoidksh=''
newsh=/bin/ksh
changesh=''
if (PATH=.; alias -x) >/dev/null 2>&1; then
		inksh=true
fi
if test -f /hp-ux -a -f /bin/ksh; then
	needksh='to avoid sh bug in "here document" expansion'
fi
if test -d /usr/lpp -a -f /usr/bin/bsh -a -f /usr/bin/uname; then
	if test X`/usr/bin/uname -v` = X4; then
		avoidksh="to avoid AIX 4's /bin/sh"
		newsh=/usr/bin/bsh
	fi
fi
if test -f /osf_boot -a -f /usr/sbin/setld; then
	if test X`/usr/bin/uname -s` = XOSF1; then
		avoidksh="to avoid Digital UNIX' ksh"
		newsh=/bin/sh
		unset BIN_SH
	fi
fi
case "$inksh/$needksh" in
/[a-z]*)
		ENV=''
		changesh=true
		reason="$needksh"
	;;
esac
case "$inksh/$avoidksh" in
true/[a-z]*)
	changesh=true
	reason="$avoidksh"
	;;
esac
case "$inksh/$needksh-$avoidksh-" in
true/--)
		cat <<EOM
(I see you are using the Korn shell.  Some ksh's blow up on $me,
mainly on older exotic systems.  If yours does, try the Bourne shell instead.)
EOM
	;;
esac
case "$changesh" in
true)
	export newsh
	echo "(Feeding myself to $newsh $reason.)"
	case "$0" in
	Configure|*/Configure) exec $newsh $0 "$@";;
	*) exec $newsh Configure "$@";;
	esac
	;;
esac

: if needed, set CDPATH to a harmless value that is not chatty
case "$CDPATH" in
'')	;;
*)	case "$SHELL" in
	*bash*) CDPATH='.' ;;
	*) CDPATH='' ;;
	esac
	;;
esac

: Configure runs within the UU subdirectory
test -d UU || mkdir UU
cd UU && rm -f ./*

ccname=''
ccversion=''
from=''
run=''
targetarch=''
to=''
usecrosscompile=''
d_bsd=''
d_dos=''
d_eunice=''
d_linux=''
d_os2=''
d_windows=''
d_xenix=''
_exe=''
eunicefix=''
ar=''
awk=''
bash=''
bison=''
byacc=''
cat=''
chgrp=''
chmod=''
chown=''
comm=''
compress=''
cp=''
cpio=''
cpp=''
csh=''
date=''
echo=''
egrep=''
emacs=''
expr=''
find=''
flex=''
gcc=''
gmake=''
gmsgfmt=''
grep=''
gzip=''
inews=''
ksh=''
less=''
line=''
lint=''
ln=''
lp=''
lpr=''
ls=''
mail=''
mailx=''
make=''
mkdir=''
more=''
msgfmt=''
msgmerge=''
mv=''
nawk=''
nm=''
nroff=''
perl=''
pg=''
pmake=''
pr=''
rm=''
rmail=''
sed=''
sendmail=''
shar=''
sleep=''
smail=''
sort=''
submit=''
tail=''
tar=''
tbl=''
tee=''
test=''
touch=''
tr=''
troff=''
uname=''
uniq=''
uuname=''
vi=''
wc=''
xgettext=''
zcat=''
zip=''
incpath=''
mips_type=''
libswanted=''
hint=''
myuname=''
osname=''
osvers=''
Author=''
Date=''
Header=''
Id=''
Locker=''
Log=''
RCSfile=''
Revision=''
Source=''
State=''
_a=''
_o=''
archobjs=''
firstmakefile=''
rm_try=''
afs=''
afsroot=''
alignbytes=''
archlib=''
archlibexp=''
d_archlib=''
installarchlib=''
archname=''
myarchname=''
bin=''
binexp=''
installbin=''
byteorder=''
cc=''
ccflags=''
cppflags=''
ldflags=''
lkflags=''
locincpth=''
optimize=''
pthread=''
cf_by=''
cf_time=''
charsize=''
contains=''
cpp_quote=''
cpp_stuff=''
cpplast=''
cppminus=''
cpprun=''
cppstdin=''
d_gettblsz=''
nofile=''
tablesize=''
d_access=''
d_alarm=''
d_arc4random=''
d_attribut=''
d_backtrace=''
d_bcmp=''
d_bcopy=''
d_bfd_lib=''
d_bfd_section=''
d_bindtxtcode=''
d_bsearch=''
d_built_bswap32=''
d_built_bswap64=''
d_built_clz=''
d_built_ctz=''
d_built_popcount=''
d_bzero=''
d_clearenv=''
d_clock_getres=''
d_clock_gettime=''
d_closefrom=''
d_const=''
d_deflate=''
d_dev_poll=''
d_difftime=''
use_difftime=''
d_dirent_d_namlen=''
d_dirent_d_type=''
d_dirfd=''
d_dladdr=''
d_end_symbol=''
d_epoll=''
d_etext_symbol=''
d_fchdir=''
d_fdatasync=''
d_fdopendir=''
d_fork=''
d_fstatat=''
d_fsync=''
d_ftime=''
d_gettimeod=''
d_getaddrinfo=''
d_geteuid=''
aphostname=''
d_gethname=''
d_phostname=''
d_uname=''
d_getifaddrs=''
d_getinvent=''
d_getlogin=''
d_getnameinfo=''
d_getppid=''
d_getprogname=''
d_getpwnam=''
d_getpwuid=''
d_getrlimit=''
d_gettext=''
d_getuid=''
d_gnulibc=''
gnulibc_version=''
d_headless=''
d_herror=''
d_hstrerror=''
d_iconv=''
d_ieee754=''
ieee754_byteorder=''
d_inflate=''
d_iptos=''
d_ipv6=''
d_isascii=''
d_kevent_int_udata=''
d_kqueue=''
d_locale_charset=''
d_lstat=''
d_madvise=''
d_memalign=''
d_memcpy=''
d_memmove=''
d_mempcpy=''
d_memrchr=''
d_memset=''
d_mmap=''
d_msghdr_msg_flags=''
d_nanosleep=''
d_nls=''
d_open3=''
d_openat=''
d_pause=''
d_pipe2=''
d_poll=''
d_popcount=''
d_popen=''
d_portable=''
d_posix_fadvise=''
d_posix_memalign=''
d_pread=''
d_preadv=''
d_proginvocname=''
d_ptattr_setstack=''
d_pwrite=''
d_pwritev=''
d_recvmsg=''
d_regcomp=''
d_regparm=''
d_rusage=''
d_sbrk=''
d_sched_yield=''
d_select=''
d_semctl=''
d_semget=''
d_semop=''
d_semtimedop=''
d_sendfile=''
d_setenv=''
d_setproctitle=''
d_setprogname=''
d_setsid=''
d_sigaction=''
d_sigaltstack=''
d_sigprocmask=''
d_sigsetjmp=''
d_sockaddr_in_sin_len=''
d_sockaddr_un=''
d_socker_get=''
sockercflags=''
sockerldflags=''
d_oldsock=''
d_socket=''
d_sockpair=''
sockethdr=''
socketlib=''
d_statfs=''
d_statvfs=''
d_index=''
d_strchr=''
d_strlcat=''
d_strlcpy=''
d_sync_atomic=''
d_syscall=''
d_sysctl=''
d_system=''
clocktype=''
d_times=''
d_ttyname=''
d_uctx_mctx=''
d_uctx_mctx_gregs=''
d_usleep=''
d_vfork=''
usevfork=''
d_voidsig=''
signal_t=''
d_volatile=''
d_vsnprintf=''
d_waitpid=''
d_dbus=''
dbuscflags=''
dbusconfig=''
dbusldflags=''
ebcdic=''
d_enablenls=''
enablenls=''
cppfilter=''
fieldn=''
gccosandvers=''
gccversion=''
glade=''
d_glib=''
glibcflags=''
glibconfig=''
glibldflags=''
d_useglib1=''
d_useglib2=''
glibpackage=''
glibversion=''
d_gnutls=''
gnutlscflags=''
gnutlsconfig=''
gnutlsldflags=''
d_gtk=''
gtkcflags=''
gtkconfig=''
gtkldflags=''
gtkgversion=''
d_usegtk1=''
d_usegtk2=''
gtkpackage=''
gtkversion=''
h_fcntl=''
h_sysfile=''
i_alloca=''
i_arpainet=''
d_dirnamlen=''
direntrytype=''
i_dirent=''
i_dlfcn=''
i_execinfo=''
i_fcntl=''
i_iconv=''
i_ifaddrs=''
i_inttypes=''
i_invent=''
i_langinfo=''
i_libcharset=''
i_libintl=''
i_limits=''
i_linux_netlink=''
i_linux_rtnetlink=''
i_malloc=''
i_math=''
i_mswsock=''
i_netdb=''
i_netif=''
i_netroute=''
i_niin=''
i_sysin=''
i_niip=''
i_poll=''
i_pthread=''
d_pwage=''
d_pwchange=''
d_pwclass=''
d_pwcomment=''
d_pwexpire=''
d_pwquota=''
i_pwd=''
i_regex=''
i_sched=''
i_stdlib=''
i_string=''
strings=''
i_sysfile=''
i_sysipc=''
i_sysmman=''
i_sysmount=''
i_sysparam=''
i_syspoll=''
i_sysresrc=''
i_sysselct=''
i_syssem=''
i_syssendfile=''
i_syssock=''
i_sysstat=''
i_sysstatvfs=''
i_syssysctl=''
i_systimeb=''
i_systimes=''
i_systypes=''
i_sysun=''
i_sysutsname=''
i_sysvfs=''
i_syswait=''
i_systime=''
i_systimek=''
i_time=''
timeincl=''
i_sys_ucontext=''
i_ucontext=''
i_unistd=''
i_stdarg=''
i_varargs=''
i_varhdr=''
i_winsock2=''
i_ws2tcpip=''
i_zlib=''
d_can64=''
d_ilp32=''
d_ilp64=''
d_lp64=''
ilp=''
install=''
installdir=''
intsize=''
longsize=''
shortsize=''
issymlink=''
libc=''
libnames=''
glibpth=''
libpth=''
loclibpth=''
plibpth=''
xlibpth=''
libs=''
libscheck=''
libsdirs=''
libsfiles=''
libsfound=''
libspath=''
lns=''
locale=''
localeexp=''
make_set_make=''
d_mymalloc=''
freetype=''
mallocobj=''
mallocsrc=''
malloctype=''
usemymalloc=''
installmansrc=''
manext=''
mansrc=''
mansrcexp=''
mkdep=''
huge=''
large=''
medium=''
models=''
small=''
split=''
msgmerge_update=''
mydomain=''
myhostname=''
phostname=''
c=''
n=''
d_eofnblk=''
eagain=''
o_nonblock=''
rd_nodata=''
groupcat=''
hostcat=''
passcat=''
d_official=''
official=''
orderlib=''
ranlib=''
package=''
spackage=''
pkgsrc=''
prefix=''
prefixexp=''
installprivlib=''
privlib=''
privlibexp=''
prototype=''
ptrsize=''
d_remotectrl=''
remotectrl=''
sh=''
sig_count=''
sig_name=''
sig_name_init=''
sig_num=''
sig_num_init=''
sig_size=''
so=''
sharpbang=''
shsharp=''
spitshell=''
src=''
startsh=''
sysman=''
trnl=''
nm_opt=''
nm_so_opt=''
runnm=''
usenm=''
usrinc=''
defvoidused=''
voidflags=''
yacc=''
yaccflags=''
CONFIG=''

: Initialize wide constants
define='define'
undef='undef'
smallmach='pdp11 i8086 z8000 i80286 iAPX286'
rmlist=''

: We must find out about Eunice early
eunicefix=':'
if test -f /etc/unixtovms; then
	eunicefix=/etc/unixtovms
fi
if test -f /etc/unixtovms.exe; then
	eunicefix=/etc/unixtovms.exe
fi

: Set executable suffix now -- needed before hints available
if test -f "/libs/version.library"; then
	: Amiga OS
	 _exe=""
elif test -f "/system/gnu_library/bin/ar.pm"; then
	: Stratus VOS
	_exe=".pm"
elif test -n "$DJGPP"; then
	: DOS DJGPP
	 _exe=".exe"
elif test -d c:/. ; then
	: OS/2 or cygwin
	_exe=".exe"
else
	: All other UNIX systems
	_exe=""
fi

ccname=''
ccversion=''
: Extra object files, if any, needed on this platform.
archobjs=''
: Possible local include directories to search.
: Set locincpth to "" in a hint file to defeat local include searches.
locincpth=""
:
: no include file wanted by default
inclwanted=''

i_whoami=''
libnames=''
: change the next line if compiling for Xenix/286 on Xenix/386
xlibpth='/usr/lib/386 /lib/386'
: Possible local library directories to search.
loclibpth=""

: general looking path for locating libraries
glibpth="/lib /usr/lib $xlibpth"
glibpth="$glibpth /usr/ccs/lib /usr/ucblib /usr/local/lib"
test -f /usr/shlib/libc.so && glibpth="/usr/shlib $glibpth"
test -f /shlib/libc.so     && glibpth="/shlib $glibpth"
glibpth="$glibpth /lib32 /lib64 "`ls -1d /usr/lib/*-gnu 2>/dev/null`
: Private path used by Configure to find libraries.  Its value
: is prepended to libpth. This variable takes care of special
: machines, like the mips.  Usually, it should be empty.
plibpth=''

: default library list
libswanted=''
: should be set by hint files if needed
libscheck=''
usesocks=''
: full support for void wanted by default
defvoidused=15

: private initializations
libswanted="bfd iberty sendfile z iconv m intl dl"

: Find the basic shell for Bourne shell scripts
case "$sh" in
'')
	case "$SYSTYPE" in
	*bsd*|sys5*) xxx="/$SYSTYPE/bin/sh";;
	*) xxx='/bin/sh';;
	esac
	if test -f "$xxx"; then
		sh="$xxx"
	else
		: Build up a list and do a single loop so we can 'break' out.
		pth=`echo $PATH | sed -e "s/$p_/ /g"`
		for xxx in sh bash ksh pdksh ash; do
			for p in $pth; do
				try="$try ${p}/${xxx}"
			done
		done
		for xxx in $try; do
			if test -f "$xxx"; then
				sh="$xxx"
				break
			elif test -f "$xxx$_exe"; then
				sh="$xxx$_exe"
				break
			elif test -f "$xxx.exe"; then
				sh="$xxx.exe"
				break
			fi
		done
	fi
	;;
esac

case "$sh" in
'')	cat >&2 <<EOM
$me:  Fatal Error:  I can't find a Bourne Shell anywhere.  

Usually it's in /bin/sh.  How did you even get this far?
Please contact me (gtk-gnutella developers) at gtk-gnutella-devel@lists.sourceforge.net and 
we'll try to straighten this all out.
EOM
	exit 1
	;;
esac

: see if sh knows # comments
if `$sh -c '#' >/dev/null 2>&1`; then
	shsharp=true
	spitshell=cat
	xcat=/bin/cat
	test -f $xcat$_exe || xcat=/usr/bin/cat
	if test ! -f $xcat$_exe; then
		for p in `echo $PATH | sed -e "s/$p_/ /g"` $paths; do
			if test -f $p/cat$_exe; then
				xcat=$p/cat
				break
			fi
		done
		if test ! -f $xcat$_exe; then
			echo "Can't find cat anywhere!"
			exit 1
		fi
	fi
	echo "#!$xcat" >sharp
	$eunicefix sharp
	chmod +x sharp
	./sharp > today 2>/dev/null
	if test -s today; then
		sharpbang='#!'
	else
		echo "#! $xcat" > sharp
		$eunicefix sharp
		chmod +x sharp
		./sharp > today 2>/dev/null
		if test -s today; then
			sharpbang='#! '
		else
			sharpbang=': use '
		fi
	fi
else
	echo " "
	echo "Your $sh doesn't grok # comments--I will strip them later on."
	shsharp=false
	cd ..
	echo "exec grep -v '^[ 	]*#'" >spitshell
	chmod +x spitshell
	$eunicefix spitshell
	spitshell=`pwd`/spitshell
	cd UU
	echo "I presume that if # doesn't work, #! won't work either!"
	sharpbang=': use '
fi
rm -f sharp today

: figure out how to guarantee sh startup
case "$startsh" in
'') startsh=${sharpbang}${sh} ;;
*)
esac
cat >sharp <<EOSS
$startsh
set abc
test "$?abc" != 1
EOSS

chmod +x sharp
$eunicefix sharp
if ./sharp; then
	: echo "Yup, it does."
else
	echo "Hmm... '$startsh' does not guarantee sh startup..."
	echo "You may have to fix up the shell scripts to make sure $sh runs them."
fi
rm -f sharp

: Save command line options in file UU/cmdline.opt for later use in
: generating config.sh.
cat > cmdline.opt <<EOSH
: Configure command line arguments.
config_arg0='$0'
config_args='$*'
config_argc=$#
EOSH
argn=1
args_exp=''
args_sep=''
for arg in "$@"; do
	cat >>cmdline.opt <<EOSH
config_arg$argn='$arg'
EOSH
	cat <<EOC | sed -e "s/'/'"'"'"'"'"'"'/g" > cmdl.opt
$arg
EOC
	arg_exp=`cat cmdl.opt`
	args_exp="$args_exp$args_sep'$arg_exp'"
	argn=`expr $argn + 1`
	args_sep=' '
done
rm -f cmdl.opt

: produce awk script to parse command line options
cat >options.awk <<'EOF'
BEGIN {
	optstr = "A:dD:eEf:hKOrsSU:V";	# getopt-style specification

	len = length(optstr);
	for (i = 1; i <= len; i++) {
		c = substr(optstr, i, 1);
		if (i < len) a = substr(optstr, i + 1, 1); else a = "";
		if (a == ":") {
			arg[c] = 1;
			i++;
		}
		opt[c] = 1;
	}
}
{
	expect = 0;
	str = $0;
	if (substr(str, 1, 1) != "-") {
		printf("'%s'\n", str);
		next;
	}
	len = length($0);
	for (i = 2; i <= len; i++) {
		c = substr(str, i, 1);
		if (!opt[c]) {
			printf("-%s\n", substr(str, i));
			next;
		}
		printf("-%s\n", c);
		if (arg[c]) {
			if (i < len)
				printf("'%s'\n", substr(str, i + 1));
			else
				expect = 1;
			next;
		}
	}
}
END {
	if (expect)
		print "?";
}
EOF

: process the command line options
set X `for arg in "$@"; do echo "X$arg"; done |
	sed -e s/X// | awk -f options.awk`
eval "set $*"
shift
rm -f options.awk

: set up default values
fastread=''
reuseval=false
config_sh=''
alldone=''
error=''
silent=''
extractsh=''
override=''
knowitall=''
rm -f optdef.sh posthint.sh
cat >optdef.sh <<EOS
$startsh
EOS


: option parsing
while test $# -gt 0; do
	case "$1" in
	-d) shift; fastread=yes;;
	-e) shift; alldone=cont;;
	-f)
		shift
		cd ..
		if test -r "$1"; then
			config_sh="$1"
		else
			echo "$me: cannot read config file $1." >&2
			error=true
		fi
		cd UU
		shift;;
	-h) shift; error=true;;
	-r) shift; reuseval=true;;
	-s) shift; silent=true; realsilent=true;;
	-E) shift; alldone=exit;;
	-K) shift; knowitall=true;;
	-O) shift; override=true;;
	-S) shift; silent=true; extractsh=true;;
	-D)
		shift
		case "$1" in
		*=)
			echo "$me: use '-U symbol=', not '-D symbol='." >&2
			echo "$me: ignoring -D $1" >&2
			;;
		*=*) echo "$1" | \
				sed -e "s/'/'\"'\"'/g" -e "s/=\(.*\)/='\1'/" >> optdef.sh;;
		*) echo "$1='define'" >> optdef.sh;;
		esac
		shift
		;;
	-U)
		shift
		case "$1" in
		*=) echo "$1" >> optdef.sh;;
		*=*)
			echo "$me: use '-D symbol=val', not '-U symbol=val'." >&2
			echo "$me: ignoring -U $1" >&2
			;;
		*) echo "$1='undef'" >> optdef.sh;;
		esac
		shift
		;;
	-A)
	    shift
	    xxx=''
	    yyy="$1"
	    zzz=''
	    uuu=undef
	    case "$yyy" in
            *=*) zzz=`echo "$yyy"|sed 's!=.*!!'`
                 case "$zzz" in
                 *:*) zzz='' ;;
                 *)   xxx=append
                      zzz=" "`echo "$yyy"|sed 's!^[^=]*=!!'` 
                      yyy=`echo "$yyy"|sed 's!=.*!!'` ;;
                 esac
                 ;;
            esac
            case "$xxx" in
            '')  case "$yyy" in
                 *:*) xxx=`echo "$yyy"|sed 's!:.*!!'`
                      yyy=`echo "$yyy"|sed 's!^[^:]*:!!'`
                      zzz=`echo "$yyy"|sed 's!^[^=]*=!!'`
                      yyy=`echo "$yyy"|sed 's!=.*!!'` ;;
                 *)   xxx=`echo "$yyy"|sed 's!:.*!!'`
                      yyy=`echo "$yyy"|sed 's!^[^:]*:!!'` ;;
                 esac
                 ;;       
            esac
	    case "$xxx" in
	    append)
		echo "$yyy=\"\${$yyy}$zzz\""	>> posthint.sh ;;
	    clear)
		echo "$yyy=''"			>> posthint.sh ;;
	    define)
	        case "$zzz" in
		'') zzz=define ;;
		esac
		echo "$yyy='$zzz'"		>> posthint.sh ;;
	    eval)
		echo "eval \"$yyy=$zzz\""	>> posthint.sh ;;
	    prepend)
		echo "$yyy=\"$zzz\${$yyy}\""	>> posthint.sh ;;
	    undef)
	        case "$zzz" in
		'') zzz="$uuu" ;;
		esac
		echo "$yyy=$zzz"		>> posthint.sh ;;
            *)  echo "$me: unknown -A command '$xxx', ignoring -A $1" >&2 ;;
	    esac
	    shift
	    ;;
	-V) echo "$me generated by metaconfig 3.5-255." >&2
	    exit 0;;
	--) break;;
	-*) echo "$me: unknown option $1" >&2; shift; error=true;;
	*) break;;
	esac
done

case "$error" in
true)
	cat >&2 <<EOM
Usage: $me [-dehrsEKOSV] [-f config.sh] [-D symbol] [-D symbol=value]
                 [-U symbol] [-U symbol=] [-A command:symbol...]
  -d : use defaults for all answers.
  -e : go on without questioning past the production of config.sh.
  -f : specify an alternate default configuration file.
  -h : print this help message and exit (with an error status).
  -r : reuse C symbols value if possible (skips costly nm extraction).
  -s : silent mode, only echoes questions and essential information.
  -D : define symbol to have some value:
         -D symbol         symbol gets the value 'define'
         -D symbol=value   symbol gets the value 'value'
  -E : stop at the end of questions, after having produced config.sh.
  -K : do not use unless you know what you are doing.
  -O : let -D and -U override definitions from loaded configuration file.
  -S : perform variable substitutions on all .SH files (can mix with -f)
  -U : undefine symbol:
         -U symbol    symbol gets the value 'undef'
         -U symbol=   symbol gets completely empty
  -A : manipulate symbol after the platform specific hints have been applied:
	 -A symbol=value		append " "value to symbol
	 -A append:symbol=value		append value to symbol
	 -A define:symbol=value		define symbol to have value
         -A clear:symbol		define symbol to be ''
	 -A define:symbol		define symbol to be 'define'
	 -A eval:symbol=value		define symbol to be eval of value
	 -A prepend:symbol=value	prepend value to symbol
	 -A undef:symbol		define symbol to be 'undef'
	 -A undef:symbol=		define symbol to be ''
  -V : print version number and exit (with a zero status).
EOM
	exit 1
	;;
esac

: Sanity checks
case "$fastread$alldone" in
yescont|yesexit) ;;
*)
	case "$extractsh" in
	true) ;;
	*)
		if test ! -t 0; then
			echo "Say 'sh Configure', not 'sh <Configure'"
			exit 1
		fi
		;;
	esac
	;;
esac

exec 4>&1
case "$silent" in
true) exec 1>/dev/null;;
esac

touch optdef.sh
if grep -q '\\' optdef.sh >/dev/null 2>&1; then
	echo "Configure does not support \\ in -D or -U arguments" >&2
	exit 1
fi

: run the defines and the undefines, if any, but leave the file out there...
. ./optdef.sh
: create the posthint manipulation script and leave the file out there...
touch posthint.sh

: set package name
package='gtk-gnutella'
first=`echo $package | sed -e 's/^\(.\).*/\1/'`
last=`echo $package | sed -e 's/^.\(.*\)/\1/'`
case "`echo AbyZ | tr '[:lower:]' '[:upper:]' 2>/dev/null`" in
ABYZ) spackage=`echo $first | tr '[:lower:]' '[:upper:]'`$last;;
*) spackage=`echo $first | tr '[a-z]' '[A-Z]'`$last;;
esac

: script used to emulate mkdir -p
cat >mkdirp <<EOS
$startsh
EOS
cat >>mkdirp <<'EOS'
name=$1;
create="";
while test $name; do
	if test ! -d "$name"; then
		create="$name $create"
		name=`echo $name | sed -e "s|^[^/]*$||"`
		name=`echo $name | sed -e "s|\(.*\)/.*|\1|"`
	else
		name=""
	fi
done
for file in $create; do
	mkdir $file
done
EOS
chmod +x mkdirp
$eunicefix mkdirp

: Some greps do not return status, grrr.
echo "grimblepritz" >grimble
if grep blurfldyick grimble >/dev/null 2>&1 ; then
	contains=contains
elif grep grimblepritz grimble >/dev/null 2>&1 ; then
	contains=grep
else
	contains=contains
fi
rm -f grimble
: the following should work in any shell
case "$contains" in
contains*)
	echo " "
	echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
	cat >contains <<'EOSS'
grep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
EOSS
chmod +x contains
esac

: Find the path to the source tree
case "$src" in
'') case "$0" in
    */*) src=`echo $0 | sed -e 's%/[^/][^/]*$%%'`
         case "$src" in
	 /*)	;;
	 .)	;;
         *)	src=`cd ../$src && pwd` ;;
	 esac
         ;;
    *)   src='.';;
    esac;;
esac
case "$src" in
'')	src=/
	rsrc=/
	;;
/*)	rsrc="$src";;
*)	rsrc="../$src";;
esac
if test -f $rsrc/Configure && \
	$contains "^package='$package'\$" $rsrc/Configure >/dev/null 2>&1
then
   : found it, so we are ok.
else
	rsrc=''
	for src in . .. ../.. ../../.. ../../../..; do
		if test -f ../$src/Configure && \
			$contains "^package=$package$" ../$src/Configure >/dev/null 2>&1
		then
			rsrc=../$src
			break
		fi
	done
fi
case "$rsrc" in
'')
	cat <<EOM >&4

Sorry, I can't seem to locate the source dir for $package.  Please start
Configure with an explicit path -- i.e. /some/path/Configure.

EOM
	exit 1
	;;
../.)	rsrc='..';;
*)
	echo " "
	echo "Sources for $package found in \"$src\"." >&4
	;;
esac

: script used to extract .SH files with variable substitutions
cat >extract <<EOS
CONFIG=true
SRC="$src"
TOP=`cd ..; pwd 2>/dev/null`
EOS
cat >>extract <<'EOS'
echo "Doing variable substitutions on .SH files..."
if test -f "$SRC/MANIFEST"; then
	set x `awk '{print $1}' <$SRC/MANIFEST | grep '\.SH'`
else
	echo "(Looking for .SH files under the source directory.)"
	set x `(cd "$SRC"; find . -name "*.SH" -print)`
fi
shift
case $# in
0) set x `(cd "$SRC"; echo *.SH)`; shift;;
esac
if test ! -f "$SRC/$1"; then
	shift
fi
for file in $*; do
	case "$SRC" in
	".")
		case "$file" in
		*/*)
			dir=`expr X$file : 'X\(.*\)/'`
			file=`expr X$file : 'X.*/\(.*\)'`
			(cd $dir && . ./$file)
			;;
		*)
			. ./$file
			;;
		esac
		;;
	*)
		case "$file" in
		*/*)
			dir=`expr X$file : 'X\(.*\)/'`
			file=`expr X$file : 'X.*/\(.*\)'`
			./mkdirp $dir
			sh <"$SRC/$dir/$file"
			;;
		*)
			sh <"$SRC/$file"
			;;
		esac
		;;
	esac
done
if test -f "$SRC/config_h.SH"; then
	if test ! -f config.h; then
		sh <"$SRC/config_h.SH"
	fi
fi
EOS

: extract files and exit if asked to do so
case "$extractsh" in
true)
	case "$realsilent" in
	true) ;;
	*) exec 1>&4;;
	esac
	case "$config_sh" in
	'') config_sh='config.sh';;
	esac
	echo " "
	echo "Fetching answers from $config_sh..."
	cd ..
	. $config_sh
	test "$override" && . ./optdef.sh
	echo " "
	. UU/extract
	rm -rf UU
	echo "Extraction done."
	exit 0
	;;
esac

: Eunice requires " " instead of "", can you believe it
echo " "
: Here we go...
echo "Beginning of configuration questions for $package."

trap 'echo " "; test -d ../UU && rm -rf X $rmlist; exit 1' 1 2 3 15

: first determine how to suppress newline on echo command
echo " "
echo "Checking echo to see how to suppress newlines..."
(echo "hi there\c" ; echo " ") >.echotmp
if $contains c .echotmp >/dev/null 2>&1 ; then
	echo "...using -n."
	n='-n'
	c=''
else
	cat <<'EOM'
...using \c
EOM
	n=''
	c='\c'
fi
echo $n "The star should be here-->$c"
echo '*'
rm -f .echotmp

: Now test for existence of everything in MANIFEST
echo " "
if test -f "$rsrc/MANIFEST"; then
	echo "First let's make sure your kit is complete.  Checking..." >&4
	awk '$1 !~ /PACK[A-Z]+/ {print $1}' "$rsrc/MANIFEST" | \
		(split -l 50 2>/dev/null || split -50)
	rm -f missing
	tmppwd=`pwd`
	for filelist in x??; do
		(cd "$rsrc"; ls `cat "$tmppwd/$filelist"` \
			>/dev/null 2>>"$tmppwd/missing")
	done
	if test -s missing; then
		cat missing >&4
		cat >&4 <<'EOM'

THIS PACKAGE SEEMS TO BE INCOMPLETE.

You have the option of continuing the configuration process, despite the
distinct possibility that your kit is damaged, by typing 'y'es.  If you
do, don't blame me if something goes wrong.  I advise you to type 'n'o
and contact the author (gtk-gnutella-devel@lists.sourceforge.net).

EOM
		echo $n "Continue? [n] $c" >&4
		read ans
		case "$ans" in
		y*)
			echo "Continuing..." >&4
			rm -f missing
			;;
		*)
			echo "ABORTING..." >&4
			kill $$
			;;
		esac
	else
		echo "Looks good..."
	fi
else
	echo "There is no MANIFEST file.  I hope your kit is complete !"
fi
rm -f missing x??

: Find the appropriate value for a newline for tr
if test -n "$DJGPP"; then
       trnl='\012'
fi
if test X"$trnl" = X; then
	case "`echo foo | tr '\n' x 2>/dev/null`" in
	foox) trnl='\n' ;;
	esac
fi
if test X"$trnl" = X; then
	case "`echo foo | tr '\012' x 2>/dev/null`" in
	foox) trnl='\012' ;;
	esac
fi
if test X"$trnl" = X; then
       case "`echo foo | tr '\r\n' xy 2>/dev/null`" in
       fooxy) trnl='\n\r' ;;
       esac
fi
if test X"$trnl" = X; then
	cat <<EOM >&2

$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.

EOM
	exit 1
fi

: compute the number of columns on the terminal for proper question formatting
case "$COLUMNS" in
'') COLUMNS='80';;
esac

: set up the echo used in my read
myecho="case \"\$xxxm\" in
'') echo $n \"\$rp $c\" >&4;;
*) case \"\$rp\" in
	'') echo $n \"[\$xxxm] $c\";;
	*)
		if test \`echo \"\$rp [\$xxxm]  \" | wc -c\` -ge $COLUMNS; then
			echo \"\$rp\" >&4
			echo $n \"[\$xxxm] $c\" >&4
		else
			echo $n \"\$rp [\$xxxm] $c\" >&4
		fi
		;;
	esac;;
esac"

: now set up to do reads with possible shell escape and default assignment
cat <<EOSC >myread
$startsh
xxxm=\$dflt
$myecho
ans='!'
case "\$fastread" in
yes) case "\$dflt" in
	'') ;;
	*) ans='';
		case "\$silent-\$rp" in
		true-) ;;
		*) echo " " >&4;;
		esac;;
	esac;;
*) case "\$silent" in
	true) case "\$rp" in
		'') ans='';;
		esac;;
	esac;;
esac
while expr "X\$ans" : "X!" >/dev/null; do
	read answ
	set x \$xxxm
	shift
	aok=''; eval "ans=\\"\$answ\\"" && aok=y
	case  "\$answ" in
	"!")
		sh 1>&4
		echo " "
		$myecho
		;;
	!*)
		set x \`expr "X\$ans" : "X!\(.*\)\$"\`
		shift
		sh 1>&4 -c "\$*"
		echo " "
		$myecho
		;;
	"\$ans")
		case "\$ans" in
		\\&*)
			set x \`expr "X\$ans" : "X&\(.*\)\$"\`
			shift
			case "\$1" in
			-d)
				fastread=yes
				echo "(OK, I'll run with -d after this question.)" >&4
				;;
			-*)
				echo "*** Sorry, \$1 not supported yet." >&4
				;;
			esac
			$myecho
			ans=!
			;;
		esac;;
	*)
		case "\$aok" in
		y)
			echo "*** Substitution done -- please confirm."
			xxxm="\$ans"
			ans=\`echo $n "\$ans$c" | tr '$trnl' ' '\`
			xxxm="\$ans"
			ans=!
			;;
		*)
			echo "*** Error -- try again."
			ans=!
			;;
		esac
		$myecho
		;;
	esac
	case "\$ans\$xxxm\$nostick" in
	'')
		ans=!
		$myecho
		;;
	esac
done
case "\$ans" in
'') ans="\$xxxm";;
esac
EOSC

: create .config dir to save info across Configure sessions
test -d ../.config || mkdir ../.config
cat >../.config/README <<EOF
This directory created by Configure to save information that should
persist across sessions for $package.

You may safely delete it if you wish.
EOF

: general instructions
needman=true
firsttime=true
user=`(logname) 2>/dev/null`
case "$user" in
'') user=`whoami 2>&1`;;
esac
if $contains "^$user\$" ../.config/instruct >/dev/null 2>&1; then
	firsttime=false
	echo " "
	rp='Would you like to see the instructions?'
	dflt=n
	. ./myread
	case "$ans" in
	[yY]*) ;;
	*) needman=false;;
	esac
fi
if $needman; then
	cat <<EOH
 
This installation shell script will examine your system and ask you questions
to determine how the gtk-gnutella package should be installed. If you get
stuck on a question, you may use a ! shell escape to start a subshell or
execute a command.  Many of the questions will have default answers in square
brackets; typing carriage return will give you the default.

On some of the questions which ask for file or directory names you are allowed
to use the ~name construct to specify the login directory belonging to "name",
even if you don't have a shell which knows about that.  Questions where this is
allowed will be marked "(~name ok)".

EOH
	rp=''
	dflt='Type carriage return to continue'
	. ./myread
	cat <<'EOH'

The prompter used in this script allows you to use shell variables and
backticks in your answers.  You may use $1, $2, etc...  to refer to the words
in the default answer, as if the default line was a set of arguments given to a
script shell.  This means you may also use $* to repeat the whole default line,
so you do not have to re-type everything to add something to the default.

Everytime there is a substitution, you will have to confirm.  If there is an
error (e.g. an unmatched backtick), the default answer will remain unchanged
and you will be prompted again.

If you are in a hurry, you may run 'Configure -d'.  This will bypass nearly all
the questions and use the computed defaults (or the previous answers if there
was already a config.sh file). Type 'Configure -h' for a list of options.
You may also start interactively and then answer '& -d' at any prompt to turn
on the non-interactive behaviour for the remainder of the execution.

EOH
	. ./myread
	cat <<EOH

Much effort has been expended to ensure that this shell script will run on any
Unix system.  If despite that it blows up on yours, your best bet is to edit
Configure and run it again.  If you can't run Configure for some reason,
you'll have to generate a config.sh file by hand.  Whatever problems you
have, let me (gtk-gnutella-devel@lists.sourceforge.net) know how I blew it.

This installation script affects things in two ways:

1) it may do direct variable substitutions on some of the files included
   in this kit.
2) it builds a config.h file for inclusion in C programs.  You may edit
   any of these files as the need arises after running this script.

If you make a mistake on a question, there is no easy way to back up to it
currently.  The easiest thing to do is to edit config.sh and rerun all the SH
files.  Configure will offer to let you do this before it runs the SH files.

EOH
	dflt='Type carriage return to continue'
	. ./myread
	case "$firsttime" in
	true) echo $user >>../.config/instruct;;
	esac
fi

: script used to emit important warnings
cat >warn <<EOS
$startsh
if test \$# -gt 0; then
	echo "\$@" >msg
else
	cat >msg
fi
echo "*** WARNING:" >&4
sed -e 's/^/*** /' <msg >&4
echo "*** " >&4
cat msg >>config.msg
echo " " >>config.msg
rm -f msg
EOS
chmod +x warn
$eunicefix warn

: find out where common programs are
echo " "
echo "Locating common programs..." >&4
cat <<EOSC >loc
$startsh
case \$# in
0) exit 1;;
esac
thing=\$1
shift
dflt=\$1
shift
for dir in \$*; do
	case "\$thing" in
	.)
	if test -d \$dir/\$thing; then
		echo \$dir
		exit 0
	fi
	;;
	*)
	for thisthing in \$dir/\$thing; do
		: just loop through to pick last item
	done
	if test -f \$thisthing; then
		echo \$thisthing
		exit 0
	elif test -f \$thisthing$_exe; then
		echo \$thisthing
		exit 0
	elif test -f \$dir/\$thing.exe; then
		if test -n "$DJGPP"; then
			echo \$dir/\$thing.exe
		else
			: on Eunice apparently
			echo \$dir/\$thing
		fi
		exit 0
	fi
	;;
	esac
done
echo \$dflt
exit 1
EOSC
chmod +x loc
$eunicefix loc
loclist="
awk
cat
chgrp
chmod
chown
cp
echo
expr
grep
make
mkdir
mv
rm
sed
sort
touch
tr
uniq
"
trylist="
ar
bison
byacc
cpp
date
egrep
gmsgfmt
ln
msgfmt
msgmerge
nawk
nm
nroff
test
uname
wc
xgettext
"
pth=`echo $PATH | sed -e "s/$p_/ /g"`
pth="$pth /sbin /usr/sbin /lib /usr/lib /etc"
for file in $loclist; do
	eval xxx=\$$file
	case "$xxx" in
	/*|?:[\\/]*)
		if test -f "$xxx"; then
			: ok
		else
			./warn "no $xxx -- ignoring your setting for $file." 4>&4
			xxx=`./loc $file $file $pth`
		fi
		;;
	'') xxx=`./loc $file $file $pth`;;
	*) xxx=`./loc $xxx $xxx $pth`;;
	esac
	eval $file=$xxx
	eval _$file=$xxx
	case "$xxx" in
	/*)
		echo $file is in $xxx.
		;;
	?:[\\/]*)
		echo $file is in $xxx.
		;;
	*)
		echo "I don't know where '$file' is, and my life depends on it." >&4
		echo "Go find a public domain implementation or fix your PATH!" >&4
		exit 1
		;;
	esac
done
echo " "
echo "Don't worry if any of the following aren't found..."
say=offhand
for file in $trylist; do
	eval xxx=\$$file
	case "$xxx" in
	/*|?:[\\/]*)
		if test -f "$xxx"; then
			: ok
		else
			./warn "no $xxx -- ignoring your setting for $file." 4>&4
			xxx=`./loc $file $file $pth`
		fi
		;;
	'') xxx=`./loc $file $file $pth`;;
	*) xxx=`./loc $xxx $xxx $pth`;;
	esac
	eval $file=$xxx
	eval _$file=$xxx
	case "$xxx" in
	/*)
		echo $file is in $xxx.
		;;
	?:[\\/]*)
		echo $file is in $xxx.
		;;
	*)
		echo "I don't see $file out there, $say."
		say=either
		;;
	esac
done
case "$egrep" in
egrep$_exe|egrep)
	echo "Substituting grep for egrep."
	egrep=$grep
	_egrep=$_grep
	;;
esac
case "$ln" in
ln$_exe|ln)
	echo "Substituting cp for ln."
	ln=$cp
	_ln=$_cp
	;;
esac
case "$make" in
make$_exe|make)	
	case "$gmake" in
	gmake)
	echo "I can't find make or gmake, and my life depends on it." >&4
	echo "Go find a public domain implementation or fix your PATH setting!" >&4
	exit 1
	;;
	esac
	;;
esac	
case "$gmake" in
gmake$_exe|gmake)	;;
*)
	if test -f "/system/gnu_library/bin/ar.pm"; then
		: Stratus VOS
		echo "Substituting gmake for make."
		make=$gmake
		_make=$_gmake
	fi
	;;
esac
case "$gmsgfmt" in
gmsgfmt$_exe|gmsgfmt)
	echo "Substituting msgfmt for gmsgfmt."
	gmsgfmt=$msgfmt
	_gmsgfmt=$_msgfmt
	;;
*)
	if $gmsgfmt --statistics /dev/null >/dev/null 2>&1 &&
		(if $gmsgfmt --statistics /dev/null 2>&1 >/dev/null | \
			grep usage >/dev/null; then exit 0; else exit 1; fi)
	then
		echo "Your $gmsgfmt is not GNU msgfmt; substituting msgfmt."
		gmsgfmt=$msgfmt
		_gmsgfmt=$_msgfmt
	fi
	;;
esac
case "$xgettext" in
xgettext$_exe|xgettext)
	xgettext=":"
	_xgettext=":"
	;;
*)
	if $xgettext --omit-header --copyright-holder= /dev/null >/dev/null 2>&1 &&
		(if $xgettext --omit-header --copyright-holder= \
			/dev/null 2>&1 >/dev/null | \
			grep usage >/dev/null; then exit 0; else exit 1; fi)
	then
		echo "Your $xgettext is not GNU xgettext; ignoring it."
		xgettext=":"
		_xgettext=":"
	elif $xgettext --from-code=UTF-8 /dev/null >/dev/null 2>&1; then
		: ok
	else
		 echo "Your $xgettext does not support --from-code; ignoring it."
		 xgettext=":"
		 _xgettext=":"
	fi
	;;
esac
case "$test" in
test|test$_exe)
	echo "Hopefully test is built into your sh."
	test=test
	;;
*)
	if `sh -c "PATH= test true" >/dev/null 2>&1`; then
		echo "Using the test built into your sh."
		test=test
		_test=test
	fi
	;;
esac
case "$echo" in
echo|echo$_exe)
	echo "Hopefully echo is built into your sh."
	echo=echo
	;;
'') ;;
*)
	echo " "
echo "Checking compatibility between $_echo and builtin echo (if any)..." >&4
	$echo $n "hi there$c" >foo1
	echo $n "hi there$c" >foo2
	if cmp foo1 foo2 >/dev/null 2>&1; then
		echo "They are compatible.  In fact, they may be identical."
	else
		case "$n" in
		'-n') n='' c='\c';;
		*) n='-n' c='';;
		esac
		cat <<FOO
They are not compatible!  You are probably running ksh on a non-USG system.
I'll have to use $echo instead of the builtin, since Bourne shell doesn't
have echo built in and we may have to run some Bourne shell scripts.  That
means I'll have to use '$n$c' to suppress newlines now.  Life is ridiculous.

FOO
		$echo $n "The star should be here-->$c"
		$echo "*"
	fi
	$rm -f foo1 foo2
	;;
esac

: generate the trygcc script for later perusal
$cat <<EOS >trygcc
$startsh
EOS
$cat <<'EOSC' >>trygcc
case "$cc" in
'') ;;
*)  $rm -f try try.*
    $cat >try.c <<EOM
int main(int argc, char *argv[]) {
  (void) argc;
  (void) argv;
  return 0;
}
EOM
    if $cc -o try $ccflags $ldflags try.c; then
       :
    else
        echo "Uh-oh, the C compiler '$cc' doesn't seem to be working." >&4
        despair=yes
        trygcc=yes
        case "$cc" in
        *gcc*) trygcc=no ;;
        esac
        case "`$cc -v -c try.c 2>&1`" in
        *gcc*) trygcc=no ;;
        esac
        if $test X"$trygcc" = Xyes; then
            if gcc -o try -c try.c; then
                echo " "
                echo "You seem to have a working gcc, though." >&4
                rp="Would you like to use it?"
                dflt=y
                if $test -f myread; then
                    . ./myread
                else
                    if $test -f UU/myread; then
                        . ./UU/myread
                    else
                        echo "Cannot find myread, sorry.  Aborting." >&2
                        exit 1
                    fi
                fi  
                case "$ans" in
                [yY]*) cc=gcc; ccname=gcc; ccflags=''; despair=no;
                       $cat *.cbu >checktmp 2>/dev/null
                       if $contains ccflags checktmp >/dev/null; then
                           ./warn 4>&4 <<EOM 
Any previous setting of the C compiler flags has been lost.
It may be necessary to pass -Dcc=gcc to Configure right away.
EOM
                       fi;;
                esac
            fi
        fi
    fi
    $rm -f try try.*
    ;;
esac
EOSC

: generate the checkcc script for later perusal
$cat <<EOS >checkcc
$startsh
EOS
$cat <<'EOSC' >>checkcc
case "$cc" in        
'') ;;
*)  $rm -f try try.*              
    $cat >try.c <<EOM
int main(int argc, char *argv[]) {
  (void) argc;
  (void) argv;
  return 0;
}
EOM
    if $cc -o try $ccflags $ldflags try.c; then
       :
    else
        if $test X"$despair" = Xyes; then
           echo "Uh-oh, the C compiler '$cc' doesn't seem to be working." >&4
        fi
        $cat >&4 <<EOM         
You need to find a working C compiler.
Either (purchase and) install the C compiler supplied by your OS vendor,
or for a free C compiler try http://gcc.gnu.org/
I cannot continue any further, aborting.
EOM
        exit 1
    fi
    $rm -f try try.*
    ;;
esac
EOSC

: determine whether symbolic links are supported
echo " "
$rm -f blurfl sym
$touch blurfl
if $ln -s blurfl sym > /dev/null 2>&1 && $test -f sym; then
	echo "Symbolic links are supported." >&4
	lns="$ln -s"
else
	echo "Symbolic links are NOT supported." >&4
	lns="$ln"
fi
$rm -f blurfl sym

: determine whether symbolic links are supported
echo " "
case "$lns" in
*"ln"*" -s")
	echo "Checking how to test for symbolic links..." >&4
	$lns blurfl sym
	if $test "X$issymlink" = X; then
		case "$newsh" in
		'') sh     -c "PATH= test -h sym" >/dev/null 2>&1 ;;
		*)  $newsh -c "PATH= test -h sym" >/dev/null 2>&1 ;;
		esac
		if test $? = 0; then
			issymlink="test -h"
		else
			echo "Your builtin 'test -h' may be broken." >&4
			case "$test" in
			/*)	;;
			*)	pth=`echo $PATH | sed -e "s/$p_/ /g"`
				for p in $pth
				do
					if test -f "$p/$test"; then
						test="$p/$test"
						break
					fi
				done
				;;
			esac
			case "$test" in
			/*)
				echo "Trying external '$test -h'." >&4
				issymlink="$test -h"
				if $test ! -h sym >/dev/null 2>&1; then
					echo "External '$test -h' is broken, too." >&4
					issymlink=''
				fi
				;;
			*)	issymlink='' ;;
			esac
		fi
	fi
	if $test "X$issymlink" = X; then
		if $test -L sym 2>/dev/null; then
			issymlink="$test -L"
			echo "The builtin '$test -L' worked." >&4
		fi
	fi
	if $test "X$issymlink" != X; then
		echo "You can test for symbolic links with '$issymlink'." >&4
	else
		echo "I do not know how you can test for symbolic links." >&4
	fi
	$rm -f blurfl sym
	;;
*)	echo "No symbolic links, so not testing for their testing..." >&4
	;;
esac

: define absolute package source directory
case "$src" in
/*) pkgsrc=$src;;
*) pkgsrc=`cd $rsrc; pwd`;;
esac

: Duplicate the tree with symbolic links if -Dmksymlinks was supplied
case "$mksymlinks" in
$define|true|[yY]*)
	echo " "
	case "$src" in
	''|'.')	echo "Cannot create symlinks in the original directory." >&4
		exit 1
		;;
	*)	case "$lns:$issymlink" in
		*"ln"*" -s:"*"test -"?)
			echo "Creating the symbolic links..." >&4
			echo "(First creating the subdirectories...)" >&4
			cd ..
			awk '{print $1}' $src/MANIFEST | grep / | sed 's:/[^/]*$::' | \
				sort -u | while true
			do
				read dir
				test -z "$dir" && break
				./UU/mkdirp $dir 2>/dev/null
				if test -d $dir; then
					: ok
				else
					echo "Failed to create '$dir'.  Aborting." >&4
					exit 1
				fi
			done
			echo "(Now creating the symlinks...)" >&4
			awk '{print $1}' $src/MANIFEST | while true; do
				read filename
				test -z "$filename" && break
				if test -f $filename; then
					if $issymlink $filename; then
						rm -f $filename
					fi
				fi
				if test -f $filename; then
					echo "$filename already exists, not symlinking."
				else
					ln -s $pkgsrc/$filename $filename
				fi
			done
			echo "(Checking current directory...)" >&4
			cd UU
			awk '$1 !~ /PACK[A-Z]+/ {print $1}' "$rsrc/MANIFEST" | \
				(split -l 50 2>/dev/null || split -50)
			rm -f missing
			tmppwd=`pwd`
			for filelist in x??; do
				(cd ..; ls `cat "$tmppwd/$filelist"` \
					>/dev/null 2>>"$tmppwd/missing")
			done
			if test -s missing; then
				echo "Failed duplication of source tree.  Aborting." >&4
				exit 1
			fi
			;;
		*)	echo "(I cannot figure out how to do symbolic links, ignoring!)" >&4
			;;
		esac
		;;
	esac
	;;
esac

: see whether [:lower:] and [:upper:] are supported character classes
echo " "
case "`echo AbyZ | LC_ALL=C $tr '[:lower:]' '[:upper:]' 2>/dev/null`" in
ABYZ)
	echo "Good, your tr supports [:lower:] and [:upper:] to convert case." >&4
	up='[:upper:]'
	low='[:lower:]'
	;;
*)	# There is a discontinuity in EBCDIC between 'I' and 'J'
        # (0xc9 and 0xd1), therefore that is a nice testing point.
        if test "X$up" = X -o "X$low" = X; then
	    case "`echo IJ | LC_ALL=C $tr '[I-J]' '[i-j]' 2>/dev/null`" in
	    ij) up='[A-Z]'
	        low='[a-z]'
		;;
	    esac
        fi
	if test "X$up" = X -o "X$low" = X; then
	    case "`echo IJ | LC_ALL=C $tr I-J i-j 2>/dev/null`" in
	    ij) up='A-Z'
		low='a-z'
		;;
	    esac
        fi
	if test "X$up" = X -o "X$low" = X; then
	    case "`echo IJ | od -x 2>/dev/null`" in
	    *C9D1*|*c9d1*)
		echo "Hey, this might be EBCDIC." >&4
		if test "X$up" = X -o "X$low" = X; then
		    case "`echo IJ | \
				LC_ALL=C $tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
		    ij) up='[A-IJ-RS-Z]'
		        low='[a-ij-rs-z]'
			;;
		    esac
		fi
		if test "X$up" = X -o "X$low" = X; then
		    case "`echo IJ | LC_ALL=C $tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
		    ij) up='A-IJ-RS-Z'
		        low='a-ij-rs-z'
			;;
		    esac
		fi
		;;
	    esac
	fi
esac
case "`echo IJ | LC_ALL=C $tr \"$up\" \"$low\" 2>/dev/null`" in
ij)
    echo "Using $up and $low to convert case." >&4
    ;;
*)
    echo "I don't know how to translate letters from upper to lower case." >&4
    echo "Your tr is not acting any way I know of." >&4
    exit 1
    ;;
esac
: set up the translation script tr, must be called with ./tr of course
cat >tr <<EOSC
$startsh
case "\$1\$2" in
'[A-Z][a-z]') LC_ALL=C exec $tr '$up' '$low';;
'[a-z][A-Z]') LC_ALL=C exec $tr '$low' '$up';;
esac
LC_ALL=C exec $tr "\$@"
EOSC
chmod +x tr
$eunicefix tr

: setup for possible cross-compilation
run=''
to=:
from=:
usecrosscompile='undef'
targetarch=''
case "$usecrosscompile" in
$define|true|[yY]*)
	echo "Cross-compilation is not supported for this package." >&4
	exit 1
	;;
esac

: Determine the name of the machine
myuname=`$uname -a 2>/dev/null`
$test -z "$myuname" && myuname=`hostname 2>/dev/null`
myuname=`echo $myuname | $sed -e 's/^[^=]*=//' -e 's/\///g' | \
	./tr '[A-Z]' '[a-z]' | $tr $trnl ' '`
newmyuname="$myuname"
has_uname=
$test -f "$uname" && has_uname=y

: Guessing of the OS name -- half the following guesses are probably wrong...
: If you have better tests or hints, please send them to the metaconfig
: authors and to gtk-gnutella-devel@lists.sourceforge.net
$test -f /irix && osname=irix
$test -f /xenix && osname=sco_xenix
$test -f /dynix && osname=dynix
$test -f /dnix && osname=dnix
$test -f /lynx.os && osname=lynxos
$test -f /unicos && osname=unicos && osvers=`$uname -r`
$test -f /unicosmk && osname=unicosmk && osvers=`$uname -r`
$test -f /unicosmk.ar && osname=unicosmk && osvers=`$uname -r`
$test -f /bin/mips && /bin/mips && osname=mips
$test -d /NextApps && set X `hostinfo | $grep 'NeXT Mach.*:' | \
	$sed -e 's/://' -e 's/\./_/'` && osname=next && osvers=$4
$test -d /usr/apollo/bin && osname=apollo
$test -f /etc/saf/_sactab && osname=svr4
$test -d /usr/include/minix && osname=minix
$test -f /system/gnu_library/bin/ar.pm && osname=vos
if $test -d /MachTen -o -d /MachTen_Folder; then
	osname=machten
	if $test -x /sbin/version; then
		osvers=`/sbin/version | $awk '{print $2}' |
		$sed -e 's/[A-Za-z]$//'`
	elif $test -x /usr/etc/version; then
		osvers=`/usr/etc/version | $awk '{print $2}' |
		$sed -e 's/[A-Za-z]$//'`
	else
		osvers="$2.$3"
	fi
fi
$test -f /sys/posix.dll &&
	$test -f /usr/bin/what &&
	set X `/usr/bin/what /sys/posix.dll` &&
	$test "$3" = UWIN &&
	osname=uwin &&
	osvers="$5"
if $test "X$has_uname" != X; then
	set X $myuname
	shift
	case "$5" in
	fps*) osname=fps ;;
	mips*)
		case "$4" in
		umips) osname=umips ;;
		*) osname=mips ;;
		esac;;
	[23]100) osname=mips ;;
	next*) osname=next ;;
	i386*)
		tmp=`/bin/uname -X 2>/dev/null|awk '/3\.2v[45]/{ print $(NF) }'`
		if $test "$tmp" != "" -a "$3" = "3.2" -a -f '/etc/systemid'; then
			osname='sco'
			osvers=$tmp
		elif $test -f /etc/kconfig; then
			osname=isc
			if $test "$lns" = "$ln -s"; then
				osvers=4
			elif $contains _SYSV3 /usr/include/stdio.h > /dev/null 2>&1 ; then
				osvers=3
			elif $contains _POSIX_SOURCE /usr/include/stdio.h > /dev/null 2>&1
			then
				osvers=2
			fi
		fi
		tmp=''
		;;
	pc*)
		if $test -n "$DJGPP"; then
			osname=dos
			osvers=djgpp
		fi
		;;
	esac
	case "$1" in
	aix) osname=aix
		tmp=`( (oslevel) 2>/dev/null || echo "not found") 2>&1`
		case "$tmp" in
		'not found') osvers="$4"."$3" ;;
		'<3240'|'<>3240') osvers=3.2.0 ;;
		'=3240'|'>3240'|'<3250'|'<>3250') osvers=3.2.4 ;;
		'=3250'|'>3250') osvers=3.2.5 ;;
		*) osvers=$tmp;;
		esac
		;;
	bsd386) osname=bsd386
		osvers=`$uname -r`
		;;
	cygwin*) osname=cygwin
		osvers=`echo "$3" | sed -e 's/\(.*\)(.*/\1/'`
		;;
	mingw*) osname=mingw
		osvers=`echo "$3" | sed -e 's/\(.*\)(.*/\1/'`
		;;
	*dc.osx) osname=dcosx
		osvers="$3"
		;;
	dnix) osname=dnix
		osvers="$3"
		;;
	domainos) osname=apollo
		osvers="$3"
		;;
	dgux) osname=dgux 
		osvers="$3"
		;;
	dynixptx*) osname=dynixptx
		osvers=`echo "$4"|sed 's/^v//'`
		;;
	freebsd) osname=freebsd 
		osvers="$3" ;;
	genix) osname=genix ;;
	hp*) osname=hpux 
		osvers=`echo "$3" | $sed 's,.*\.\([0-9]*\.[0-9]*\),\1,'`
		;;
	irix*) osname=irix
		case "$3" in
		4*) osvers=4 ;;
		5*) osvers=5 ;;
		*)	osvers="$3" ;;
		esac
		;;
	linux) osname=linux
		case "$3" in
		*)	osvers="$3" ;;
		esac
		;;
	MiNT) osname=mint
		;;
	netbsd*) osname=netbsd
		osvers="$3"
		;;
	news-os) osvers="$3"
		case "$3" in
		4*) osname=newsos4 ;;
		*) osname=newsos ;;
		esac
		;;
	next*) osname=next ;;
	nonstop-ux) osname=nonstopux ;;
	openbsd) osname=openbsd
				osvers="$3"
				;;
	POSIX-BC | posix-bc ) osname=posix-bc
		osvers="$3"
		;;
	powerux | power_ux | powermax_os | powermaxos | \
	powerunix | power_unix) osname=powerux
		osvers="$3"
		;;
	qnx) osname=qnx
		osvers="$4"
		;;
	solaris) osname=solaris
		case "$3" in
		5*) osvers=`echo $3 | $sed 's/^5/2/g'` ;;
		*)	osvers="$3" ;;
		esac
		;;
	sunos) osname=sunos
		case "$3" in
		5*) osname=solaris
			osvers=`echo $3 | $sed 's/^5/2/g'` ;;
		*)	osvers="$3" ;;
		esac
		;;
	titanos) osname=titanos
		case "$3" in
		1*) osvers=1 ;;
		2*) osvers=2 ;;
		3*) osvers=3 ;;
		4*) osvers=4 ;;
		*)	osvers="$3" ;;
		esac
		;;
	ultrix) osname=ultrix
		osvers="$3"
		;;
	osf1|mls+)	case "$5" in
		alpha)
			osname=dec_osf
			osvers=`sizer -v | awk '{print $3}' | \
				./tr '[A-Z]' '[a-z]' | sed 's/^[xvt]//'`
			case "$osvers" in
			[1-9].[0-9]*) ;;
			*) osvers=`echo "$3" | sed 's/^[xvt]//'` ;;
			esac
			;;
		hp*)	osname=hp_osf1	;;
		mips)	osname=mips_osf1 ;;
		esac
		;;
	unixware) osname=svr5
		osvers="$4"
		;;
	uts)	osname=uts
		osvers="$3"
		;;
	vos) osvers="$3"
		;;
	$2) case "$osname" in
		*isc*) ;;
		*freebsd*) ;;
		svr*)
			: svr4.x or possibly later
			case "svr$3" in	
			${osname}*)
				osname=svr$3
				osvers=$4
				;;
			esac
			case "$osname" in
			svr4.0)
				: Check for ESIX
				if $test -f /stand/boot ; then
					eval `$grep '^INITPROG=[a-z/0-9]*$' /stand/boot`
					if $test -n "$INITPROG" -a -f "$INITPROG"; then
						isesix=`strings -a $INITPROG | \
							$grep 'ESIX SYSTEM V/386 Release 4.0'`
						if $test -n "$isesix"; then
							osname=esix4
						fi
					fi
				fi
				;;
			esac
			;;
		*)	if $test -f /etc/systemid; then
				osname=sco
				set `echo $3 | $sed 's/\./ /g'` $4
				if $test -f $src/hints/sco_$1_$2_$3.sh; then
					osvers=$1.$2.$3
				elif $test -f $src/hints/sco_$1_$2.sh; then
					osvers=$1.$2
				elif $test -f $src/hints/sco_$1.sh; then
					osvers=$1
				fi
			else
				case "$osname" in
				'') : Still unknown.  Probably a generic Sys V.
					osname="sysv"
					osvers="$3"
					;;
				esac
			fi
			;;
		esac
		;;
	*)	case "$osname" in
		'') : Still unknown.  Probably a generic BSD.
			osname="$1"
			osvers="$3"
			;;
		esac
		;;
	esac
else
	if $test -f /vmunix -a -f $src/hints/news_os.sh; then
		(what /vmunix | UU/tr '[A-Z]' '[a-z]') > UU/kernel.what 2>&1
		if $contains news-os UU/kernel.what >/dev/null 2>&1; then
			osname=news_os
		fi
		$rm -f UU/kernel.what
	elif $test -d c:/.; then
		set X $myuname
		osname=os2
		osvers="$5"
	fi
fi

: Try to determine whether config.sh was made on this system
case "$config_sh" in
'')
dflt=n
case "$knowitall" in
'')
	if test -f ../config.sh; then
		if $contains myuname= ../config.sh >/dev/null 2>&1; then
			eval "`$grep myuname= ../config.sh`"
		fi
		if test "X$myuname" = "X$newmyuname"; then
			dflt=y
		fi
	fi
	;;
*) dflt=y;;
esac

saved_osname="$osname"
saved_osvers="$osvers"
saved_libswanted="$libswanted"
tmp_n="$n"
tmp_c="$c"
tmp_sh="$sh"

: Get old answers from config file if it was generated on the same system
hint=default
if $test -f ../config.sh; then
	echo " "
	rp="I see a config.sh file.  Shall I use it to set the defaults?"
	. ./myread
	case "$ans" in
	n*|N*) echo "OK, I'll ignore it."
		mv ../config.sh ../config.sh.old
		myuname="$newmyuname"
		;;
	*)  echo "Fetching default answers from your old config.sh file..." >&4
		. ../config.sh
		cp ../config.sh .
		hint=previous
		case "$dflt" in
		n)
			echo " "
			rp="Do you want further invocations to use these defaults?"
			. ./myread
			case "$ans" in
			y*|Y*) myuname="$newmyuname";;
			esac
			;;
		esac
		;;
	esac
fi
;;
*)
	echo " "
	echo "Fetching default answers from $config_sh..." >&4
	cd ..
	cp $config_sh config.sh 2>/dev/null
	chmod +w config.sh
	. ./config.sh
	cd UU
	cp ../config.sh .
	hint=previous
	;;
esac
case "$sh" in
'') sh="$tmp_sh" ;;
esac
$test "$override" && . ./optdef.sh

: Restore computed paths
for file in $loclist $trylist; do
	eval $file="\$_$file"
done

osname="$saved_osname"
osvers="$saved_osvers"
n="$tmp_n"
c="$tmp_c"

case "$libswanted" in
"$saved_libswanted") ;;
*) libs='';;
esac
libswanted="$saved_libswanted"

. ./checkcc
case "$targetarch" in
'') ;;
*)  hostarch=$osname
	osname=`echo $targetarch|sed 's,^[^-]*-,,'`
	osvers=''
	;;
esac

: Process their -A options
. ./posthint.sh

: Ask them to confirm the OS name
cat << EOM

Configure uses the operating system name and version to set some defaults.
The default value is probably right if the name rings a bell. Otherwise,
since spelling matters for me, either accept the default or answer "none"
to leave it blank.

EOM
case "$osname" in
	''|' ')
		case "$hintfile" in
		''|' '|none) dflt=none ;;
		*)  dflt=`echo $hintfile | $sed -e 's/\.sh$//' -e 's/_.*$//'` ;;
		esac
		;;
	*) dflt="$osname" ;;
esac
rp="Operating system name?"
. ./myread
case "$ans" in
none)  osname='' ;;
*) osname=`echo "$ans" | $sed -e 's/[ 	][	]*/_/g' | ./tr '[A-Z]' '[a-z]'`;;
esac
echo " "
case "$osvers" in
	''|' ')
		case "$hintfile" in
		''|' '|none) dflt=none ;;
		*)	dflt=`echo $hintfile | $sed -e 's/\.sh$//' -e 's/^[^_]*//'`
			dflt=`echo $dflt | $sed -e 's/^_//' -e 's/_/./g'`
			case "$dflt" in
			''|' ') dflt=none ;;
			esac
			;;
		esac
		;;
	*) dflt="$osvers" ;;
esac
rp="Operating system version?"
. ./myread
case "$ans" in
none)  osvers='' ;;
*) osvers="$ans" ;;
esac

: who configured the system
cf_time=`LC_ALL=C; LANGUAGE=C; export LC_ALL; export LANGUAGE; $date 2>&1`
case "$cf_by" in
"")
	cf_by=`(logname) 2>/dev/null`
	case "$cf_by" in
	"")
		cf_by=`(whoami) 2>/dev/null`
		case "$cf_by" in
		"") cf_by=unknown ;;
		esac ;;
	esac ;;
esac

: determine the architecture name
echo " "
if xxx=`./loc arch blurfl $pth`; $test -f "$xxx"; then
	tarch=`arch`"-$osname"
elif xxx=`./loc uname blurfl $pth`; $test -f "$xxx" ; then
	if uname -m > tmparch 2>&1 ; then
		tarch=`$sed -e 's/ *$//' -e 's/ /_/g' \
			-e 's/$/'"-$osname/" tmparch`
	else
		tarch="$osname"
	fi
	$rm -f tmparch
else
	tarch="$osname"
fi
case "$myarchname" in
''|"$tarch") ;;
*)
	echo "(Your architecture name used to be $myarchname.)"
	archname=''
	;;
esac
case "$archname" in
'') dflt="$tarch";;
*) dflt="$archname";;
esac
rp='What is your architecture name'
. ./myread
archname="$ans"
myarchname="$tarch"

: allow them to override the AFS root
case "$afsroot" in
'')	afsroot=/afs ;;
*)	afsroot=$afsroot ;;
esac

: is AFS running?
echo " "
case "$afs" in
$define|true)	afs=true ;;
$undef|false)	afs=false ;;
*)	if $test -d $afsroot; then
		afs=true
	else
		afs=false
	fi
	;;
esac
if $afs; then
	echo "AFS may be running... I'll be extra cautious then..." >&4
else
	echo "AFS does not seem to be running..." >&4
fi

: decide how portable to be
case "$d_portable" in
"$define") dflt=y;;
*)	dflt=n;;
esac
$cat <<'EOH'
 
I can set things up so that your shell scripts and binaries are more portable,
at what may be a noticable cost in performance.  In particular, if you
ask to be portable, the following happens:

     1) Shell scripts will rely on the PATH variable rather than using
	the paths derived above.
     2) ~username interpretations will be done at run time rather than
	by Configure.

EOH
rp="Do you expect to run these scripts and binaries on multiple machines?"
. ./myread
case "$ans" in
	y*) d_portable="$define"
	;;
	*)  d_portable="$undef" ;;
esac

: set up shell script to do ~ expansion
cat >filexp <<EOSS
$startsh
: expand filename
case "\$1" in
 \~/*|\~)
	echo \$1 | $sed "s|~|\${HOME-\$LOGDIR}|"
	;;
 \~*)
	if $test -f /bin/csh; then
		/bin/csh -f -c "glob \$1"
		failed=\$?
		echo ""
		exit \$failed
	else
		name=\`$expr x\$1 : '..\([^/]*\)'\`
		dir=\`$sed -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}' </etc/passwd\`
		if $test ! -d "\$dir"; then
			me=\`basename \$0\`
			echo "\$me: can't locate home directory for: \$name" >&2
			exit 1
		fi
		case "\$1" in
		*/*)
			echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
			;;
		*)
			echo \$dir
			;;
		esac
	fi
	;;
*)
	echo \$1
	;;
esac
EOSS
chmod +x filexp
$eunicefix filexp

: now set up to get a file name
cat <<EOS >getfile
$startsh
EOS
cat <<'EOSC' >>getfile
tilde=''
fullpath=''
already=''
skip=''
none_ok=''
exp_file=''
nopath_ok=''
orig_rp="$rp"
orig_dflt="$dflt"
case "$gfpth" in
'') gfpth='.' ;;
esac

case "$fn" in
*\(*)
	: getfile will accept an answer from the comma-separated list
	: enclosed in parentheses even if it does not meet other criteria.
	expr "$fn" : '.*(\(.*\)).*' | $tr ',' $trnl >getfile.ok
	fn=`echo $fn | sed 's/(.*)//'`
	;;
esac

case "$fn" in
*:*)
	loc_file=`expr $fn : '.*:\(.*\)'`
	fn=`expr $fn : '\(.*\):.*'`
	;;
esac

case "$fn" in
*~*) tilde=true;;
esac
case "$fn" in
*/*) fullpath=true;;
esac
case "$fn" in
*+*) skip=true;;
esac
case "$fn" in
*n*) none_ok=true;;
esac
case "$fn" in
*e*) exp_file=true;;
esac
case "$fn" in
*p*) nopath_ok=true;;
esac

case "$fn" in
*f*) type='File';;
*d*) type='Directory';;
*l*) type='Locate';;
esac

what="$type"
case "$what" in
Locate) what='File';;
esac

case "$exp_file" in
'')
	case "$d_portable" in
	"$define") ;;
	*) exp_file=true;;
	esac
	;;
esac

cd ..
while test "$type"; do
	redo=''
	rp="$orig_rp"
	dflt="$orig_dflt"
	case "$tilde" in
	true) rp="$rp (~name ok)";;
	esac
	. UU/myread
	if test -f UU/getfile.ok && \
		$contains "^$ans\$" UU/getfile.ok >/dev/null 2>&1
	then
		value="$ans"
		ansexp="$ans"
		break
	fi
	case "$ans" in
	none)
		value=''
		ansexp=''
		case "$none_ok" in
		true) type='';;
		esac
		;;
	*)
		case "$tilde" in
		'') value="$ans"
			ansexp="$ans";;
		*)
			value=`UU/filexp $ans`
			case $? in
			0)
				if test "$ans" != "$value"; then
					echo "(That expands to $value on this system.)"
				fi
				;;
			*) value="$ans";;
			esac
			ansexp="$value"
			case "$exp_file" in
			'') value="$ans";;
			esac
			;;
		esac
		case "$fullpath" in
		true)
			case "$ansexp" in
			/*) value="$ansexp" ;;
			[a-zA-Z]:/*) value="$ansexp" ;;
			[a-zA-Z]:\\*) value="$ansexp" ;;
			*)
				redo=true
				case "$already" in
				true)
				echo "I shall only accept a full path name, as in /bin/ls." >&4
				echo "Use a ! shell escape if you wish to check pathnames." >&4
					;;
				*)
				echo "Please give a full path name, starting with slash." >&4
					case "$tilde" in
					true)
				echo "Note that using ~name is ok provided it expands well." >&4
						already=true
						;;
					esac
				esac
				;;
			esac
			;;
		esac
		case "$redo" in
		'')
			case "$type" in
			File)
				for fp in $gfpth; do
					if test "X$fp" = X.; then
					    pf="$ansexp"
					else    
					    pf="$fp/$ansexp"
					fi
					if test -f "$pf"; then
						type=''
					elif test -r "$pf" || (test -h "$pf") >/dev/null 2>&1
					then
						echo "($value is not a plain file, but that's ok.)"
						type=''
					fi
					if test X"$type" = X; then
					    value="$pf"
					    break
					fi
				done
				;;
			Directory)
				for fp in $gfpth; do
					if test "X$fp" = X.; then
					    dir="$ans"
					    direxp="$ansexp"
					else    
					    dir="$fp/$ansexp"
					    direxp="$fp/$ansexp"
					fi
					if test -d "$direxp"; then
						type=''
						value="$dir"
						break
					fi
				done
				;;
			Locate)
				if test -d "$ansexp"; then
					echo "(Looking for $loc_file in directory $value.)"
					value="$value/$loc_file"
					ansexp="$ansexp/$loc_file"
				fi
				if test -f "$ansexp"; then
					type=''
				fi
				case "$nopath_ok" in
				true)	case "$value" in
					*/*) ;;
					*)	echo "Assuming $value will be in people's path."
						type=''
						;;
					esac
					;;
				esac
				;;
			esac

			case "$skip" in
			true) type='';
			esac

			case "$type" in
			'') ;;
			*)
				if test "$fastread" = yes; then
					dflt=y
				else
					dflt=n
				fi
				rp="$what $value doesn't exist.  Use that name anyway?"
				. UU/myread
				dflt=''
				case "$ans" in
				y*) type='';;
				*) echo " ";;
				esac
				;;
			esac
			;;
		esac
		;;
	esac
done
cd UU
ans="$value"
rp="$orig_rp"
dflt="$orig_dflt"
rm -f getfile.ok
test "X$gfpthkeep" != Xy && gfpth=""
EOSC

: determine root of directory hierarchy where package will be installed.
case "$prefix" in
'')
	dflt=`./loc . /usr/local /usr/local /local /opt /usr`
	;;
*)
	dflt="$prefix"
	;;
esac
$cat <<EOM

By default, $package will be installed in $dflt/bin, manual
pages under $dflt/man, etc..., i.e. with $dflt as prefix for
all installation directories. Typically set to /usr/local, but you
may choose /usr if you wish to install $package among your system
binaries. If you wish to have binaries under /bin but manual pages
under /usr/local/man, that's ok: you will be prompted separately
for each of the installation directories, the prefix being only used
to set the defaults.

EOM
fn=d~
rp='Installation prefix to use?'
. ./getfile
oldprefix=''
case "$prefix" in
'') ;;
*)
	case "$ans" in
	"$prefix") ;;
	*) oldprefix="$prefix";;
	esac
	;;
esac
prefix="$ans"
prefixexp="$ansexp"

: set the prefixit variable, to compute a suitable default value
prefixit='case "$3" in
""|none)
	case "$oldprefix" in
	"") eval "$1=\"\$$2\"";;
	*)
		case "$3" in
		"") eval "$1=";;
		none)
			eval "tp=\"\$$2\"";
			case "$tp" in
			""|" ") eval "$1=\"\$$2\"";;
			*) eval "$1=";;
			esac;;
		esac;;
	esac;;
*)
	eval "tp=\"$oldprefix-\$$2-\""; eval "tp=\"$tp\"";
	case "$tp" in
	--|/*--|\~*--) eval "$1=\"$prefix/$3\"";;
	/*-$oldprefix/*|\~*-$oldprefix/*)
		eval "$1=\`echo \$$2 | sed \"s,^$oldprefix,$prefix,\"\`";;
	*) eval "$1=\"\$$2\"";;
	esac;;
esac'

: determine where private executables go
set dflt privlib lib/$package
eval $prefixit
$cat <<EOM

There are some auxiliary files for $package that need to be put into a
private library directory that is accessible by everyone.

EOM
fn=d~+
rp='Pathname where the private library files will reside?'
. ./getfile
if $test "X$privlibexp" != "X$ansexp"; then
	installprivlib=''
fi
privlib="$ans"
privlibexp="$ansexp"
if $afs; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in which
private files reside from the directory in which they are installed (and from
which they are presumably copied to the former directory by occult means).

EOM
	case "$installprivlib" in
	'') dflt=`echo $privlibexp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installprivlib";;
	esac
	fn=de~
	rp='Where will private files be installed?'
	. ./getfile
	installprivlib="$ans"
else
	installprivlib="$privlibexp"
fi

: set the prefixup variable, to restore leading tilda escape
prefixup='case "$prefixexp" in
"$prefix") ;;
*) eval "$1=\`echo \$$1 | sed \"s,^$prefixexp,$prefix,\"\`";;
esac'

: determine where public architecture dependent libraries go
set archlib archlib
eval $prefixit
case "$archlib" in
'')
	case "$privlib" in
	'')
		dflt=`./loc . "." $prefixexp/lib /usr/local/lib /usr/lib /lib`
		set dflt
		eval $prefixup
		;;
	*)  dflt="$privlib/$archname";;
	esac
	;;
*) dflt="$archlib";;
esac
cat <<EOM

$spackage contains architecture-dependent library files.  If you are
sharing libraries in a heterogeneous environment, you might store
these files in a separate location.  Otherwise, you can just include
them with the rest of the public library files.

EOM
fn=d+~
rp='Where do you want to put the public architecture-dependent libraries?'
. ./getfile
archlib="$ans"
archlibexp="$ansexp"

if $afs; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in which
private files reside from the directory in which they are installed (and from
which they are presumably copied to the former directory by occult means).

EOM
	case "$installarchlib" in
	'') dflt=`echo $archlibexp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installarchlib";;
	esac
	fn=de~
	rp='Where will architecture-dependent library files be installed?'
	. ./getfile
	installarchlib="$ans"
else
	installarchlib="$archlibexp"
fi
if $test X"$archlib" = X"$privlib"; then
	d_archlib="$undef"
else
	d_archlib="$define"
fi

: make some quick guesses about what we are up against
echo " "
$echo $n "Hmm...  $c"
echo exit 1 >bsd
echo exit 1 >usg
echo exit 1 >v7
echo exit 1 >osf1
echo exit 1 >eunice
echo exit 1 >xenix
echo exit 1 >venix
echo exit 1 >os2
echo exit 1 >gnu
echo exit 1 >linux
echo exit 1 >dos
echo exit 1 >windows
d_bsd="$undef"
d_linux="$undef"
d_dos="$undef"
d_os2="$undef"
d_windows="$undef"
$cat /usr/include/signal.h /usr/include/sys/signal.h >foo 2>/dev/null
if test -f /osf_boot || $contains 'OSF/1' /usr/include/ctype.h >/dev/null 2>&1
then
	echo "Looks kind of like an OSF/1 system, but we'll see..."
	echo exit 0 >osf1
elif test `echo abc | $tr a-z A-Z` = Abc ; then
	xxx=`./loc addbib blurfl $pth`
	if $test -f $xxx; then
	echo "Looks kind of like a USG system with BSD features, but we'll see..."
		echo exit 0 >bsd
		echo exit 0 >usg
	else
		if $contains SIGTSTP foo >/dev/null 2>&1 ; then
			echo "Looks kind of like an extended USG system, but we'll see..."
		else
			echo "Looks kind of like a USG system, but we'll see..."
		fi
		echo exit 0 >usg
	fi
elif $contains SIGTSTP foo >/dev/null 2>&1 ; then
	echo "Looks kind of like a BSD system, but we'll see..."
	d_bsd="$define"
	echo exit 0 >bsd
elif
	$rm --version 2>/dev/null >foo;
	$contains "Free Software Foundation" foo >/dev/null
then
	xxx=`uname`
	echo exit 0 >gnu
	echo "Looks kind of like a GNU/$xxx system, but we'll see..."
	if $test X$xxx = XLinux; then
		d_linux="$define"
		echo exit 0 >linux
	fi
else
	echo "Looks kind of like a Version 7 system, but we'll see..."
	echo exit 0 >v7
fi
case "$eunicefix" in
*unixtovms*)
	$cat <<'EOI'
There is, however, a strange, musty smell in the air that reminds me of
something...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
EOI
	echo exit 0 >eunice
	d_eunice="$define"
: it so happens the Eunice I know will not run shell scripts in Unix format
	;;
*)
	echo " "
	echo "Congratulations.  You aren't running Eunice."
	d_eunice="$undef"
	;;
esac
if test -d c:/.; then
	case "X${MACHTYPE:-nonesuchmach}" in
	*cygwin) echo " "; echo "Hah!... you're running under Cygwin!";;
	*msys) echo " "; echo "Hah!... you're running under MinGW!";;
	esac
	case "X${MACHTYPE:-nonesuchmach}" in
	*cygwin|*msys)
		echo exit 0 >windows
		d_windows="$define"
		;;
	esac
fi
case "$p_" in
:) ;;
*)
	$cat <<'EOI'
I have the feeling something is not exactly right, however...don't tell me...
EOI
	if test -n "$DJGPP"; then
		echo exit 0 >dos
		d_dos="$define"
	else
		$cat <<'EOI'
lemme think...does HAL ring a bell?...no, of course, you're only running OS/2!
EOI
		echo exit 0 >os2
		d_os2="$define"
	fi
	;;
esac
if test -f /xenix; then
	echo "Actually, this looks more like a XENIX system..."
	echo exit 0 >xenix
	d_xenix="$define"
else
	echo " "
	echo "It's not Xenix..."
	d_xenix="$undef"
fi
chmod +x xenix
$eunicefix xenix
if test -f /venix; then
	echo "Actually, this looks more like a VENIX system..."
	echo exit 0 >venix
else
	echo " "
	if ./xenix; then
		: null
	else
		echo "Nor is it Venix..."
	fi
fi
chmod +x bsd usg v7 osf1 eunice xenix venix dos os2 gnu linux windows
$eunicefix bsd usg v7 osf1 eunice xenix venix dos os2 gnu linux windows
$rm -f foo

: set up the script used to warn in case of inconsistency
cat <<EOS >whoa
$startsh
EOS
cat <<'EOSC' >>whoa
dflt=y
echo " "
echo "*** WHOA THERE!!! ***" >&4
echo "    The $hint value for \$$var on this machine was \"$was\"!" >&4
rp="    Keep the $hint value?"
. ./myread
case "$ans" in
y) td=$was; tu=$was;;
esac
EOSC

: function used to set '$1' to '$val'
setvar='var=$1; eval "was=\$$1"; td=$define; tu=$undef;
case "$val$was" in
$define$undef) . ./whoa; eval "$var=\$td";;
$undef$define) . ./whoa; eval "$var=\$tu";;
*) eval "$var=$val";;
esac'

: Determine the C compiler to be used
echo " "
case "$cc" in
'') dflt=cc;;
*) dflt="$cc";;
esac
rp="Use which C compiler?"
. ./myread
cc="$ans"

: See whether they have no cc but they do have gcc
. ./trygcc
if $test -f cc.cbu; then
    . ./cc.cbu
fi
. ./checkcc

: Check whether they have gcc in any guise.  
echo " "
echo "Checking for GNU cc in disguise and/or its version number..." >&4
$cat >try.c <<EOM
int main(void) {
#ifdef __GNUC__
gcc_version_major __GNUC__
#ifdef __GNUC_MINOR__
gcc_version_minor __GNUC__
#endif
#ifdef __GNUC_PATCHLEVEL__
gcc_version_patchlevel __GNUC_PATCHLEVEL__
#endif
#endif
}
EOM
if $cc -E try.c > try 2>&1
then
	gccversion=`$grep gcc_version_major try |
		sed 's/^.*gcc_version_major[\t ]*//'`
	case "$gccversion" in
	'') echo "You are not using GNU cc." ;;
	*)  echo "You are using GNU cc $gccversion."
	    ccname=gcc	
	    ;;
	esac
else
	gccversion=''
fi
$rm -f try try.*
case "$gccversion" in
1) cpp=`./loc gcc-cpp $cpp $pth` ;;
esac
case "$gccversion" in
'') gccosandvers='' ;;
*) gccshortvers=`echo "$gccversion"|sed 's/ .*//'`
   gccosandvers=`$cc -v 2>&1 | \
	$grep '/specs$'|sed "s!.*/[^-/]*-[^-/]*-\([^-/]*\)/$gccshortvers/specs!\1!"`
   gccshortvers=''
   case "$gccosandvers" in
   $osname) gccosandvers='' ;; # linux gccs seem to have no linux osvers, grr
   $osname$osvers) ;; # looking good
   $osname*) cat <<EOM >&4

*** WHOA THERE!!! ***

    Your gcc has not been compiled for the exact release of
    your operating system ($gccosandvers versus $osname$osvers).

    In general it is a good idea to keep gcc synchronized with
    the operating system because otherwise serious problems
    may ensue when trying to compile software, like Perl.

    I'm trying to be optimistic here, though, and will continue.
    If later during the configuration and build icky compilation
    problems appear (headerfile conflicts being the most common
    manifestation), I suggest reinstalling the gcc to match
    your operating system release.

EOM
      ;;
   *) gccosandvers='' ;; # failed to parse, better be silent
   esac
   ;;
esac
case "$ccname" in
'') ccname="$cc" ;;
esac

: gcc 3.1 complains about adding -Idirectories that it already knows about,
: so we will take those off from locincpth.
case "$gccversion" in
3)
    echo "main(){}">try.c
    for incdir in `$cc -v -c try.c 2>&1 | \
       sed '1,/^#include <\.\.\.>/d;/^End of search list/,$d;s/^ //'` ; do
       locincpth=`echo $locincpth | sed s!$incdir!!`
    done
    $rm -f try try.*
esac

: What should the include directory be ?
echo " "
$echo $n "Hmm...  $c"
incpath=''
mips_type=''
if $test -f /bin/mips && /bin/mips; then
	echo "Looks like a MIPS system..."
	$cat >usr.c <<'EOCP'
#ifdef SYSTYPE_BSD43
/bsd43
#endif
EOCP
	if cc -E usr.c > usr.out && $contains / usr.out >/dev/null 2>&1; then
		dflt='/bsd43/usr/include'
		incpath='/bsd43'
		mips_type='BSD 4.3'
	else
		mips_type='System V'
	fi
	$rm -f usr.c usr.out
	echo "and you're compiling with the $mips_type compiler and libraries."
	echo "exit 0" >mips
else
	echo "Doesn't look like a MIPS system."
	echo "exit 1" >mips
fi
chmod +x mips
$eunicefix mips

: What should the include directory be ?
echo " "
dflt='/usr/include'
case "$usrinc" in
'') dflt="$incpath/usr/include";;
*) dflt="$usrinc";;
esac
fn=d/
rp='Where are the include files you want to use?'
. ./getfile
usrinc="$ans"

: Define several unixisms.
: Hints files or command line option can be used to override them.
case "$_a" in
'') _a='.a';;
esac
case "$_o" in
'') _o='.o';;
esac

rm_try="$rm -f try try$_exe a.out .out try.[cho] try.$_o core core.try* try.core*"

: see how we invoke the C preprocessor
echo " "
echo "Now, how can we feed standard input to your C preprocessor..." >&4
cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC.XYZ
EOT
cd ..
if $test ! -f cppstdin; then
	echo "$startsh" >cppstdin
if $test "X$osname" = "Xaix" -a "X$gccversion" = X; then
	echo 'cat >.$$.c; rm -f .$$.u; '"$cc"' ${1+"$@"} -M -c .$$.c 2>/dev/null; \
	test -s .$$.u && \
	awk '"'"'$2 ~ /\.h$/ { print "# 0 \""$2"\"" }'"'"' .$$.u; \
	rm -f .$$.o .$$.u; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >> cppstdin
else
	echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >>cppstdin
fi; else
	echo "Keeping your $hint cppstdin wrapper."
fi
chmod 755 cppstdin
$eunicefix cppstdin
wrapper=`pwd`/cppstdin
ok='false'
cd UU

if $test "X$cppstdin" != "X" && \
	$cppstdin $cppminus <testcpp.c >testcpp.out 2>&1 && \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
then
	echo "You used to use $cppstdin $cppminus so we'll use that again."
	case "$cpprun" in
	'') echo "But let's see if we can live without a wrapper..." ;;
	*)
		if $cpprun $cpplast <testcpp.c >testcpp.out 2>&1 && \
			$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
		then
			echo "(And we'll use $cpprun $cpplast to preprocess directly.)"
			ok='true'
		else
			echo "(However, $cpprun $cpplast does not work, let's see...)"
		fi
		;;
	esac
else
	case "$cppstdin" in
	'') ;;
	*)
		echo "Good old $cppstdin $cppminus does not seem to be of any help..."
		;;
	esac
fi

if $ok; then
	: nothing
elif echo 'Maybe "'"$cc"' -E" will work...'; \
	$cc -E <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	x_cpp="$cc -E"
	x_minus='';
elif echo 'Nope...maybe "'"$cc"' -E -" will work...'; \
	$cc -E - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	x_cpp="$cc -E"
	x_minus='-';
elif echo 'Nope...maybe "'"$cc"' -P" will work...'; \
	$cc -P <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yipee, that works!"
	x_cpp="$cc -P"
	x_minus='';
elif echo 'Nope...maybe "'"$cc"' -P -" will work...'; \
	$cc -P - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "At long last!"
	x_cpp="$cc -P"
	x_minus='-';
elif echo 'No such luck, maybe "'$cpp'" will work...'; \
	$cpp <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "It works!"
	x_cpp="$cpp"
	x_minus='';
elif echo 'Nixed again...maybe "'$cpp' -" will work...'; \
	$cpp - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Hooray, it works!  I was beginning to wonder."
	x_cpp="$cpp"
	x_minus='-';
elif echo 'Uh-uh.  Time to get fancy.  Trying a wrapper...'; \
	$wrapper <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	x_cpp="$wrapper"
	x_minus=''
	echo "Eureka!"
else
	dflt=''
	rp="No dice.  I can't find a C preprocessor.  Name one:"
	. ./myread
	x_cpp="$ans"
	x_minus=''
	$x_cpp <testcpp.c >testcpp.out 2>&1
	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
		echo "OK, that will do." >&4
	else
echo "Sorry, I can't get that to work.  Go find one and rerun Configure." >&4
		exit 1
	fi
fi

case "$ok" in
false)
	cppstdin="$x_cpp"
	cppminus="$x_minus"
	cpprun="$x_cpp"
	cpplast="$x_minus"
	set X $x_cpp
	shift
	case "$1" in
	"$cpp")
		echo "Perhaps can we force $cc -E using a wrapper..."
		if $wrapper <testcpp.c >testcpp.out 2>&1; \
			$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
		then
			echo "Yup, we can."
			cppstdin="$wrapper"
			cppminus='';
		else
			echo "Nope, we'll have to live without it..."
		fi
		;;
	esac
	case "$cpprun" in
	"$wrapper")
		cpprun=''
		cpplast=''
		;;
	esac
	;;
esac

case "$cppstdin" in
"$wrapper"|'cppstdin') ;;
*) $rm -f $wrapper;;
esac
$rm -f testcpp.c testcpp.out

: Set private lib path
case "$plibpth" in
'') if ./mips; then
		plibpth="$incpath/usr/lib /usr/local/lib /usr/ccs/lib"
	fi;;
esac
case "$libpth" in
' ') dlist='';;
'') dlist="$loclibpth $plibpth $glibpth";;
*) dlist="$libpth";;
esac

: Now check and see which directories actually exist, avoiding duplicates
libpth=''
for xxx in $dlist
do
    if $test -d $xxx; then
		case " $libpth " in
		*" $xxx "*) ;;
		*) libpth="$libpth $xxx";;
		esac
    fi
done
$cat <<'EOM'

Some systems have incompatible or broken versions of libraries.  Among
the directories listed in the question below, please remove any you
know not to be holding relevant libraries, and add any that are needed.
Say "none" for none.

EOM
case "$libpth" in
'') dflt='none';;
*)
	set X $libpth
	shift
	dflt=${1+"$@"}
	;;
esac
rp="Directories to use for library searches?"
. ./myread
case "$ans" in
none) libpth=' ';;
*) libpth="$ans";;
esac

: determine optimize, if desired, or use for debug flag also
case "$optimize" in
' '|$undef) dflt='none';;
'')
	case "$gccversion" in
	'') dflt='-O';;
	*) dflt='-O2 -g';;
	esac
	;;
*) dflt="$optimize";;
esac
case "$gccversion" in
'') $cat <<EOH

Some C compilers have problems with their optimizers.  By default, $package
compiles with the -O flag to use the optimizer.  Alternately, you might want
to use the symbolic debugger, which uses the -g flag (on traditional Unix
systems).  Either flag can be specified here.  To use neither flag, specify
the word "none".

EOH
	;;
*) $cat <<EOH

With the GNU C compiler, it is possible to supply both -O2 and -g flags, to
be able to reasonably optimize, whilst retaining the ability to use a
symbolic debugger.  Either flag can be specified here.  To use neither flag,
specify the word "none".

EOH
	;;
esac
rp="What optimizer/debugger flag should be used?"
. ./myread
optimize="$ans"
case "$optimize" in
'none') optimize=" ";;
esac

: see whether we need -pthread at the compile/link stage
case "$pthread" in
''|$undef)
	$cat > try.c <<'EOF'
int main() { return 0; }
EOF
	if $cc -pthread -c try.c >/dev/null 2>&1; then
		dflt='-pthread'
	else
		dflt='none'
	fi
	;;
*) dflt="$pthread";;
esac
$cat <<EOH

Some C compilers need to have special flags supplied at compile and link time
to be able to generate code that will work correctly with POSIX threads.
When no specific flags are required, specify the word "none".

EOH
rp="What thread-support compiler/linker flag should be used?"
. ./myread
pthread="$ans"
case "$pthread" in
'none') pthread="";;
esac

dflt=''
: We will not override a previous value, but we might want to
: augment a hint file
case "$hint" in
default|recommended)
	case "$gccversion" in
	1) dflt='-fpcc-struct-return' ;;
	esac
	case "$gccversion" in
	2) if test -d /etc/conf/kconfig.d &&
			$contains _POSIX_VERSION $usrinc/sys/unistd.h >/dev/null 2>&1
		then
			dflt="$dflt -posix"
		fi
		;;
	esac
	case "$gccversion" in
	1|2) dflt="$dflt -Wall";;
	*) dflt="$dflt -W -Wall -Wformat=2 -Wshadow";;
	esac
	;;
esac

case "$mips_type" in
*BSD*|'') inclwanted="$locincpth $usrinc";;
*) inclwanted="$locincpth $inclwanted $usrinc/bsd";;
esac
for thisincl in $inclwanted; do
	if $test -d $thisincl; then
		if $test x$thisincl != x$usrinc; then
			case "$dflt" in
			*$thisincl*);;
			*) dflt="$dflt -I$thisincl";;
			esac
		fi
	fi
done

inctest='if $contains $2 $usrinc/$1 >/dev/null 2>&1; then
	xxx=true;
elif $contains $2 $usrinc/sys/$1 >/dev/null 2>&1; then
	xxx=true;
else
	xxx=false;
fi;
if $xxx; then
	case "$dflt" in
	*$2*);;
	*) dflt="$dflt -D$2";;
	esac;
fi'

if ./osf1; then
	set signal.h __LANGUAGE_C__; eval $inctest
else
	set signal.h LANGUAGE_C; eval $inctest
fi

case "$hint" in
default|recommended) dflt="$dflt $ccflags" ;;
*) dflt="$ccflags";;
esac

case "$dflt" in
''|' ') dflt=none;;
esac
$cat <<EOH

Your C compiler may want other flags.  For this question you should include
-I/whatever and -DWHATEVER flags and any other flags used by the C compiler,
but you should NOT include libraries or ld flags like -lwhatever.

To use no flags, specify the word "none".

EOH
set X $dflt
shift
dflt=${1+"$@"}
rp="Any additional cc flags?"
. ./myread
case "$ans" in
none) ccflags='';;
*) ccflags="$ans";;
esac

: the following weeds options from ccflags that are of no interest to cpp
cppflags="$ccflags"
case "$gccversion" in
1) cppflags="$cppflags -D__GNUC__"
esac
case "$mips_type" in
'');;
*BSD*) cppflags="$cppflags -DSYSTYPE_BSD43";;
esac
case "$cppflags" in
'');;
*)
	echo " "
	echo "Let me guess what the preprocessor flags are..." >&4
	set X $cppflags
	shift
	cppflags=''
	$cat >cpp.c <<'EOM'
#define BLURFL foo

BLURFL xx LFRULB
EOM
	previous=''
	for flag in $*
	do
		case "$flag" in
		-*) ftry="$flag";;
		*) ftry="$previous $flag";;
		esac
		if $cppstdin -DLFRULB=bar $ftry $cppminus <cpp.c \
			>cpp1.out 2>/dev/null && \
			$cpprun -DLFRULB=bar $ftry $cpplast <cpp.c \
			>cpp2.out 2>/dev/null && \
			$contains 'foo.*xx.*bar' cpp1.out >/dev/null 2>&1 && \
			$contains 'foo.*xx.*bar' cpp2.out >/dev/null 2>&1
		then
			cppflags="$cppflags $ftry"
			previous=''
		else
			previous="$flag"
		fi
	done
	set X $cppflags
	shift
	cppflags=${1+"$@"}
	case "$cppflags" in
	*-*)  echo "They appear to be: $cppflags";;
	esac
	$rm -f cpp.c cpp?.out
	;;
esac

: flags used in final linking phase
case "$ldflags" in
'') if ./venix; then
		dflt='-i -z'
	else
		dflt=''
	fi
	case "$ccflags" in
	*-posix*) dflt="$dflt -posix" ;;
	esac
	;;
*) dflt="$ldflags";;
esac

: Try to guess additional flags to pick up local libraries.
for thislibdir in $libpth; do
	case " $loclibpth " in
	*" $thislibdir "*)
		case "$dflt " in 
		*"-L$thislibdir "*) ;;
		*)  dflt="$dflt -L$thislibdir" ;;
		esac
		;;
	esac
done

case "$dflt" in
'') dflt='none' ;;
*) set X $dflt; shift; dflt="$@";;
esac

$cat <<EOH

Your C linker may need flags.  For this question you should
include -L/whatever and any other flags used by the C linker, but you
should NOT include libraries like -lwhatever.

Make sure you include the appropriate -L/path flags if your C linker
does not normally search all of the directories you specified above,
namely
	$libpth
To use no flags, specify the word "none".

EOH

rp="Any additional ld flags (NOT including libraries)?"
. ./myread
case "$ans" in
none) ldflags='';;
*) ldflags="$ans";;
esac
rmlist="$rmlist pdp11"

: coherency check
echo " "
echo "Checking your choice of C compiler and flags for coherency..." >&4
set X $cc $optimize $pthread $ccflags $ldflags -o try try.c
shift
$cat >try.msg <<EOM
I've tried to compile and run a simple program with:

	$*
	./try

and I got the following output:

EOM
$cat > try.c <<'EOF'
int main() { return 0; }
EOF
dflt=y
if sh -c "$cc $optimize $ccflags $ldflags -o try try.c" >>try.msg 2>&1; then
	if sh -c './try' >>try.msg 2>&1; then
		dflt=n
	else
		echo "The program compiled OK, but exited with status $?." >>try.msg
		rp="You have a problem.  Shall I abort Configure"
		dflt=y
	fi
else
	echo "I can't compile the test program." >>try.msg
	rp="You have a BIG problem.  Shall I abort Configure"
	dflt=y
fi
case "$dflt" in
y)
	$cat try.msg >&4
	case "$knowitall" in
	'')
		echo "(The supplied flags might be incorrect with this C compiler.)"
		;;
	*) dflt=n;;
	esac
	echo " "
	. ./myread
	case "$ans" in
	n*|N*) ;;
	*)	echo "Ok.  Stopping Configure." >&4
		exit 1
		;;
	esac
	;;
n) echo "OK, that should do.";;
esac
$rm_try

: determine filename position in cpp output
echo " "
echo "Computing filename position in cpp output for #include directives..." >&4
echo '#include <stdio.h>' > foo.c
case "$osname" in
vos)
	testaccess=-e
	cppfilter="tr '\\\\>' '/' |"
	;;
*)
	testaccess=-r
	cppfilter=''
	;;
esac
$cat >fieldn <<EOF
$startsh
$cppstdin $cppminus <foo.c 2>/dev/null | \
$grep '^[ 	]*#.*stdio\.h' | \
while read cline; do
	pos=1
	set \$cline
	while $test \$# -gt 0; do
		if $test $testaccess \`echo \$1 | $tr -d '"'\`; then
			echo "\$pos"
			exit 0
		fi
		shift
		pos=\`expr \$pos + 1\`
	done
done
EOF
chmod +x fieldn
fieldn=`./fieldn`
$rm -f foo.c fieldn
case $fieldn in
'') pos='???';;
1) pos=first;;
2) pos=second;;
3) pos=third;;
*) pos="${fieldn}th";;
esac
echo "Your cpp writes the filename in the $pos field of the line."

: locate header file
$cat >findhdr <<EOF
$startsh
wanted=\$1
name=''
for usrincdir in $usrinc; do
	if test -f \$usrincdir/\$wanted; then
		echo "\$usrincdir/\$wanted"
		exit 0
	fi
done
awkprg='{ print \$$fieldn }'
echo "#include <\$wanted>" > foo\$\$.c
$cppstdin $cppminus $cppflags < foo\$\$.c 2>/dev/null | \
$cppfilter $grep "^[ 	]*#.*\$wanted" | \
while read cline; do
	name=\`echo \$cline | $awk "\$awkprg" | $tr -d '"'\`
	case "\$name" in
	*[/\\\\]\$wanted) echo "\$name"; exit 1;;
	*[\\\\/]\$wanted) echo "\$name"; exit 1;;
	*) exit 2;;
	esac
done
status=\$?
$rm -f foo\$\$.c
if test \$status -eq 1; then
	exit 0
fi
exit 1
EOF
chmod +x findhdr
$eunicefix findhdr

: define an alternate in-header-list? function
inhdr='echo " "; td=$define; tu=$undef; yyy=$@;
cont=true; xxf="echo \"<\$1> found.\" >&4";
case $# in 2) xxnf="echo \"<\$1> NOT found.\" >&4";;
*) xxnf="echo \"<\$1> NOT found, ...\" >&4";;
esac;
case $# in 4) instead=instead;; *) instead="at last";; esac;
while $test "$cont"; do
	xxx=`./findhdr $1`
	var=$2; eval "was=\$$2";
	if $test "$xxx" && $test -r "$xxx";
	then eval $xxf;
	eval "case \"\$$var\" in $undef) . ./whoa; esac"; eval "$var=\$td";
		cont="";
	else eval $xxnf;
	eval "case \"\$$var\" in $define) . ./whoa; esac"; eval "$var=\$tu"; fi;
	set $yyy; shift; shift; yyy=$@;
	case $# in 0) cont="";;
	2) xxf="echo \"but I found <\$1> $instead.\" >&4";
		xxnf="echo \"and I did not find <\$1> either.\" >&4";;
	*) xxf="echo \"but I found <\$1\> instead.\" >&4";
		xxnf="echo \"there is no <\$1>, ...\" >&4";;
	esac;
done;
while $test "$yyy";
do set $yyy; var=$2; eval "was=\$$2";
	eval "case \"\$$var\" in $define) . ./whoa; esac"; eval "$var=\$tu";
	set $yyy; shift; shift; yyy=$@;
done'

: see if this is a malloc.h system
set malloc.h i_malloc
eval $inhdr

: see if stdlib is available
set stdlib.h i_stdlib
eval $inhdr

: compute shared library extension
case "$so" in
'')
	if xxx=`./loc libc.sl X $libpth`; $test -f "$xxx"; then
		dflt='sl'
	else
		dflt='so'
	fi
	;;
*) dflt="$so";;
esac
$cat <<EOM

On some systems, shared libraries may be available.  Answer 'none' if
you want to suppress searching of shared libraries for the remainder
of this configuration.

EOM
rp='What is the file extension used for shared libraries?'
. ./myread
so="$ans"

: Looking for optional libraries
echo " "
echo "Checking for optional libraries..." >&4
case "$libs" in
' '|'') dflt='';;
*) dflt="$libs";;
esac
case "$libswanted" in
'') libswanted='c_s';;
esac
case "$usesocks" in
"$define") libswanted="$libswanted socks5 socks5_sh" ;;
esac
echo "extern void abort(void); int main(void) { abort(); return 0; }" > lt.c
libsfound=''
libsfiles=''
libsdirs=''
libspath=''
for thisdir in $libpth $xlibpth; do
  test -d $thisdir && libspath="$libspath $thisdir"
done
for thislib in $libswanted; do
	for thisdir in $libspath; do
	    xxx=''
	    if $test ! -f "$xxx" ; then
			xxx=`ls $thisdir/lib$thislib.$so.[0-9]* 2>/dev/null | $sed -n '1p'`
			$test -f "$xxx" && eval $libscheck
			$test -f "$xxx" && libstyle=shared
	    fi
	    if test ! -f "$xxx"; then
			xxx=$thisdir/lib$thislib.$so
			$test -f "$xxx" && eval $libscheck
			$test -f "$xxx" && libstyle=shared
	    fi	
	    if test ! -f "$xxx"; then
			xxx=$thisdir/lib$thislib$_a
	        $test -f "$xxx" && eval $libscheck
			$test -f "$xxx" && libstyle=static
	    fi
	    if test ! -f "$xxx"; then
			xxx=$thisdir/$thislib$_a
	        $test -f "$xxx" && eval $libscheck
			$test -f "$xxx" && libstyle=static
	    fi
	    if test ! -f "$xxx"; then
			xxx=$thisdir/lib${thislib}_s$_a
	        $test -f "$xxx" && eval $libscheck
			$test -f "$xxx" && libstyle=static
			$test -f "$xxx" && thislib=${thislib}_s
	    fi
	    if test ! -f "$xxx"; then
			xxx=$thisdir/Slib$thislib$_a
	        $test -f "$xxx" && eval $libscheck
			$test -f "$xxx" && libstyle=static
	    fi
	    if $test -f "$xxx"; then
			if $cc -o lt $ccflags $ldflags lt.c -l$thislib >/dev/null 2>&1;
			then
				linkmsg=""
			else
				linkmsg=" but I can't link against it"
			fi
			case "$libstyle" in
			shared) echo "Found -l$thislib (shared)$linkmsg." ;;
			static) echo "Found -l$thislib$linkmsg." ;;
			*)      echo "Found -l$thislib ($libstyle)$linkmsg." ;;
			esac
			case " $dflt " in
			*"-l$thislib "*) ;;
			*)
				case "$linkmsg" in
				'')
					dflt="$dflt -l$thislib"
					libsfound="$libsfound $xxx"
					yyy=`basename $xxx`
					libsfiles="$libsfiles $yyy"
					yyy=`echo $xxx|$sed -e "s%/$yyy\\$%%"`
					case " $libsdirs " in
					*" $yyy "*) ;;
					*) libsdirs="$libsdirs $yyy" ;;
					esac
				   ;;
				esac
				;;
			esac
			break
	    fi	
	done
	if $test ! -f "$xxx"; then
		if $cc -o lt $ccflags $ldflags lt.c -l$thislib >/dev/null 2>&1
		then
			echo "Found -l$thislib (via $cc)."
			case " $dflt " in
			*"-l$thislib "*) ;;
			*) dflt="$dflt -l$thislib";;
			esac
		else
			echo "No -l$thislib."
		fi
	fi
done
set X $dflt
shift
dflt="$*"
case "$libs" in
'') dflt="$dflt";;
*) dflt="$libs";;
esac
case "$dflt" in
' '|'') dflt='none';;
esac
$rm -f lt.c lt

$cat <<EOM

In order to compile $package on your machine, a number of libraries
are usually needed.  Include any other special libraries here as well.
Say "none" for none.  The default list is almost always right.
EOM

echo " "
rp="Which libraries to use?"
. ./myread
case "$ans" in
none) libs=' ';;
*) libs="$ans";;
esac

: determine which malloc to compile in
echo " "
case "$usemymalloc" in
[yY]*|true|$define) dflt='y' ;;
[nN]*|false|$undef) dflt='n' ;;
*) dflt=y ;;
esac
$cat <<EOM
$spackage comes with its own malloc() implementation that will supersede
the version included in your C library.  Since proper memory allocation is
critical, you may choose to opt out from this specific implementation and
rely on the (hopefully) more thoroughly tested version in the C library.

If you change your mind later, you can always re-run this configuration
script and recompile $package from scratch.

EOM
rp="Do you wish to attempt to use the malloc() that comes with $package?"
. ./myread
usemymalloc="$ans"
case "$ans" in
y*|true)
	usemymalloc='y'
	mallocsrc='malloc.c'
	mallocobj="malloc$_o"
	d_mymalloc="$define"
	case "$libs" in
	*-lmalloc*)
		: Remove malloc from list of libraries to use
		echo "Removing unneeded -lmalloc from library list" >&4
		set `echo X $libs | $sed -e 's/-lmalloc / /' -e 's/-lmalloc$//'`
		shift
		libs="$*"
		echo "libs = $libs" >&4
		;;
	esac
	;;
*)
	usemymalloc='n'
	mallocsrc=''
	mallocobj=''
	d_mymalloc="$undef"
	;;
esac

: determine whether this is an official build
case "$official" in
false)
	official=false
	val="$undef"
	echo " "
	./warn 'This build will not be suitable for distribution.' 4>&4

;;
*)
	val="$define"
	official=true
	;;
esac
set d_official
eval $setvar

: ask them whether they want remote control support
$cat <<EOM

$spackage has a raw remote control service.

Currently you can create searches, connect to nodes, and print and 
set the values of properties as well as read the 'tooltips'.  It is
not completely functional, but you may choose to enable it here at
compile time.  The feature will need activation from the GUI.

For more information, see doc/other/shell.txt

EOM
case "$remotectrl" in
true) dflt=y;;
*) dflt=n;;
esac
rp="Enable remote control service"
. ./myread
val="$ans"
case "$ans" in
y) val="$define";;
*) val="$undef";;
esac
set d_remotectrl
eval $setvar
case "$d_remotectrl" in
$define) remotectrl=true;;
*) remotectrl=false;;
esac

: look whether they wish to run headless
$cat <<EOM

$spackage can run without any GUI interface in so-called "headless" mode.
Therefore, monitoring of operations for $package will have to be done
without relying on any GUI, and the configuration is done via files only.

EOM
case "$d_headless" in
"$define") dflt=y;;
*) dflt=n;;
esac
rp="Run without any GUI interface"
. ./myread
case "$ans" in
y) val="$define";;
*) val="$undef";;
esac
set d_headless
eval $setvar

: ask them wich GTK+ version they want
echo " "
case "$d_headless" in
"$define")
	echo "Turning off GTK+ since you want to run without any GUI" >&4
	d_usegtk1="$undef";
	d_usegtk2="$undef";
	;;
*)
	$cat <<'EOM'
I can compile for the GTK+ 1.x version or for the GTK+ 2.x version.
The GTK1 frontend will use much less CPU than the GTK2 one, so if you
have a slow 32-bit CPU, you are encouraged to choose GTK1.
On 64-bit platforms, you need to choose GTK2 since GTK1 is not 64-bit safe.

EOM
	case "$gtkversion" in
	'') dflt=2;;
	2) dflt=2;;
	*) dflt=1;;
	esac
	rp="Use which GTK toolkit (1 or 2)"
	. ./myread
	case "$ans" in
	2)
		gtkversion=2; gtkpackage=gtk+-2.0
		d_usegtk2="$define"; d_usegtk1="$undef";;
	*)
		gtkversion=1; gtkpackage=gtk+
		d_usegtk1="$define"; d_usegtk2="$undef";;
	esac
	;;
esac

: decide which version of GLib to use -- tied to the choice of GTK
case "$gtkversion" in
1) ver=1;;
*) ver=2;;
esac
case "$ver" in
2)
	glibversion=2; glibpackage="glib-2.0 gobject-2.0 gthread-2.0"
	d_useglib2="$define"; d_useglib1="$undef";;
*)
	glibversion=1; glibpackage="glib gthread"
	d_useglib1="$define"; d_useglib2="$undef";;
esac

: determine where public executables go
echo " "
set dflt bin bin
eval $prefixit
fn=d~
rp='Pathname where the public executables will reside?'
. ./getfile
if $test "X$ansexp" != "X$binexp"; then
	installbin=''
fi
bin="$ans"
binexp="$ansexp"
if $afs; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in which
executables reside from the directory in which they are installed (and from
which they are presumably copied to the former directory by occult means).

EOM
	case "$installbin" in
	'') dflt=`echo $binexp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installbin";;
	esac
	fn=de~
	rp='Where will public executables be installed?'
	. ./getfile
	installbin="$ans"
else
	installbin="$binexp"
fi

: determine where manual pages are on this system
echo " "
case "$sysman" in
'') 
	syspath='/usr/share/man/man1 /usr/man/man1'
	syspath="$syspath /usr/man/mann /usr/man/manl /usr/man/local/man1"
	syspath="$syspath /usr/man/u_man/man1 /usr/share/man/man1"
	syspath="$syspath /usr/catman/u_man/man1 /usr/man/l_man/man1"
	syspath="$syspath /usr/local/man/u_man/man1 /usr/local/man/l_man/man1"
	syspath="$syspath /usr/man/man.L /local/man/man1 /usr/local/man/man1"
	sysman=`./loc . /usr/man/man1 $syspath`
	;;
esac
if $test -d "$sysman"; then
	echo "System manual is in $sysman." >&4
else
	echo "Could not find manual pages in source form." >&4
fi

: determine where manual pages go
set mansrc mansrc none
eval $prefixit
$cat <<EOM

$spackage has manual pages available in source form.
EOM
case "$nroff" in
nroff)
	echo "However, you don't have nroff, so they're probably useless to you."
	case "$mansrc" in
	'') mansrc="none";;
	esac;;
esac
echo "If you don't want the manual sources installed, answer 'none'."
case "$mansrc" in
'')
	lookpath="$prefixexp/share/man/man1 $prefixexp/man/man1"
	lookpath="$lookpath $prefixexp/man/u_man/man1 $prefixexp/man/l_man/man1"
	lookpath="$lookpath /usr/local/man/man1 /opt/man/man1 /usr/man/manl"
	lookpath="$lookpath /usr/share/man/man1 /usr/local/share/man/man1"
	lookpath="$lookpath /usr/man/local/man1 /usr/man/l_man/man1"
	lookpath="$lookpath /usr/local/man/u_man/man1 /usr/local/man/l_man/man1"
	lookpath="$lookpath /usr/man/man.L"
	mansrc=`./loc . $prefixexp/man/man1 $lookpath`
	if $test -d "$mansrc"; then
		dflt="$mansrc"
	else
		dflt="$sysman"
	fi
	set dflt
	eval $prefixup
	;;
' ') dflt=none;;
*)  dflt="$mansrc"
	;;
esac
echo " "
fn=dn~
rp='Where do the manual pages (source) go?'
. ./getfile
if test "X$mansrcexp" != "X$ansexp"; then
	installmansrc=''
fi
mansrc="$ans"
mansrcexp="$ansexp"
case "$mansrc" in
'') mansrc=' '
	installmansrc='';;
esac
if $afs && $test "$mansrc"; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in which
manual pages reside from the directory in which they are installed (and from
which they are presumably copied to the former directory by occult means).

EOM
	case "$installmansrc" in
	'') dflt=`echo $mansrcexp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installmansrc";;
	esac
	fn=de~
	rp='Where will man pages be installed?'
	. ./getfile
	installmansrc="$ans"
else
	installmansrc="$mansrcexp"
fi

case "$mansrc" in
' ') manext='0';;
*l) manext=l;;
*n) manext=n;;
*o) manext=l;;
*p) manext=n;;
*C) manext=C;;
*L) manext=L;;
*L1) manext=L1;;
*) manext=1;;
esac

: see whether the try.c file compiles and links
trylink='
var=$1;
shift;
val=$undef;
file=trylink.log;
nparams=$#;
case "$cyn" in
"") msg="";;
*" "*) msg="$cyn"; yes=yes; no=no;;
*)
	case "$var" in
	d_*) msg="for $cyn()"; yes=found; no=missing;;
	i_*) msg="for <$cyn>"; yes=found; no=missing;;
	*) msg="$cyn"; yes=yes; no=no;;
	esac
	;;
esac;
case "$cyn" in
"") echo "--- $var ---" >> "$file";;
*)
	echo " "; $echo $n "Checking $msg...$c" >&4;
	echo "--- $var --- ($msg)" >> "$file"
	;;
esac;
$cat try.c >> "$file";
while :; do
	$rm -f try$_exe;
	if $cc $ccflags -o try try.c $ldflags $1 >> "$file" 2>&1; then
		case "$nparams" in 0) ;; *) echo "==> OK with \"$1\"" >> "$file";; esac;
		val=$define;
		break;
	fi;
	if $test $# -lt 1; then
		break;
	fi;
	echo "==> FAILED with \"$1\"" >> "$file";
	shift;
done;
$rm -rf try try.*;
echo "==> $var=$val" >> "$file";
case "$cyn" in
"") ;;
*)
	case "$val" in
	"$define") echo " $yes." >&4;;
	*) echo " $no." >&4;;
	esac
	;;
esac;
set $var; eval $setvar;
cyn=""
'

: see if gettext exists
$cat >try.c <<EOC
#include <libintl.h>
int main(void)
{
	static char ret;
	ret |= *gettext("msgid");
	return ret ? 0 : 1;
}
EOC
cyn=gettext
set d_gettext -lintl
eval $trylink

: see if this is a libintl system
set libintl.h i_libintl
eval $inhdr

: determine whether we support NLS
echo " "
case "$d_nls" in
"$define")
		echo "You have NLS support." >&4
		val="$define"
		;;
*)
	case "$d_gettext$i_libintl" in
	"$define$define")
		echo "You have NLS support." >&4
		val="$define"
		;;
	*)
		echo "I don't see support for NLS here..." >&4
		val="$undef"
		;;
	esac
	;;
esac
set d_nls
eval $setvar

: determine whether to enable NLS
echo " "
case "$d_nls" in
"$undef")
	echo "I won't enable NLS since you don't have that feature." >&4
	val="$undef"
	;;
*)
	$cat <<EOM
I can compile $package with Native Language Support (NLS), which
will enable internationalization of some messages, provided there is
a suitable translation available.

EOM
	dflt=y
	case "$d_enablenls" in
	"$undef") dflt=n;;
	esac
	rp='Shall I enable NLS'
	. ./myread
	case "$ans" in
	y) val="$define";;
	*) val="$undef";;
	esac
	;;
esac
set d_enablenls
eval $setvar
case "$d_enablenls" in
"$define") enablenls=true;;
"$undef") enablenls=false;;
esac

: determine where locale files go
case "$enablenls" in
false) ;;
*)
	set locale locale
	eval $prefixit
	case "$locale" in
	'')
		dflt=`./loc . "." $prefixexp/share/locale \
			/usr/share/locale /usr/local/share/locale`
		set dflt
		eval $prefixup
		;;
	*)  dflt="$locale";;
	esac
	fn=d~
	$cat <<EOM

$spackage comes with a set of files holding translations for various
languages.  Those need to be installed in order for you to benefit
from those translations and have $package localized.

EOM
	rp='Where do you want to put the localization files?'
	. ./getfile
	locale="$ans"
	localeexp="$ansexp"
	;;
esac

: Initialize h_fcntl
h_fcntl=false

: Initialize h_sysfile
h_sysfile=false

: see if this is a unistd.h system
set unistd.h i_unistd
eval $inhdr

: access call always available on UNIX
$cat >try.c <<EOC
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static int ret;
	ret |= access("path", 1);
	return ret ? 0 : 1;
}
EOC
cyn=access
set d_access
eval $trylink

: locate the flags for 'access()'
case "$d_access" in
"$define")
	echo " "
	$cat >access.c <<'EOCP'
#include <sys/types.h>
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void) {
	static int mode;
	mode |= R_OK;
	mode |= W_OK;
	mode |= X_OK;
	mode |= F_OK;
	return mode ? 0 : 1;
}
EOCP
	: check sys/file.h first, no particular reason here
	if $test `./findhdr sys/file.h` && \
		$cc -o access $cppflags -DI_SYS_FILE access.c >/dev/null 2>&1 ; then
		h_sysfile=true;
		echo "<sys/file.h> defines the *_OK access constants." >&4
	elif $test `./findhdr fcntl.h` && \
		$cc -o access $cppflags -DI_FCNTL access.c >/dev/null 2>&1 ; then
		h_fcntl=true;
		echo "<fcntl.h> defines the *_OK access constants." >&4
	elif $test `./findhdr unistd.h` && \
		$cc -o access $cppflags -DI_UNISTD access.c >/dev/null 2>&1 ; then
		echo "<unistd.h> defines the *_OK access constants." >&4
	else
		echo "I can't find the four *_OK access constants--I'll use mine." >&4
	fi
	;;
esac
$rm -f access*

: see if alarm exists
$cat >try.c <<EOC
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static unsigned ret;
	ret |= alarm(1);
	return ret ? 0 : 1;
}
EOC
cyn=alarm
set d_alarm
eval $trylink

: see if arc4random exists
$cat >try.c <<EOC
#$i_stdlib I_STDLIB
#ifdef I_STDLIB
#include <stdlib.h>
#endif
int main(void)
{
	static unsigned long ret;
	ret |= arc4random();
	return 0 != ret;
}
EOC
cyn=arc4random
set d_arc4random
eval $trylink

: Look for GNU-cc style attribute checking
$cat >try.c <<'EOCP'
#include <stdio.h>
void croak (char* pat,...) __attribute__((format(printf,1,2),noreturn));
int main(void) { return 0; }
EOCP
cyn="whether your compiler can handle __attribute__"
set d_attribut
eval $trylink

: see if this is an execinfo.h system
set execinfo.h i_execinfo
eval $inhdr

: see if backtrace exists
$cat >try.c <<EOC
#$i_execinfo I_EXECINFO
#ifdef I_EXECINFO
#include <execinfo.h>
#endif
int main(void)
{
	void *buf[2];
	static int ret;
	ret |= backtrace(buf, 2);
	return ret ? 0 : 1;
}
EOC
cyn=backtrace
set d_backtrace
eval $trylink

: see if bcmp exists
$cat >try.c <<EOC
#include <strings.h>
int main(void)
{
	static int a, b, ret;
	ret |= bcmp(&a, &b, sizeof(a));
	return ret ? 0 : 1;
}
EOC
cyn=bcmp
set d_bcmp
eval $trylink

: see if bcopy exists
$cat >try.c <<EOC
#include <strings.h>
static void
init_data(char *a, unsigned len)
{
	unsigned i;
	for (i = 0; i < len; i++)
		a[i] = i * 2 + 1;
}
static void
recopy_data(char *src, char *dst, unsigned len)
{
	bcopy(&src[3], &dst[0], len - 3);
}
int main(void)
{
	static char src[20], dst[20];
	init_data(src, sizeof src);
	recopy_data(src, dst, sizeof src);
	return dst[0] + dst[1];
}
EOC
cyn=bcopy
set d_bcopy
eval $trylink

: see whether the bfd library is available
$cat >try.c <<EOC
#define PACKAGE
#define PACKAGE_VERSION
#include <bfd.h>
int main(void)
{
	bfd *b;
	b = bfd_openr("file", 0);
	return b ? 0 : 1;
}
EOC
cyn="whether the BFD library is available"
set d_bfd_lib '-lbfd -lintl -liberty' '-lbfd -liberty' '-lbfd -liberty -lz' \
	'-lbfd -lintl -liberty -lz' '-lbfd -lz' '-lbfd -lintl -lz' \
	'-lbfd -lz -ldl'
eval $trylink

: see whether bfd_section_vma exists and takes 1 argument
case "$d_bfd_lib" in
$undef)
	d_bfd_section=$undef
	;;
*)
	$cat >try.c <<EOC
#define PACKAGE
#define PACKAGE_VERSION
#include <bfd.h>
int main(void)
{
	bfd *b = 0;
	asection *sec = 0;

	return 0 == bfd_section_vma(sec);
}
EOC
	cyn="whether bfd_section_vma() takes 1 argument"
	set d_bfd_section
	eval $trylink
	;;
esac

: see if bind_textdomain_codeset exists
$cat >try.c <<EOC
#include <libintl.h>
int main(void)
{
	static char ret;
	ret |= *bind_textdomain_codeset("domain", "codeset");
	return ret ? 0 : 1;
}
EOC
cyn=bind_textdomain_codeset
set d_bindtxtcode '-lintl'
eval $trylink

: see if there is a bsearch
$cat >try.c <<EOC
#include <stdlib.h>
int mycmp(const void *a, const void *b)
{
	return (char *) a - (char *) b;
}
int main(int argc, char **argv)
{
	return NULL == bsearch("foo", argv, argc, sizeof argv[0], mycmp);
}
EOC
cyn=bsearch
set d_bsearch
eval $trylink

: check for __builtin_bswap32
$cat >try.c <<EOC
int main(void)
{
	static int ret;
	ret |= __builtin_bswap32(127);
	return ret ? 0 : 1;
}
EOC
cyn=__builtin_bswap32
set d_built_bswap32
eval $trylink

: check for __builtin_bswap64
$cat >try.c <<EOC
int main(void)
{
	static int ret;
	ret |= __builtin_bswap64(127);
	return ret ? 0 : 1;
}
EOC
cyn=__builtin_bswap64
set d_built_bswap64
eval $trylink

: check for __builtin_clz
$cat >try.c <<EOC
int main(void)
{
	static int ret;
	ret |= __builtin_clz(127);
	return ret ? 0 : 1;
}
EOC
cyn=__builtin_clz
set d_built_clz
eval $trylink

: check for __builtin_ctz
$cat >try.c <<EOC
int main(void)
{
	static int ret;
	ret |= __builtin_ctz(127);
	return ret ? 0 : 1;
}
EOC
cyn=__builtin_ctz
set d_built_ctz
eval $trylink

: check for __builtin_popcount
$cat >try.c <<EOC
int main(void)
{
	static int ret;
	ret |= __builtin_popcount(127);
	return ret ? 0 : 1;
}
EOC
cyn=__builtin_popcount
set d_built_popcount
eval $trylink

: see if bzero exists
$cat >try.c <<EOC
#include <strings.h>
int main(void)
{
	static int dst;
	bzero(&dst, sizeof(dst));
	return 0;
}
EOC
cyn=bzero
set d_bzero
eval $trylink

: static assertion checking include file
$cat >static_assert.h <<'EOC'
#define STATIC_ASSERT(expr)		((void) sizeof(char[1 - 2*!(expr)]))
EOC

: check for lengths of integral types
echo " "
types=''
types="$types short"
types="$types int"
types="$types long"
for t in $types; do
	$echo $n "Checking to see how big your ${t}s are...$c" >&4
	for size in 2 4 8 16 error; do
		$cat >try.c <<EOCP
#include "static_assert.h"
$t foo;
int main()
{
	STATIC_ASSERT($size == sizeof(foo));
	return 0;
}
EOCP
		if $cc -c $ccflags try.c >/dev/null 2>&1; then break; fi
	done
	var=${t}size
	case "$size" in
	error)
		echo " cannot compute it." >&4
		case $t in
		short) dflt=2;;
		int) dflt=4;;
		long) dflt=4;;
		esac
		rp="What is the size of the \"$t\" type (in bytes)?"
		. ./myread
		eval $var="$ans"
		;;
	*)
		echo " $size bytes." >&4
		eval $var=$size
		;;
	esac
done
$rm_try

: check for length of pointer
echo " "
$echo $n "Checking to see how big your pointers are...$c" >&4
for size in 2 4 8 16 error; do
	$cat >try.c <<EOCP
#include "static_assert.h"
char *foo;
int main()
{
	STATIC_ASSERT($size == sizeof(foo));
	return 0;
}
EOCP
	if $cc -c $ccflags try.c >/dev/null 2>&1; then break; fi
done
case "$size" in
error)
	echo " cannot compute it." >&4
	dflt=4
	rp="What is the size of a pointer type (in bytes)?"
	. ./myread
	ptrsize="$ans"
	;;
*)
	echo " $size bytes." >&4
	ptrsize=$size
	;;
esac
$rm_try

: check for architecture type
echo " "
$echo $n "Computing CPU architecture type...$c" >&4
ilp=`expr $longsize \* 8`
case "$ptrsize" in
8)
	val=$undef; set d_ilp32; eval $setvar
	case "$intsize" in
	8)	
		echo " ILP64." >&4
		val=$define; set d_ilp64; eval $setvar
		val=$undef; set d_lp64; eval $setvar
		;;
	*)
		echo " LP64." >&4
		val=$define; set d_lp64; eval $setvar
		val=$undef; set d_ilp64; eval $setvar
		;;
	esac
	;;
*)
	echo " ILP${ilp}." >&4
	case "$ilp" in
	32) val=$define;;
	*) val=$undef;;
	esac
	set d_ilp32; eval $setvar
	val=$undef; set d_ilp64; eval $setvar
	val=$undef; set d_lp64; eval $setvar
	;;
esac

: see whether compiler supports 64-bit emulation
val=$undef
case "$ilp" in
64) val=$define;;
*)
	$cat >try.c <<EOCP
#include "static_assert.h"
long long foo;
int main()
{
	STATIC_ASSERT(8 == sizeof(foo));
	return 0;
}
EOCP
	if $cc -c $ccflags try.c >/dev/null 2>&1; then
		echo " "
		echo "Your compiler also supports 64-bit emulation." >&4
		val=$define
	fi
	$rm -f try.*
	;;
esac
set d_can64
eval $setvar

: do we have clearenv?
$cat >try.c <<EOC
#$i_stdlib I_STDLIB
#ifdef I_STDLIB
#include <stdlib.h>
#endif
int main(void)
{
	return clearenv();
}
EOC
cyn=clearenv
set d_clearenv
eval $trylink

: see whether clock_getres exists
$cat >try.c <<EOC
#include <time.h>
int main(void)
{
	int ret;
	struct timespec res;
	ret = clock_getres(CLOCK_REALTIME, &res);
	return ret ? 0 : 1;
}
EOC
cyn=clock_getres
set d_clock_getres
eval $trylink

: see whether clock_gettime exists
$cat >try.c <<EOC
#include <time.h>
int main(void)
{
	int ret;
	struct timespec tp;
	ret = clock_gettime(CLOCK_REALTIME, &tp);
	return ret ? 0 : 1;
}
EOC
cyn=clock_gettime
set d_clock_gettime
eval $trylink

: can we use closefrom?
$cat >try.c <<EOC
#include <sys/types.h>
#include <stdlib.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
  static const int fd = 1;
  /*
   * On Solaris it returns nothing
   * On NetBSD it's equivalent to fcntl(fd, F_CLOSEM)
   */
  closefrom(fd);	
  return 0;
}
EOC
cyn=closefrom
set d_closefrom
eval $trylink

: check for const keyword
echo " "
echo 'Checking to see if your C compiler knows about "const"...' >&4
$cat >const.c <<'EOCP'
typedef struct spug { int drokk; } spug;
int main(void)
{
	static const char *foo;
	static const spug y;
	(void) foo;
	(void) y;
	return 0;
}
EOCP
if $cc -c $ccflags const.c; then
	val="$define"
	echo "Yup, it does."
else
	val="$undef"
	echo "Nope, it doesn't."
fi
set d_const
eval $setvar
$rm -f const.c const.o

: how can we find information about dbus?
dbus="$undef"
dbuscflags=
dbusldflags=
dbusconfig='false'
modver=''

case "$d_dbus" in
"$undef") ;;
*)
	echo " "
	echo "Checking how we can gather information about dbus..." >&4
	if pkg-config dbus-1 --cflags >/dev/null 2>&1; then
		dbusconfig="pkg-config dbus-1"
		modver=--modversion
		echo "(I'll use '$dbusconfig' to gather that information.)" >&4

		: Make sure we have a good enough version
		version=`$dbusconfig $modver`
		case "$version" in
		'') ;;
		*)
			vint=`echo $version | $awk -F. '{print $1 * 10000 + $2 * 100 + $3;}'`
			if test 0$vint -lt 03502; then
				echo "Sorry, you have dbus $version, I need at least 0.35.2." >&4
				dbuscflags=
				dbusldflags=
			else
				echo "Good, you have dbus $version." >&4

				dbuscflags=`$dbusconfig --cflags`
				dbusldflags=`$dbusconfig --libs`
		
				$cat <<'EOM'

D-Bus support allows me to send out messages onto the D-Bus message
bus. That way external applications can easily act on certain 
events that happen, such as a completed download.

For more information, see doc/other/dbus-support.txt

EOM
				rp="Enable D-Bus support"
				dflt=y
				. ./myread
				case "$ans" in
				y) dbus="$define";;
				*) dbus="$undef";;
				esac
			fi
			;;
		esac
	else
		echo "You've don't seem to have dbus installed?" >&4
	fi
	;;
esac
val=$dbus
set d_dbus
eval $setvar

: can we use /dev/poll?
$cat >try.c <<EOC
#include <poll.h>
#include <stropts.h>
#include <sys/devpoll.h>
int main(void)
{
  static struct pollfd pfd;
  static struct dvpoll dvp;
  static int ret;
  pfd.fd |= 1;
  pfd.events |= POLLIN;
  pfd.events |= POLLPRI;
  pfd.events |= POLLOUT;
  pfd.events |= POLLHUP;
  pfd.events |= POLLERR;
  pfd.events |= POLLNVAL;
  pfd.events |= POLLREMOVE;
  pfd.revents |= 1;
  dvp.dp_timeout |= 1;
  dvp.dp_nfds |= 1;
  dvp.dp_fds = &pfd;
  ret |= ioctl(1, DP_POLL, &dvp);
  return 0 != ret;
}
EOC
cyn="whether /dev/poll can be used"
set d_dev_poll
eval $trylink

: see if this is a dirent system
echo " "
if xinc=`./findhdr dirent.h`; $test "$xinc"; then
	val="$define"
	echo "<dirent.h> found." >&4
else
	val="$undef"
	if xinc=`./findhdr sys/dir.h`; $test "$xinc"; then
		echo "<sys/dir.h> found." >&4
		echo " "
	else
		xinc=`./findhdr sys/ndir.h`
	fi
	echo "<dirent.h> NOT found." >&4
fi
set i_dirent
eval $setvar


: check whether struct dirent has a member d_namlen.
$cat >try.c <<EOC
#include <sys/types.h>
#$i_dirent I_DIRENT
#ifdef I_DIRENT
#include <dirent.h>
#endif
int main(void)
{
  static struct dirent dir_entry;
  dir_entry.d_namlen |= 1;
  return 0;
}
EOC
cyn="whether struct dirent has a d_namlen member"
set d_dirent_d_namlen
eval $trylink

: check whether struct dirent has a member d_type.
$cat >try.c <<EOC
#include <sys/types.h>
#$i_dirent I_DIRENT
#ifdef I_DIRENT
#include <dirent.h>
#endif
int main(void)
{
  static struct dirent dir_entry;
  dir_entry.d_type |= 1
	| DT_UNKNOWN
	| DT_FIFO
	| DT_CHR
	| DT_DIR
	| DT_BLK
	| DT_REG
	| DT_LNK
	| DT_SOCK;
  return 0;
}
EOC
cyn="whether struct dirent has a d_type member"
set d_dirent_d_type
eval $trylink

: see if dirfd exists
$cat >try.c <<EOC
#include <sys/types.h>
#$i_dirent I_DIRENT
#ifdef I_DIRENT
#include <dirent.h>
#endif
int main(void)
{
	static DIR *dir;
	static int ret;
	ret = dirfd(dir);
	return ret ? 0 : 1;
}
EOC
cyn=dirfd
set d_dirfd
eval $trylink

: see if dlfcn is available
set dlfcn.h i_dlfcn
eval $inhdr

: see if dladdr exists
$cat >try.c <<EOC
#$i_dlfcn I_DLFCN
#define _GNU_SOURCE
#ifdef I_DLFCN
#include <dlfcn.h>
#endif
int main(void)
{
	Dl_info info;

	dladdr(main, &info);
	return info.dli_fbase != 0;
}
EOC
cyn=dladdr
set d_dladdr '-ldl'
eval $trylink

: see if the end symbol exists
$cat >try.c <<EOC
int main(void)
{
	extern int end;
	return (int) &end >> 12;
}
EOC
cyn="whether your linker defines the end symbol"
set d_end_symbol
eval $trylink

: can we use epoll?
$cat >try.c <<EOC
#include <sys/types.h>
#include <sys/epoll.h>
int main(void)
{
  static struct epoll_event ev;
  static int ret, epfd;
  epfd |= epoll_create(1);
  ev.events |= EPOLLOUT; 
  ev.events |= EPOLLPRI; 
  ev.events |= EPOLLERR; 
  ev.events |= EPOLLHUP; 
  ev.events |= EPOLLET; 
  ev.data.ptr = (void *) 0; 
  ev.data.fd |= 1; 
  ev.data.u32 |= 1; 
  ev.data.u64 |= 1; 
  ret |= epoll_ctl(epfd, 1, EPOLL_CTL_ADD, &ev);
  ret |= epoll_ctl(epfd, 1, EPOLL_CTL_MOD, &ev);
  ret |= epoll_ctl(epfd, 1, EPOLL_CTL_DEL, &ev);
  ret |= epoll_wait(epfd, &ev, 1, -1);
  return 0 != ret;
}
EOC
cyn="whether epoll support is available"
set d_epoll
eval $trylink

: see if the etext symbol exists
$cat >try.c <<EOC
int main(void)
{
	extern int etext;
	return (int) &etext >> 12;
}
EOC
cyn="whether your linker defines the etext symbol"
set d_etext_symbol
eval $trylink

: see if fchdir exists
$cat >try.c <<EOC
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static int fd, ret;
	ret |= fchdir(fd);
	return ret ? 0 : 1;
}
EOC
cyn=fchdir
set d_fchdir
eval $trylink

: see if fdatasync exists
$cat >try.c <<EOC
#include <sys/types.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static int ret, fd;
	ret |= fdatasync(fd);
	return ret ? 0 : 1;
}
EOC
cyn=fdatasync
set d_fdatasync
eval $trylink

: see if fdopendir exists
$cat >try.c <<EOC
#$i_dirent I_DIRENT
#include <sys/types.h>
#ifdef I_DIRENT
#include <dirent.h>
#endif
int main(void)
{
	static DIR *d;
	d = fdopendir(0);
	return (DIR *) 0 == d;
}
EOC
cyn=fdopendir
set d_fdopendir
eval $trylink

: see if fork exists
$cat >try.c <<EOC
#include <sys/types.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static pid_t pid;
	pid |= fork();
	return pid ? 0 : 1;
}
EOC
cyn=fork
set d_fork
eval $trylink

: see if sys/stat.h is available
set sys/stat.h i_sysstat
eval $inhdr

: see if fstatat exists
$cat >try.c <<EOC
#$i_sysstat I_SYS_STAT
#include <fcntl.h>	/* AT_* constants */
#ifdef I_SYS_STAT
#include <sys/stat.h>
#endif
int main(void)
{
	static int ret;
	struct stat sb;
	ret |= fstatat(AT_FDCWD, "path", &sb, 0);
	return ret ? 0 : 1;
}
EOC
cyn=fstatat
set d_fstatat
eval $trylink

: see if fsync exists
$cat >try.c <<EOC
#include <sys/types.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static int ret, fd;
	ret |= fsync(fd);
	return ret ? 0 : 1;
}
EOC
cyn=fsync
set d_fsync
eval $trylink

: see if arpa/inet.h has to be included
set arpa/inet.h i_arpainet
eval $inhdr

: see if this is a netdb.h system
set netdb.h i_netdb
eval $inhdr

: see if this is a sys/socket.h system
set sys/socket.h i_syssock
eval $inhdr

: see if this is a winsock2.h system
set winsock2.h i_winsock2
eval $inhdr

: see if this is a ws2tcpip.h system
set ws2tcpip.h i_ws2tcpip
eval $inhdr

: see if this is a netinet/in.h or sys/in.h system
set netinet/in.h i_niin sys/in.h i_sysin
eval $inhdr

: can we use getaddrinfo?
$cat >try.c <<EOC
#$i_syssock I_SYS_SOCKET
#$i_winsock2 I_WINSOCK2
#$i_ws2tcpip I_WS2TCPIP
#$i_niin I_NETINET_IN
#$i_arpainet I_ARPA_INET
#$i_netdb I_NETDB
#$d_windows WINDOWS_SYSTEM
#ifdef WINDOWS_SYSTEM
#define WINVER 0x0501
#endif
#include <sys/types.h>
#ifdef I_SYS_SOCKET
#include <sys/socket.h>
#endif
#ifdef I_NETINET_IN
#include <netinet/in.h>
#endif
#ifdef I_ARPA_INET
#include <arpa/inet.h>
#endif
#ifdef I_NETDB
#include <netdb.h>
#endif
#ifdef I_WINSOCK2
#include <Winsock2.h>
#endif
#ifdef I_WS2TCPIP
#include <Ws2tcpip.h>
#endif
int main(void)
{
	struct addrinfo hints, *res;
	int ret;

	hints.ai_flags = 1;
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = 1;
	hints.ai_protocol = 1;
	hints.ai_addrlen = (socklen_t) 1;
	hints.ai_canonname = "canonname";
	hints.ai_addr = (struct sockaddr *) 0;
	hints.ai_next = (struct addrinfo *) 0;
	ret = getaddrinfo("localhost", "www", &hints, &res);
	if (0 != ret) {
		const char *s;
		s = gai_strerror(ret);
		(void) s;
	}
	if (res)
		freeaddrinfo(res);
	return 0;
}
EOC
cyn=getaddrinfo
set d_getaddrinfo '-lWs2_32'
eval $trylink

: can we use geteuid?
$cat >try.c <<EOC
#include <sys/types.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static uid_t ret;
	ret |= geteuid();
	return ret ? 0 : 1;
}
EOC
cyn=geteuid
set d_geteuid
eval $trylink

: see if this is a net/if.h system
set net/if.h i_netif
eval $inhdr

: can we use getifaddrs?
$cat >try.c <<EOC
#include <sys/types.h>
#include <sys/socket.h>
#$i_netif I_NET_IF
#ifdef I_NET_IF
#include <net/if.h>
#endif
#include <ifaddrs.h>
int main(void)
{
  struct ifaddrs *ifa0, *ifa;
  static int ret;

  ret |= getifaddrs(&ifa0);

  for (ifa = ifa0; ifa; ifa = ifa->ifa_next) {
    (void) ifa->ifa_flags;
    (void) ifa->ifa_addr;
    (void) ifa->ifa_addr->sa_family;
    (void) ifa->ifa_netmask;
    if ((IFF_LOOPBACK | IFF_UP | IFF_RUNNING) & ifa->ifa_flags)
	break;
  }
  freeifaddrs(ifa0);
  return 0;
}
EOC
cyn=getifaddrs
set d_getifaddrs
eval $trylink

: see if getinvent exists
$cat >try.c <<EOC
#include <invent.h>
int main(void)
{
	static inventory_t *ret;
	ret = getinvent();
	return ret ? 0 : 1;
}
EOC
cyn=getinvent
set d_getinvent
eval $trylink

: see if getlogin exists
$cat >try.c <<EOC
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static char ret;
	ret |= *getlogin();
	return ret ? 0 : 1;
}
EOC
cyn=getlogin
set d_getlogin
eval $trylink

: can we use getnameinfo?
$cat >try.c <<EOC
#$i_syssock I_SYS_SOCKET
#$i_winsock2 I_WINSOCK2
#$i_ws2tcpip I_WS2TCPIP
#$i_niin I_NETINET_IN
#$i_arpainet I_ARPA_INET
#$i_netdb I_NETDB
#$d_windows WINDOWS_SYSTEM
#ifdef WINDOWS_SYSTEM
#define WINVER 0x0501
#endif
#include <sys/types.h>
#ifdef I_SYS_SOCKET
#include <sys/socket.h>
#endif
#ifdef I_NETINET_IN
#include <netinet/in.h>
#endif
#ifdef I_ARPA_INET
#include <arpa/inet.h>
#endif
#ifdef I_NETDB
#include <netdb.h>
#endif
#ifdef I_WINSOCK2
#include <Winsock2.h>
#endif
#ifdef I_WS2TCPIP
#include <Ws2tcpip.h>
#endif
int main(void)
{
	int ret;
	static struct sockaddr sa;
	socklen_t salen;
	char host[NI_MAXHOST];
	char serv[NI_MAXSERV];

	salen = sizeof(sa);
	ret = getnameinfo(&sa, salen,
		host, sizeof host, serv, sizeof serv,
		NI_NAMEREQD | NI_DGRAM | NI_NOFQDN | NI_NUMERICHOST | NI_NUMERICSERV);
	return 0 == ret;
}
EOC
cyn=getnameinfo
set d_getnameinfo '-lWs2_32'
eval $trylink

: see if getppid exists
$cat >try.c <<EOC
#include <sys/types.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static pid_t ret;
	ret |= getppid();
	return ret ? 0 : 1;
}
EOC
cyn=getppid
set d_getppid
eval $trylink

: can we use getprogname?
$cat >try.c <<EOC
#include <stdio.h>
#$i_stdlib I_STDLIB
#ifdef I_STDLIB
#include <stdlib.h>
#endif
int main(void)
{
	printf("%s\n", getprogname());
	return 0;
}
EOC
cyn=getprogname
set d_getprogname
eval $trylink

: see if there is a getpwnam
$cat >try.c <<EOC
#include <pwd.h>
int main(void)
{
	struct passwd pw;
	pw = *getpwnam("foo");
	return pw.pw_name ? 0 : 1;
}
EOC
cyn=getpwnam
set d_getpwnam
eval $trylink

: see if there is a getpwuid
$cat >try.c <<EOC
#include <pwd.h>
int main(void)
{
	struct passwd pw;
	pw = *getpwuid(0);
	return pw.pw_name ? 0 : 1;
}
EOC
cyn=getpwuid
set d_getpwuid
eval $trylink

: see if sys/select.h has to be included
set sys/select.h i_sysselct
eval $inhdr

: see if we should include time.h, sys/time.h, or both
echo " "
echo "Testing to see if we should include <time.h>, <sys/time.h> or both." >&4
$echo $n "I'm now running the test program...$c"
$cat >try.c <<'EOCP'
#include <sys/types.h>
#ifdef I_TIME
#include <time.h>
#endif
#ifdef I_SYSTIME
#ifdef SYSTIMEKERNEL
#define KERNEL
#endif
#include <sys/time.h>
#endif
#ifdef I_SYSSELECT
#include <sys/select.h>
#endif
int main(void)
{
	struct tm foo;
#ifdef S_TIMEVAL
	struct timeval bar;
#endif
#ifdef S_TIMEZONE
	struct timezone tzp;
#endif
	if (foo.tm_sec == foo.tm_sec)
		return 0;
#ifdef S_TIMEVAL
	if (bar.tv_sec == bar.tv_sec)
		return 0;
#endif
	return 1;
}
EOCP
flags=''
for s_timezone in '-DS_TIMEZONE' ''; do
sysselect=''
for s_timeval in '-DS_TIMEVAL' ''; do
for i_systimek in '' '-DSYSTIMEKERNEL'; do
for i_time in '' '-DI_TIME'; do
for i_systime in '-DI_SYSTIME' ''; do
	case "$flags" in
	'') $echo $n ".$c"
		if $cc $ccflags \
		$i_time $i_systime $i_systimek $sysselect $s_timeval $s_timezone \
		-o try try.c >/dev/null 2>&1 ; then
			set X $i_time $i_systime $i_systimek $sysselect $s_timeval
			shift
			flags="$*"
			echo " "
			$echo $n "Succeeded with $flags$c"
		fi
		;;
	esac
done
done
done
done
done
timeincl=''
echo " "
case "$flags" in
*SYSTIMEKERNEL*) i_systimek="$define"
	timeincl=`./findhdr sys/time.h`
	echo "We'll include <sys/time.h> with KERNEL defined." >&4;;
*) i_systimek="$undef";;
esac
case "$flags" in
*I_TIME*) i_time="$define"
	timeincl=`./findhdr time.h`" $timeincl"
	echo "We'll include <time.h>." >&4;;
*) i_time="$undef";;
esac
case "$flags" in
*I_SYSTIME*) i_systime="$define"
	timeincl=`./findhdr sys/time.h`" $timeincl"
	echo "We'll include <sys/time.h>." >&4;;
*) i_systime="$undef";;
esac
$rm_try

: see if getrlimit exists
$cat >try.c <<EOC
#$i_systime I_SYS_TIME
#ifdef I_SYS_TIME
#include <sys/time.h>
#endif
#include <sys/resource.h>
int main(void)
{
	static struct rlimit lim;
	int ret;
	ret |= getrlimit(RLIMIT_CORE, &lim);
	ret += lim.rlim_cur > lim.rlim_max ? 1 : 0;
	return ret ? 0 : 1;
}
EOC
cyn=getrlimit
set d_getrlimit
eval $trylink

: define a shorthand compile call
compile='
mc_file=$1;
shift;
$cc -o ${mc_file} $optimize $ccflags $ldflags $* ${mc_file}.c $libs > /dev/null 2>&1;'
: define a shorthand compile call for compilations that should be ok.
compile_ok='
mc_file=$1;
shift;
$cc -o ${mc_file} $optimize $ccflags $ldflags $* ${mc_file}.c $libs;'

: determine whether we are using a GNU C library
echo " "
echo "Checking for GNU C Library..." >&4
cat >try.c <<'EOCP'
/* Find out version of GNU C library.  __GLIBC__ and __GLIBC_MINOR__
   alone are insufficient to distinguish different versions, such as
   2.0.6 and 2.0.7.  The function gnu_get_libc_version() appeared in
   libc version 2.1.0.      A. Dougherty,  June 3, 2002.
*/
#include <stdio.h>
int main(void)
{
#ifdef __GLIBC__
#   ifdef __GLIBC_MINOR__
#       if __GLIBC__ >= 2 && __GLIBC_MINOR__ >= 1
#           include <gnu/libc-version.h>
	    printf("%s\n",  gnu_get_libc_version());
#       else
	    printf("%d.%d\n",  __GLIBC__, __GLIBC_MINOR__);
#       endif
#   else
	printf("%d\n",  __GLIBC__);
#   endif
    return 0;
#else
    return 1;
#endif
}
EOCP
set try
if eval $compile_ok && $run ./try > glibc.ver; then
	val="$define"
	gnulibc_version=`$cat glibc.ver`
	echo "You are using the GNU C Library version $gnulibc_version"
else
	val="$undef"
	gnulibc_version=''
	echo "You are not using the GNU C Library"
fi
$rm_try glibc.ver
set d_gnulibc
eval $setvar

: see if nm is to be used to determine whether a symbol is defined or not
case "$usenm" in
'')
	dflt=''
	case "$d_gnulibc" in
	"$define")
		echo " "
		echo "$nm probably won't work on the GNU C Library." >&4
		dflt=n
		;;
	esac
	case "$dflt" in
	'')
		if $test "$osname" = aix -a ! -f /lib/syscalls.exp; then
			echo " "
			echo "Whoops!  This is an AIX system without /lib/syscalls.exp!" >&4
			echo "'nm' won't be sufficient on this system." >&4
			dflt=n
		fi
		;;
	esac
	case "$dflt" in
	'')
		if ./gnu; then
			echo " "
			echo "Hmm...  A GNU system without a GNU C Library?  Weird..." >&4
			dflt=n
		else
			dflt=`$egrep 'inlibc|csym' $rsrc/Configure | wc -l 2>/dev/null`
			if $test $dflt -gt 20; then
				dflt=y
			else
				dflt=n
			fi
		fi
		;;
	esac
	;;
*)
	case "$usenm" in
	true|$define) dflt=y;;
	*) dflt=n;;
	esac
	;;
esac
$cat <<EOM

I can use $nm to extract the symbols from your C libraries. This
is a time consuming task which may generate huge output on the disk (up
to 3 megabytes) but that should make the symbols extraction faster. The
alternative is to skip the 'nm' extraction part and to compile a small
test program instead to determine whether each symbol is present. If
you have a fast C compiler and/or if your 'nm' output cannot be parsed,
this may be the best solution.

EOM
rp='Shall I use nm to extract C symbols from the libraries?'
. ./myread
case "$ans" in
[Nn]*) usenm=false;;
*) usenm=true;;
esac

runnm=$usenm
case "$reuseval" in
true) runnm=false;;
esac

: nm options which may be necessary
case "$nm_opt" in
'') if $test -f /mach_boot; then
		nm_opt=''		# Mach
	elif $test -d /usr/ccs/lib; then
		nm_opt='-p'		# Solaris (and SunOS?)
	elif $test -f /dgux; then
		nm_opt='-p'		# DG-UX
	elif $test -f /lib64/rld; then
		nm_opt='-p'		# 64-bit Irix
	else
		nm_opt=''
	fi;;
esac

case "$nm_so_opt" in
'')	case "$osname" in
	*linux*)
		if $nm --help | $grep 'dynamic' > /dev/null 2>&1; then
			nm_so_opt='--dynamic'
		fi
		;;
	esac
	;;
esac

: Figure out where the libc is located
case "$runnm" in
true)
: get list of predefined functions in a handy place
echo " "
case "$libc" in
'') libc=unknown
	case "$libs" in
	*-lc_s*) libc=`./loc libc_s$_a $libc $libpth`
	esac
	;;
esac
case "$libs" in
'') ;;
*)  for thislib in $libs; do
	case "$thislib" in
	-lc|-lc_s)
		: Handle C library specially below.
		;;
	-l*)
		thislib=`echo $thislib | $sed -e 's/^-l//'`
		if try=`./loc lib$thislib.$so.'*' X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc lib$thislib.$so X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc lib$thislib$_a X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc $thislib$_a X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc lib$thislib X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc $thislib X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc Slib$thislib$_a X $xlibpth`; $test -f "$try"; then
			:
		else
			try=''
		fi
		libnames="$libnames $try"
		;;
	*) libnames="$libnames $thislib" ;;
	esac
	done
	;;
esac
xxx=normal
case "$libc" in
unknown)
	set /lib/libc.$so
	for xxx in $libpth; do
		$test -r $1 || set $xxx/libc.$so
		: The messy sed command sorts on library version numbers.
		$test -r $1 || \
			set `echo blurfl; echo $xxx/libc.$so.[0-9]* | \
			tr ' ' $trnl | egrep -v '\.[A-Za-z]*$' | $sed -e '
				h
				s/[0-9][0-9]*/0000&/g
				s/0*\([0-9][0-9][0-9][0-9][0-9]\)/\1/g
				G
				s/\n/ /' | \
			 $sort | $sed -e 's/^.* //'`
		eval set \$$#
	done
	$test -r $1 || set /usr/ccs/lib/libc.$so
	$test -r $1 || set /lib/libsys_s$_a
	;;
*)
	set blurfl
	;;
esac
if $test -r "$1"; then
	echo "Your (shared) C library seems to be in $1."
	libc="$1"
elif $test -r /lib/libc && $test -r /lib/clib; then
	echo "Your C library seems to be in both /lib/clib and /lib/libc."
	xxx=apollo
	libc='/lib/clib /lib/libc'
	if $test -r /lib/syslib; then
		echo "(Your math library is in /lib/syslib.)"
		libc="$libc /lib/syslib"
	fi
elif $test -r "$libc" || (test -h "$libc") >/dev/null 2>&1; then
	echo "Your C library seems to be in $libc, as you said before."
elif $test -r $incpath/usr/lib/libc$_a; then
	libc=$incpath/usr/lib/libc$_a;
	echo "Your C library seems to be in $libc.  That's fine."
elif $test -r /lib/libc$_a; then
	libc=/lib/libc$_a;
	echo "Your C library seems to be in $libc.  You're normal."
else
	if tans=`./loc libc$_a blurfl/dyick $libpth`; $test -r "$tans"; then
		:
	elif tans=`./loc libc blurfl/dyick $libpth`; $test -r "$tans"; then
		libnames="$libnames "`./loc clib blurfl/dyick $libpth`
	elif tans=`./loc clib blurfl/dyick $libpth`; $test -r "$tans"; then
		:
	elif tans=`./loc Slibc$_a blurfl/dyick $xlibpth`; $test -r "$tans"; then
		:
	elif tans=`./loc Mlibc$_a blurfl/dyick $xlibpth`; $test -r "$tans"; then
		:
	else
		tans=`./loc Llibc$_a blurfl/dyick $xlibpth`
	fi
	if $test -r "$tans"; then
		echo "Your C library seems to be in $tans, of all places."
		libc=$tans
	else
		libc='blurfl'
	fi
fi
if $test $xxx = apollo -o -r "$libc" || (test -h "$libc") >/dev/null 2>&1; then
	dflt="$libc"
	cat <<EOM

If the guess above is wrong (which it might be if you're using a strange
compiler, or your machine supports multiple models), you can override it here.

EOM
else
	dflt=''
	echo $libpth | $tr ' ' $trnl | $sort | $uniq > libpath
	cat >&4 <<EOM
I can't seem to find your C library.  I've looked in the following places:

EOM
	$sed 's/^/	/' libpath
	cat <<EOM

None of these seems to contain your C library. I need to get its name...

EOM
fi
fn=f
rp='Where is your C library?'
. ./getfile
libc="$ans"

echo " "
echo $libc $libnames | $tr ' ' $trnl | $sort | $uniq > libnames
set X `cat libnames`
shift
xxx=files
case $# in 1) xxx=file; esac
echo "Extracting names from the following $xxx for later perusal:" >&4
echo " "
$sed 's/^/	/' libnames >&4
echo " "
$echo $n "This may take a while...$c" >&4

for file in $*; do
	case $file in
	*$so*) $nm $nm_so_opt $nm_opt $file 2>/dev/null;;
	*) $nm $nm_opt $file 2>/dev/null;;
	esac
done >libc.tmp

$echo $n ".$c"
$grep fprintf libc.tmp > libc.ptf
xscan='eval "<libc.ptf $com >libc.list"; $echo $n ".$c" >&4'
xrun='eval "<libc.tmp $com >libc.list"; echo "done." >&4'
xxx='[ADTSIW]'
if com="$sed -n -e 's/__IO//' -e 's/^.* $xxx  *_[_.]*//p' -e 's/^.* $xxx  *//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__*//' -e 's/^\([a-zA-Z_0-9$]*\).*xtern.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e '/|UNDEF/d' -e '/FUNC..GL/s/^.*|__*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.* D __*//p' -e 's/^.* D //p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^_//' -e 's/^\([a-zA-Z_0-9]*\).*xtern.*text.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$grep '|' | $sed -n -e '/|COMMON/d' -e '/|DATA/d' \
				-e '/ file/d' -e 's/^\([^ 	]*\).*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p' -e 's/^.*|FUNC |WEAK .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__//' -e '/|Undef/d' -e '/|Proc/s/ .*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|Proc .*|Text *| *//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e '/Def. Text/s/.* \([^ ]*\)\$/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^[-0-9a-f ]*_\(.*\)=.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/.*\.text n\ \ \ \.//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="sed -n -e 's/^__.*//' -e 's/[       ]*D[    ]*[0-9]*.*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
else
	$nm -p $* 2>/dev/null >libc.tmp
	$grep fprintf libc.tmp > libc.ptf
	if com="$sed -n -e 's/^.* [ADTSIW]  *_[_.]*//p' -e 's/^.* [ADTSIW] //p'";\
		eval $xscan; $contains '^fprintf$' libc.list >/dev/null 2>&1
	then
		nm_opt='-p'
		eval $xrun
	else
		echo " "
		echo "$nm didn't seem to work right. Trying $ar instead..." >&4
		com=''
		if $ar t $libc > libc.tmp && \
			$contains '^fprintf$' libc.tmp >/dev/null 2>&1
		then
			for thisname in $libnames $libc; do
				$ar t $thisname >>libc.tmp
			done
			$sed -e "s/\\$_o\$//" < libc.tmp > libc.list
			echo "Ok." >&4
		elif test "X$osname" = "Xos2" && $ar tv $libc > libc.tmp; then
			for thisname in $libnames $libc; do
				$ar tv $thisname >>libc.tmp
				emximp -o tmp.imp $thisname \
				    2>/dev/null && \
				    $sed -e 's/^\([_a-zA-Z0-9]*\) .*$/\1/p' \
				    < tmp.imp >>libc.tmp
				$rm -f tmp.imp
			done
			$sed -e "s/\\$_o\$//" -e 's/^ \+//' < libc.tmp > libc.list
			echo "Ok." >&4
		else
			echo "$ar didn't seem to work right." >&4
			echo "Maybe this is a Cray...trying bld instead..." >&4
			if
				bld t $libc | \
					$sed -e 's/.*\///' -e "s/\\$_o:.*\$//" > libc.list &&
				$test -s libc.list
			then
				for thisname in $libnames; do
					bld t $libnames | \
					$sed -e 's/.*\///' -e "s/\\$_o:.*\$//" >>libc.list
					$ar t $thisname >>libc.tmp
				done
				echo "Ok." >&4
			else
				echo "That didn't work either." >&4
				echo "No problem, I'll be compiling test programs then..." >&4
				runnm=false
			fi
		fi
	fi
fi
nm_extract="$com"
if $test -f /lib/syscalls.exp; then
	echo " "
	echo "Also extracting names from /lib/syscalls.exp for good ole AIX..." >&4
	$sed -n 's/^\([^ 	]*\)[ 	]*syscall[0-9]*[ 	]*$/\1/p' \
		/lib/syscalls.exp >>libc.list
fi
;;
esac
$rm -f libnames libpath

: is a C symbol defined?
csym='tlook=$1;
case "$3" in
-v) tf=libc.tmp; tc=""; tdc="";;
-a) tf=libc.tmp; tc="[0]"; tdc="[]";;
*) tlook="^$1\$"; tf=libc.list; tc=""; tdc="()";;
esac;
file=csym.log;
tx=yes;
case "$reuseval-$4" in
true-) ;;
true-*) tx=no; eval "tval=\$$4"; case "$tval" in "") tx=yes;; esac;;
esac;
case "$tx" in
yes)
	case "$runnm" in
	true)
		if $contains $tlook $tf >/dev/null 2>&1;
		then tval=true;
		else tval=false;
		fi;;
	*)
		echo "--- $1$tdc ---" >> "$file";
		echo "extern char $1$tdc; int main(void) { return (unsigned long) &$1$tc > 2; }" > t.c;
		$cat t.c >> "$file";
		if $cc $ccflags $ldflags -o t t.c $libs >>"$file" 2>&1;
		then tval=true;
		else tval=false;
		fi;
		$rm -f t t.c;;
	esac;;
*)
	case "$tval" in
	$define) tval=true;;
	*) tval=false;;
	esac;;
esac;
echo "==> HAS $1$tdc is $tval ($4)" >>"$file";
eval "$2=$tval"'

: see if getdtablesize exists
echo " "
case "$d_gettblsz" in
$define) d_gettblsz="$undef";;
$undef) d_gettblsz="$define";;
esac
if set getdtablesize val -f d_gettblsz; eval $csym; $val; then
	echo 'getdtablesize() found.' >&4
	d_gettblsz="$undef"
	tablesize=''
else
	echo 'getdtablesize() NOT found...' >&4
	if set ulimit val -f; eval $csym; $val; then
		echo 'Maybe ulimit(4,0) will work...'
		$cat >nofile.c <<'EOCP'
#include <stdio.h>
#ifdef GETPARAM_H
#include <sys/param.h>
#endif
int main()
{
	printf("%d %d\n",
#ifdef NOFILE
		NOFILE,
#else
		0,
#endif
		ulimit(4,0));
		exit(0);
}
EOCP
		if $cc $ccflags -DGETPARAM_H -o nofile nofile.c $libs >/dev/null 2>&1 \
			|| $cc $ccflags -o nofile nofile.c $libs >/dev/null 2>&1 ; then
			set `./nofile`
			d_gettblsz=$1
			d_ulimit4=$2
			if $test "$d_ulimit4" -lt 0; then
				echo "Your ulimit() call doesn't tell me what I want to know."
				echo "We'll just use NOFILE in this case."
				nofile=$d_gettblsz
				d_gettblsz="$define"
				tablesize='NOFILE'
			else
				if $test "$d_gettblsz" -gt 0; then
				echo "Your system defines NOFILE to be $d_gettblsz, and" >&4
				else
				echo "I had trouble getting NOFILE from your system, but" >&4
				fi
echo "ulimit returns $d_ulimit4 as the number of available file descriptors." >&4
				dflt='y';
				echo " "
	rp='Should I use ulimit to get the number of available file descriptors?'
				. ./myread
				case "$ans" in
				y*)
					nofile=$d_ulimit4
					d_gettblsz="$define"
					tablesize='ulimit(4, 0L)'
					echo "Using ulimit(4,0)."
					;;
				*)
					nofile=$d_gettblsz
					d_gettblsz="$define"
					tablesize='NOFILE'
					echo "Using NOFILE."
					;;
				esac
			fi
		else
			echo "Strange, I couldn't get my test program to compile."
			echo "We'll just use NOFILE in this case."
			d_gettblsz="$define"
			tablesize='NOFILE'
			nofile=''
		fi
	else
		echo 'Using NOFILE instead.'
		d_gettblsz="$define"
		tablesize='NOFILE'
		nofile=''
	fi
fi
$rm -f nofile*

: see where struct timeb is defined
echo " "
xxx=`./findhdr sys/timeb.h`
if $test "$xxx"; then
	if $contains 'struct timeb' $xxx >/dev/null 2>&1; then
		val="$define"
		echo "You have struct timeb defined in <sys/timeb.h>." >&4
	else
		val="$undef"
		echo "Assuming struct timeb is defined in <sys/time.h>." >&4
	fi
else
	val="$undef"
echo "No <sys/timeb.h> -- Assuming struct timeb is defined in <sys/time.h>." >&4
fi
set i_systimeb
eval $setvar

: see if gettimeofday or ftime exists
$cat >try.c <<EOC
#include <sys/time.h>
int main(void)
{
	static struct timeval tv;
	static void *tz;
	static int ret;
	ret |= gettimeofday(&tv, tz);
	return ret ? 0 : 1;
}
EOC
cyn=gettimeofday
set d_gettimeod
eval $trylink

$cat >try.c <<EOC
#include <sys/types.h>
#$i_systimeb I_SYS_TIMEB
#ifdef I_SYS_TIMEB
#include <sys/timeb.h>
#endif
int main(void)
{
	static struct timeb t;
	static int ret;
	ret |= ftime(&t);
	return ret ? 0 : 1;
}
EOC
cyn=ftime
set d_ftime
eval $trylink

case "$d_gettimeod$d_ftime" in
"$undef$undef")
	echo " "
	echo 'No ftime() nor gettimeofday() -- timing may be less accurate.' >&4
	;;
esac

: can we use getuid?
$cat >try.c <<EOC
#include <sys/types.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static uid_t ret;
	ret |= getuid();
	return ret ? 0 : 1;
}
EOC
cyn=getuid
set d_getuid
eval $trylink

: how can we find information about GnuTLS?
echo " "

gnutls="$undef"
gnutlscflags=
gnutlsldflags=
gnutlsconfig='false'
modver=

case "$d_gnutls" in
"$undef") ;;
*)
echo "Checking how we can gather information about GnuTLS..." >&4
if pkg-config gnutls --cflags >/dev/null 2>&1; then
	gnutlsconfig="pkg-config gnutls"
	modver=--modversion
elif libgnutls-config --cflags >/dev/null 2>&1; then
	gnutlsconfig="libgnutls-config"
	modver=--version
else
	echo "You don't seem to have GnuTLS installed?" >&4
fi

if [ "$gnutlsconfig" != false ]; then
	echo "(I'll use '$gnutlsconfig' to gather that information.)"
fi

version=`$gnutlsconfig $modver`
case "$version" in
'') ;;
*)
	vint=`echo $version | $awk -F. '{print $1 * 10000 + $2 * 100 + $3;}'`
	if test 0$vint -lt 020205; then
		echo "Sorry, you have GnuTLS $version, I need at least 2.2.5." >&4
	else
		echo "Good, you have GnuTLS $version." >&4
		
		$cat <<'EOM'

GnuTLS allows encryption of downloads, uploads and Gnutella connections.

For more information, see http://www.gnu.org/software/gnutls/.

EOM
		rp="Enable GnuTLS support"
		dflt=y
		. ./myread
		case "$ans" in
		y)	gnutlscflags=`$gnutlsconfig --cflags`
			gnutlsldflags=`$gnutlsconfig --libs`
			gnutls="$define";;
		*)	gnutls="$undef";;
		esac
	fi
	;;
esac
;;
esac

val=$gnutls
set d_gnutls
eval $setvar

: see if herror exists
$cat >try.c <<EOC
#include <netdb.h>
int main(void)
{
	herror("string");
	return 0;
}
EOC
cyn=herror
set d_herror
eval $trylink

: see if hstrerror exists
$cat >try.c <<EOC
#include <netdb.h>
int main(void)
{
	static char ret;
	ret |= *hstrerror(1);
	return ret ? 0 : 1;
}
EOC
cyn=hstrerror
set d_hstrerror 
eval $trylink

: check for ieee754 float and their endianness
echo " "
$echo $n "Checking IEEE-754 float byte-ordering...$c" >&4
$cat >try.c <<'EOCP'
float ascii_le[] = {
	3223.213134765625, 6.8273612896518898e-07, 1.9753562586009612e+31, 0 };
float ascii_be[] = {
	865942.3125, 6.7652519659605424e+22, 1.9695089292781631e-07, 0 };
EOCP
order=0
val=''
if $cc -c $ccflags try.c >/dev/null 2>&1; then
	if $contains ISieee754Sys try$_o >/dev/null 2>&1; then
		val=$define
		order=4321
	elif $contains isIEEE754Sys try$_o >/dev/null 2>&1; then
		val=$define
		order=1234
	else
		strings try$_o >str 2>/dev/null
		if $contains ISieee754Sys str >/dev/null 2>&1; then
			val=$define
			order=4321
		elif $contains isIEEE754Sys str >/dev/null 2>&1; then
			val=$define
			order=1234
		else
			val=$undef
		fi
		$rm -f str
	fi
fi
set d_ieee754
eval $setvar
case "$order" in
0)    echo " not using IEEE-754 here." >&4;;
1234) echo " little-endian." >&4;;
4321) echo " big-endian." >&4;;
esac
ieee754_byteorder=$order
$rm -f try.c try$_o

: index or strchr
$cat >try.c <<EOC
#include <string.h>
int main(void)
{
	static char ret;
	static int c;
	ret |= *strchr("string", c);
	return ret ? 0 : 1;
}
EOC
cyn=strchr
set d_strchr
eval $trylink

$cat >try.c <<EOC
#include <strings.h>
int main(void)
{
	static char ret;
	static int c;
	ret |= *index("string", c);
	return ret ? 0 : 1;
}
EOC
cyn=index
set d_index 
eval $trylink

: see if this is a netinet/ip.h system
set netinet/ip.h i_niip
eval $inhdr

: check for IP TOS support
echo " "
echo "Checking whether IP TOS (Type of Service) support is available..." >&4
case "$i_niin" in
"$define") inh=netinet/in.h;;
*)
	case "$i_sysin" in
	"$define") inh=sys/in.h;;
	*)
		case "$i_ws2tcpip" in
		"$define") inh=Ws2tcpip.h;;
		esac
		;;
	esac
	;;
esac
$cat >iptos <<EOM
#$i_syssock I_SYS_SOCKET
#$i_winsock2 I_WINSOCK2
#$d_windows WINDOWS_SYSTEM
#ifdef WINDOWS_SYSTEM
#define WINVER 0x0501
#endif
#ifdef I_SYS_SOCKET
#include <sys/socket.h>
#endif
#ifdef I_WINSOCK2
#include <Winsock2.h>
#endif
#include <$inh>
#if defined(IP_TOS) && defined(IPTOS_LOWDELAY) && defined(IPTOS_THROUGHPUT)
YES
#endif
EOM
$cppstdin $cppflags $cppminus <iptos >iptos.h 2>/dev/null
val="$undef"
if $contains YES iptos.h >/dev/null 2>&1; then
	val="$define"
	echo "You have IP TOS support in <$inh>." >&4
elif $test "x$i_niip" = "x$define"; then
	$cat >iptos <<EOM
#$i_syssock I_SYS_SOCKET
#ifdef I_SYS_SOCKET
#include <sys/socket.h>
#endif
#include <$inh>
#include <netinet/ip.h>
#if defined(IP_TOS) && defined(IPTOS_LOWDELAY) && defined(IPTOS_THROUGHPUT)
YES
#endif
EOM
	$cppstdin $cppflags $cppminus <iptos >iptos.h 2>/dev/null
	if $contains YES iptos.h >/dev/null 2>&1; then
		val="$define"
		echo "You have IP TOS support in <netinet/ip.h>." >&4
	fi
fi
case "$val" in
"$define") ;;
*) echo "Sorry, you seem to be lacking IP TOS support." >&4;;
esac
set d_iptos
eval $setvar
$rm -f iptos iptos.h

: determine whether IPv6 can be used
case "$d_ipv6" in
"$undef") 
	echo "IPv6 support is disabled." >&4
;;
*)
	$cat >try.c <<EOC
#$i_syssock I_SYS_SOCKET
#$i_winsock2 I_WINSOCK2
#$i_ws2tcpip I_WS2TCPIP
#$i_niin I_NETINET_IN
#$i_arpainet I_ARPA_INET
#$i_netdb I_NETDB
#include <sys/types.h>
#ifdef I_SYS_SOCKET
#include <sys/socket.h>
#endif
#ifdef I_NETINET_IN
#include <netinet/in.h>
#endif
#ifdef I_ARPA_INET
#include <arpa/inet.h>
#endif
#ifdef I_NETDB
#include <netdb.h>
#endif
#ifdef I_WINSOCK2
#include <Winsock2.h>
#endif
#ifdef I_WS2TCPIP
#include <Ws2tcpip.h>
#endif
#include "static_assert.h"

int main(void)
{
	struct sockaddr_storage ss;
	struct sockaddr_in6 sin6;
	static struct in6_addr in6;

	ss.ss_family = PF_INET6;

	sin6.sin6_family = AF_INET6;
	sin6.sin6_port = 6346;
	sin6.sin6_flowinfo = 23UL;
	sin6.sin6_scope_id = 42UL;
	sin6.sin6_addr = in6;
	sin6.sin6_addr.s6_addr[0] = in6.s6_addr[0];

	STATIC_ASSERT(AF_INET6 == PF_INET6);
	STATIC_ASSERT(sizeof in6 == sizeof sin6.sin6_addr);
	STATIC_ASSERT(16 == sizeof sin6.sin6_addr.s6_addr);
	STATIC_ASSERT(2 == sizeof sin6.sin6_port);
	STATIC_ASSERT(4 == sizeof sin6.sin6_flowinfo);
	STATIC_ASSERT(4 == sizeof sin6.sin6_scope_id);

	(void) sin6;
	(void) in6;

	return 0;
}
EOC

	cyn="whether IPv6 support is available"
	set d_ipv6
	eval $trylink
	;;
esac

: Look for isascii
$cat >try.c <<EOC
#include <ctype.h>
int main(void)
{
	static int ret, c;
	ret |= isascii(c);
	return ret ? 0 : 1;
}
EOC
cyn=isascii
set d_isascii
eval $trylink

: can we use kqueue?
$cat >try.c <<'EOC'
#include <sys/types.h>
#include <sys/event.h>
#include <sys/time.h>
int main(void)
{
  static struct kevent changes, events;
  static struct timespec ts;
  static unsigned long filter;
  static int kq, fd;
  static unsigned long flags;
  filter |= EVFILT_READ;
  filter |= EVFILT_WRITE;
  filter |= EVFILT_SIGNAL;
  filter |= EVFILT_VNODE;
  filter |= EVFILT_PROC;
  flags |= EV_ADD;
  flags |= EV_ENABLE;
  flags |= EV_ONESHOT;
  flags |= EV_CLEAR;
  flags |= EV_EOF;
  flags |= EV_ERROR;
  flags |= EV_DISABLE;
  flags |= EV_DELETE;
  EV_SET(&changes, fd, filter, flags, 0, 0, 0);
  kq |= kqueue();
  kevent(kq, &changes, 1, &events, 1, &ts);
  return 0;
}
EOC
cyn=kqueue
set d_kqueue
eval $trylink

: check whether udata in struct kevent is an integer
case "$d_kqueue" in
"$define")
	$cat >try.c <<EOC
#include <sys/types.h>
#include <sys/event.h>
#include <sys/time.h>
int main(void)
{
  static struct kevent ev;
  ev.udata |= 1;
  return 0;
}
EOC

	cyn="whether member 'udata' of 'struct kevent' is an integer"
	set d_kevent_int_udata
	eval $trylink
	;;
*)
	val="$undef"
	set d_kevent_int_udata
	eval $setvar
esac

: see if this is a libcharset system
set libcharset.h i_libcharset
eval $inhdr

: can we use locale_charset?
$cat >try.c <<EOC
#$i_libcharset I_LIBCHARSET
#ifdef I_LIBCHARSET
#include <libcharset.h>
#endif
int main(void)
{
	static char ret;
	ret |= *locale_charset();
	return ret ? 0 : 1;
}
EOC
cyn=locale_charset
set d_locale_charset
eval $trylink

: see if lstat exists
$cat >try.c <<EOC
#$i_sysstat I_SYS_STAT
#ifdef I_SYS_STAT
#include <sys/stat.h>
#endif
int main(void)
{
	static int ret;
	struct stat sb;
	ret |= lstat("path", &sb);
	return ret ? 0 : 1;
}
EOC
cyn=lstat
set d_lstat
eval $trylink

: see if sys/mman.h has to be included
set sys/mman.h i_sysmman
eval $inhdr

: see if madvise exists
$cat >try.c <<EOC
#include <sys/types.h>
#$i_sysmman I_SYS_MMAN
#ifdef I_SYS_MMAN
#include <sys/mman.h>
#endif
int main(void)
{
	static int ret;
	static void *p;
	size_t len = 1024;
	ret |= madvise(p, len, 1);
	return ret ? 0 : 1;
}
EOC
cyn=madvise
set d_madvise 
eval $trylink

: see if memalign exists
$cat >try.c <<EOC
#define _GNU_SOURCE
#$i_stdlib I_STDLIB
#ifdef I_STDLIB
#include <stdlib.h>
#endif
#$i_malloc I_MALLOC
#ifdef I_MALLOC
#include <malloc.h>
#endif
int main(void)
{
	static size_t align, size;
	void *p;
	p = memalign(align, size);
	return p ? 0 : 1;
}
EOC
cyn=memalign
set d_memalign
eval $trylink

: see if memcpy exists
$cat >try.c <<EOC
#include <string.h>
int main(void)
{
	static char src, dst;
	void *p;
	p = memcpy(&dst, &src, sizeof(dst));
	return p ? 0 : 1;
}
EOC
cyn=memcpy
set d_memcpy
eval $trylink

: see if memmove exists
$cat >try.c <<EOC
#include <string.h>
int main(void)
{
	static char dst, src;
	void *p;
	p = memmove(&dst, &src, sizeof(dst));
	return p ? 0 : 1;
}
EOC
cyn=memmove
set d_memmove
eval $trylink

: see if mempcpy exists
$cat >try.c <<EOC
#include <string.h>

void *copy(void *d, const void *s, unsigned n)
{
	char *q = d;
	const char *r = s;
	return mempcpy(q + 4, r + 2, n - 1);
}

int main(void)
{
	static char src, dst;
	void *p;
	p = copy(&dst, &src, sizeof(dst));
	return p ? 0 : 1;
}
EOC
cyn=mempcpy
set d_mempcpy
eval $trylink

: see if memrchr exists
$cat >try.c <<EOC
#include <string.h>
int main(void)
{
	static char s[] = "xxx";
	static size_t n = sizeof(s);
	void *p;
	p = memrchr(s, 'x', n);
	return p ? 0 : 1;
}
EOC
cyn=memrchr
set d_memrchr
eval $trylink

: see if memset exists
$cat >try.c <<EOC
#include <string.h>
int main(void)
{
	static int dst, c;
	size_t n = sizeof(dst);
	void *p;
	p = memset(&dst, c, n);
	return p ? 0 : 1;
}
EOC
cyn=memset
set d_memset
eval $trylink

: see if mmap exists
$cat >try.c <<EOC
#include <sys/types.h>
#$i_sysmman I_SYS_MMAN
#ifdef I_SYS_MMAN
#include <sys/mman.h>
#endif
int main(void)
{
	static off_t offset;
	static void *addr;
	static size_t len;
	static int flags, fd, prot;
	void *p;
	flags |= PROT_NONE;
	flags |= PROT_READ;
	flags |= PROT_WRITE;
	flags |= PROT_EXEC;
	p = mmap(addr, len, prot, flags, fd, offset);
	return p ? 0 : 1;
}
EOC
cyn=mmap
set d_mmap
eval $trylink

: see if sys/types.h has to be included
set sys/types.h i_systypes
eval $inhdr

: see if this is a mswsock.h system
set mswsock.h i_mswsock
eval $inhdr

: check for msg_flags in struct msghdr
$cat >try.c <<EOC
#$i_systypes I_SYS_TYPES
#$i_sysselct I_SYS_SELECT
#$i_syssock I_SYS_SOCKET
#$i_winsock2 I_WINSOCK2
#$i_mswsock I_MSWSOCK
#$d_windows WINDOWS_SYSTEM
#ifdef WINDOWS_SYSTEM
#define WINVER 0x0501
#endif
#ifdef I_SYS_TYPES
#include <sys/types.h>
#endif
#ifdef I_SYS_SOCKET
#include <sys/socket.h>
#endif
#ifdef I_WINSOCK2
#include <Winsock2.h>
#endif
#ifdef I_MSWSOCK
#include <Mswsock.h>
#endif
int main(void)
{
	struct msghdr msg;
	msg.msg_flags |= 1;
	return 0;
}
EOC
cyn="whether 'struct msghdr' has a 'msg_flags' member"
set d_msghdr_msg_flags
eval $trylink

: see if nanosleep exists
$cat >try.c <<EOC
#include <time.h>
int main(void)
{
	static int ret;
	static struct timespec request, remain;
	ret |= nanosleep(&request, &remain);
	return ret ? 0 : 1;
}
EOC
cyn=nanosleep
set d_nanosleep 
eval $trylink

: Locate the flags for 'open()'
echo " "
$cat >open3.c <<'EOCP'
#include <sys/types.h>
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
int main(void) {
	if(O_RDONLY);
#ifdef O_TRUNC
	return 0;
#else
	return 1;
#endif
}
EOCP
: check sys/file.h first to get FREAD on Sun
if $test `./findhdr sys/file.h` && \
		$cc $cppflags "-DI_SYS_FILE" -o open3 open3.c >/dev/null 2>&1 ; then
	h_sysfile=true;
	echo "<sys/file.h> defines the O_* constants..." >&4
	if ./open3; then
		echo "and you have the 3 argument form of open()." >&4
		val="$define"
	else
		echo "but not the 3 argument form of open().  Oh, well." >&4
		val="$undef"
	fi
elif $test `./findhdr fcntl.h` && \
		$cc "-DI_FCNTL" -o open3 open3.c >/dev/null 2>&1 ; then
	h_fcntl=true;
	echo "<fcntl.h> defines the O_* constants..." >&4
	if ./open3; then
		echo "and you have the 3 argument form of open()." >&4
		val="$define"
	else
		echo "but not the 3 argument form of open().  Oh, well." >&4
		val="$undef"
	fi
else
	val="$undef"
	./warn "I can't find the O_* constant definitions!  You got problems." 4>&4
fi
set d_open3
eval $setvar
$rm -f open3*

: see if openat exists
$cat >try.c <<EOC
#include <fcntl.h>	/* AT_* constants */
int main(void)
{
	static int ret;
	ret |= openat(AT_FDCWD, "path", /* flags */ 0, /* mode */ 0);
	return ret ? 0 : 1;
}
EOC
cyn=openat
set d_openat
eval $trylink

: see if pause exists
$cat >try.c <<EOC
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static int ret;
	ret |= pause();
	return ret ? 0 : 1;
}
EOC
cyn=pause
set d_pause
eval $trylink

: see if this is a sys/file.h system
val=''
set sys/file.h val
eval $inhdr

: do we need to include sys/file.h ?
case "$val" in
"$define")
	echo " "
	if $h_sysfile; then
		val="$define"
		echo "We'll be including <sys/file.h>." >&4
	else
		val="$undef"
		echo "We won't be including <sys/file.h>." >&4
	fi
	;;
*)
	h_sysfile=false
	;;
esac
set i_sysfile
eval $setvar

: see if pipe2 exists
$cat >try.c <<EOC
#$i_unistd I_UNISTD
#$i_sysfile I_SYS_FILE
#ifdef I_UNISTD
#include <unistd.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>	/* For O_* constants */
#endif
#include <fcntl.h>		/* For O_* constants */
int main(void)
{
	static int fds[2], ret;
	ret |= pipe2(fds, O_CLOEXEC | O_NONBLOCK);
	return ret ? 0 : 1;
}
EOC
cyn=pipe2
set d_pipe2
eval $trylink

: see if there is a poll.h file
set poll.h i_poll
eval $inhdr

: see if there is a sys/poll.h file
set sys/poll.h i_syspoll
eval $inhdr

: see if poll exists
$cat >try.c <<EOC
#include <sys/types.h>
#$i_syspoll I_SYS_POLL
#ifdef I_SYS_POLL
#include <sys/poll.h>
#endif
#$i_poll I_POLL
#ifdef I_POLL
#include <poll.h>
#endif
int main(void)
{
	static int ret, timeout;
	static unsigned n;
	static struct pollfd pfd;
	pfd.fd |= 1;
	pfd.revents |= 1;
	pfd.events |= POLLIN;
	pfd.events |= POLLOUT;
	pfd.events |= POLLPRI;
	pfd.events |= POLLERR;
	pfd.events |= POLLHUP;
	pfd.events |= POLLNVAL;
	ret |= poll(&pfd, n, timeout);
	return ret ? 0 : 1;
}
EOC
cyn=poll
set d_poll
eval $trylink

: see which of string.h or strings.h is needed
echo " "
strings=`./findhdr string.h`
if $test "$strings" && $test -r "$strings"; then
	echo "Using <string.h> instead of <strings.h>." >&4
	val="$define"
else
	val="$undef"
	strings=`./findhdr strings.h`
	if $test "$strings" && $test -r "$strings"; then
		echo "Using <strings.h> instead of <string.h>." >&4
	else
		./warn "No string header found -- You'll surely have problems." 4>&4
	fi
fi
set i_string
eval $setvar
case "$i_string" in
"$undef") strings=`./findhdr strings.h`;;
*)	  strings=`./findhdr string.h`;;
esac

: see if popcount exists
$cat >try.c <<EOC
#$i_string I_STRING
#ifdef I_STRING
#include <string.h>
#else
#include <strings.h>
#endif
int main(void)
{
	static int ret;
	ret |= popcount(127);
	return ret ? 0 : 1;
}
EOC
cyn=popcount
set d_popcount
eval $trylink

: see if popen exists
$cat >try.c <<EOC
#include <stdio.h>
int main(void)
{
	FILE *f;

	f = popen("command", "mode");
	return f ? 0 : 1;
}
EOC
cyn=popen
set d_popen
eval $trylink

: can we use posix_fadvise?
$cat >try.c <<'EOC'
#include <sys/types.h>
#include <fcntl.h>
int main(void)
{
  static int ret, fd;
  static off_t offset, size;
  static int hint;

  hint	= POSIX_FADV_NORMAL
	| POSIX_FADV_RANDOM
	| POSIX_FADV_SEQUENTIAL
	| POSIX_FADV_WILLNEED
	| POSIX_FADV_DONTNEED
	| POSIX_FADV_NOREUSE;

  ret |= posix_fadvise(fd, offset, size, hint);
  return ret ? 0 : 1;
}
EOC
cyn=posix_fadvise
set d_posix_fadvise
eval $trylink

: can we use posix_memalign?
$cat >try.c <<EOC
#$i_stdlib I_STDLIB
#ifdef I_STDLIB
#include <stdlib.h>
#endif
int main(void)
{
  static int ret;
  static size_t align, size;
  void *p;
  ret |= posix_memalign(&p, align, size);
  return ret ? 0 : 1;
}
EOC
cyn=posix_memalign
set d_posix_memalign
eval $trylink

: see if pread exists
$cat >try.c <<EOC
#define _GNU_SOURCE
#include <sys/types.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static ssize_t ret;
	static int fd;
	static char buf[1];
	static size_t size;
	static off_t offset;
	ret |= pread(fd, buf, size, offset);
	return ret ? 0 : 1;
}
EOC
cyn=pread
set d_pread
eval $trylink

: see if preadv exists
$cat >try.c <<EOC
#include <sys/types.h>
#include <sys/uio.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static ssize_t ret;
	static int fd, iovcnt;
	static struct iovec iov;
	static off_t offset;
	ret |= preadv(fd, &iov, iovcnt, offset);
	return ret ? 0 : 1;
}
EOC
cyn=preadv
set d_preadv
eval $trylink

: do we have the program_invocation_name variable?
$cat >try.c <<EOC
#include <stdio.h>
#define __USE_GNU
#include <errno.h>
int main(void)
{
	printf("%s\n%s\n", program_invocation_name, program_invocation_short_name);
	return 0;
}
EOC
cyn="whether C startup sets program_invocation_name"
set d_proginvocname
eval $trylink

: can we use pthread_attr_setstack
$cat >try.c <<'EOC'
#include <pthread.h>
int main(void)
{
	pthread_attr_t attr;
	void *p = NULL;
	static int ret;

	ret |= pthread_attr_setstack(&attr, p, 4096);
	return ret ? 0 : 1;
}
EOC
cyn=pthread_attr_setstack
set d_ptattr_setstack '-lpthread'
eval $trylink

: see if pwrite exists
$cat >try.c <<EOC
#define _GNU_SOURCE
#include <sys/types.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static ssize_t ret;
	static int fd;
	static char buf[1];
	static size_t size;
	static off_t offset;
	ret |= pwrite(fd, buf, size, offset);
	return ret ? 0 : 1;
}
EOC
cyn=pwrite
set d_pwrite
eval $trylink

: see if pwritev exists
$cat >try.c <<EOC
#include <sys/types.h>
#include <sys/uio.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static ssize_t ret;
	static int fd, iovcnt;
	static struct iovec iov;
	static off_t offset;
	ret |= pwritev(fd, &iov, iovcnt, offset);
	return ret ? 0 : 1;
}
EOC
cyn=pwritev
set d_pwritev
eval $trylink

: check for recvmsg function
$cat >try.c <<EOC
#$i_systypes I_SYS_TYPES
#$i_sysselct I_SYS_SELECT
#$i_syssock I_SYS_SOCKET
#$i_winsock2 I_WINSOCK2
#$i_mswsock I_MSWSOCK
#$d_windows WINDOWS_SYSTEM
#ifdef WINDOWS_SYSTEM
#define WINVER 0x0501
#endif
#ifdef I_SYS_TYPES
#include <sys/types.h>
#endif
#ifdef I_SYS_SOCKET
#include <sys/socket.h>
#endif
#ifdef I_WINSOCK2
#include <Winsock2.h>
#endif
#ifdef I_MSWSOCK
#include <Mswsock.h>
#endif
int main(void)
{
	static struct msghdr msg;
	int ret, fd, flags;

	fd = 1;
	flags = 1;
	msg.msg_name = (void *) 0;
	msg.msg_namelen |= 1;
	msg.msg_iov = (void *) 0;
	msg.msg_iovlen |= 1;
	/* msg.msg_flags is intentionally excluded, see other unit */
	msg.msg_control = (void *) 0;
	msg.msg_controllen |= 1;
	ret = recvmsg(fd, &msg, flags);
	return ret ? 0 : 1;
}
EOC
cyn='recvmsg'
set d_recvmsg
eval $trylink

: see if regcomp exists
$cat >try.c <<EOC
#include <regex.h>
int main(void)
{
	int ret = 0;
	regex_t re;
	ret |= regcomp(&re, ".",
		REG_EXTENDED | REG_NOSUB | REG_ICASE | REG_NEWLINE);
	return ret ? 0 : 1;
}
EOC
cyn=regcomp
set d_regcomp
eval $trylink

: check whether '__attribute__((__regparm__(n)))' can be used
val="$undef"
if [ "x$gccversion" != x ]
then
	$cat >try.c <<'EOC'
static __attribute__((__regparm__(1))) int
blah(int x)
{
	return x / 2;
}
int main(int argc, char *argv[])
{
	(void) argv;
	return blah(argc);
}
EOC
	if $cc $ccflags -Werror $ldflags -o try try.c >/dev/null 2>&1
	then
		val="$define"
	fi
	$rm -rf try try.*
fi

set d_regparm
eval $setvar

: see if sys/resource.h has to be included
set sys/resource.h i_sysresrc
eval $inhdr

: see if getrusage exists
$cat >try.c <<EOC
#include <sys/types.h>
#include <sys/time.h>
#$i_sysresrc I_SYS_RESOURCE
#ifdef I_SYS_RESOURCE
#include <sys/resource.h>
#endif
int main(void)
{
	static struct rusage ru;
	static int ret;
	ret |= getrusage(RUSAGE_SELF, &ru);
	ret |= getrusage(RUSAGE_CHILDREN, &ru);
	return ret ? 0 : 1;
}
EOC
cyn=getrusage
set d_rusage
eval $trylink

: see if sbrk exists
$cat >try.c <<EOC
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	void *ret;
	ret = sbrk(1);
	return ret ? 0 : 1;
}
EOC
cyn=sbrk
set d_sbrk
eval $trylink

: see if sched_yield exists
$cat >try.c <<EOC
#include <sched.h>
int main(void)
{
	static int ret;
	ret |= sched_yield();
	return ret ? 0 : 1;
}
EOC
cyn=sched_yield
set d_sched_yield
eval $trylink

: see if select exists
$cat >try.c <<EOC
#$i_unistd I_UNISTD
#$i_systypes I_SYS_TYPES
#$i_sysselct I_SYS_SELECT
#$i_winsock2 I_WINSOCK2
#ifdef I_SYS_TYPES
#include <sys/types.h>
#endif
#ifdef I_UNISTD
#include <unistd.h>
#endif
#ifdef I_SYS_SELECT
#include <sys/select.h>
#endif
#ifdef I_WINSOCK2
#include <Winsock2.h>
#endif
int main(void)
{
	static int ret, n;
	static fd_set r, w, x;
	static struct timeval timeout;
	ret |= select(n, &r, &w, &x, &timeout);
	return ret ? 0 : 1;
}
EOC
cyn=select
set d_select '-lWs2_32'
eval $trylink

: see if semctl exists
$cat >try.c <<EOC
#include <sys/sem.h>
int main(void)
{
	static int ret, id, num;
	static union semun {
		int val;
		struct semid_ds *buf;
		unsigned short  *array;
	} arg;
	ret |= semctl(id, num, GETVAL, &arg);
	ret |= semctl(id, num, SETVAL, &arg);
	ret |= semctl(id, num, GETPID, &arg);
	ret |= semctl(id, num, GETNCNT, &arg);
	ret |= semctl(id, num, GETZCNT, &arg);
	ret |= semctl(id, num, GETALL, &arg);
	ret |= semctl(id, num, SETALL, &arg);
	return ret ? 0 : 1;
}
EOC
cyn=semctl
set d_semctl
eval $trylink

: see if semget exists
$cat >try.c <<EOC
#include <sys/ipc.h>
#include <sys/sem.h>
int main(void)
{
	static int ret, n, flags;
	static key_t key;
	key = IPC_PRIVATE;
	flags |= IPC_CREAT;
	flags |= IPC_EXCL;
	ret |= semget(key, n, flags);
	return ret ? 0 : 1;
}
EOC
cyn=semget
set d_semget
eval $trylink

: see if semop exists
$cat >try.c <<EOC
#include <sys/ipc.h>
#include <sys/sem.h>
int main(void)
{
	static int ret, id;
	static size_t n;
	static struct sembuf buf;
	
	buf.sem_num |= 1;
	buf.sem_op |= 1;
	buf.sem_flg |= SEM_UNDO;
	buf.sem_flg |= IPC_NOWAIT;
	ret |= semop(id, &buf, n);
	return ret ? 0 : 1;
}
EOC
cyn=semop
set d_semop
eval $trylink

: see if semtimedop exists
$cat >try.c <<EOC
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int main(void)
{
	static int ret, id;
	static size_t n;
	static struct sembuf buf;

	
	buf.sem_num |= 1;
	buf.sem_op |= 1;
	buf.sem_flg |= SEM_UNDO;
	buf.sem_flg |= IPC_NOWAIT;
	ret |= semtimedop(id, &buf, n, (struct timespec *) 0);
	return ret ? 0 : 1;
}
EOC
cyn=semtimedop
set d_semtimedop
eval $trylink

: see if sendfile exists
$cat >try.c <<EOC
#include <sys/types.h>
#include <sys/sendfile.h>
int main(void)
{
	static ssize_t ret;
	static int out_fd, in_fd;
	static off_t offset;
	static size_t n;
	ret |= sendfile(out_fd, in_fd, &offset, n);
	return ret ? 0 : 1;
}
EOC
cyn=sendfile
set d_sendfile '-lsendfile'
eval $trylink

: do we have setenv?
$cat >try.c <<EOC
#$i_stdlib I_STDLIB
#ifdef I_STDLIB
#include <stdlib.h>
#endif
int main(void)
{
	return setenv("foo", "bar", 1);
}
EOC
cyn=setenv
set d_setenv
eval $trylink

: can we use setproctitle?
$cat >try.c <<EOC
#include <sys/types.h>
#$i_stdlib I_STDLIB
#ifdef I_STDLIB
#include <stdlib.h>
#endif
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
  setproctitle("%s %d %s %c", "blah", 1, "x", 'X');
  return 0;
}
EOC
cyn=setproctitle
set d_setproctitle
eval $trylink

: can we use setprogname?
$cat >try.c <<EOC
#include <sys/types.h>
#$i_stdlib I_STDLIB
#ifdef I_STDLIB
#include <stdlib.h>
#endif
int main(void)
{
	setprogname("test");
	return 0;
}
EOC
cyn=setprogname
set d_setprogname
eval $trylink

: see if setsid exists
$cat >try.c <<EOC
#include <sys/types.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static pid_t ret;
	ret |= setsid();
	return ret ? 0 : 1;
}
EOC
cyn=setsid
set d_setsid
eval $trylink

: see if we have sigaction
$cat >try.c <<EOC
#include <stdio.h>
#include <sys/types.h>
#include <signal.h>
int main(void)
{
	struct sigaction act, oact;
	static int ret, sig;
	ret |= sigaction(sig, &act, &oact);
	return ret ? 0 : 1;
}
EOC
cyn=sigaction
set d_sigaction
eval $trylink

: see if we have sigaltstack
$cat >try.c <<EOC
#include <stdio.h>
#include <signal.h>
int main(void)
{
	stack_t ss;
	static int ret;
	ss.ss_sp = NULL;
	ss.ss_flags |= SS_ONSTACK | SS_DISABLE;
	ss.ss_size = SIGSTKSZ + MINSIGSTKSZ;
	ret |= sigaltstack(&ss, NULL);
	return ret ? 0 : 1;
}
EOC
cyn=sigaltstack
set d_sigaltstack
eval $trylink

: see if sigprocmask exists
$cat >try.c <<EOC
#include <signal.h>
int main(void)
{
	static int ret;
	sigset_t oset;
	ret |= sigprocmask(SIG_BLOCK, &oset, &oset);
	return ret ? 0 : 1;
}
EOC
cyn=sigprocmask
set d_sigprocmask
eval $trylink

: see if sigsetjmp exists
echo " "
case "$d_sigsetjmp" in
'')
	$cat >set.c <<'EOP'
#include <setjmp.h>
sigjmp_buf env;
int set = 1;
int main(void)
{
	if (sigsetjmp(env,1))
		return set;
	set = 0;
	siglongjmp(env, 1);
	return 1;
}
EOP
	if $cc $ccflags $ldflags -o set set.c $libs >/dev/null 2>&1; then
		if ./set >/dev/null 2>&1; then
			echo "POSIX sigsetjmp() found." >&4
			val="$define"
		else
			$cat >&4 <<EOM
Uh-Oh!
You have POSIX sigsetjmp() and siglongjmp(), but they do not work properly!!
I'll ignore them.
EOM
			val="$undef"
		fi
	else
		echo "sigsetjmp() not found." >&4
		val="$undef"
	fi
	;;
*) val="$d_sigsetjmp"
	case "$d_sigsetjmp" in
	$define) echo "POSIX sigsetjmp() found." >&4;;
	$undef) echo "sigsetjmp() not found." >&4;;
	esac
	;;
esac
set d_sigsetjmp
eval $setvar
$rm -f set.c set

: does struct sockaddr_in has sin_len
$cat >try.c <<EOC
#$i_syssock I_SYS_SOCKET
#$i_niin I_NETINET_IN
#$i_winsock2 I_WINSOCK2
#$i_arpainet I_ARPA_INET
#include <sys/types.h>
#ifdef I_SYS_SOCKET
#include <sys/socket.h>
#endif
#ifdef I_NETINET_IN
#include <netinet/in.h>
#endif
#ifdef I_ARPA_INET
#include <arpa/inet.h>
#endif
#ifdef I_WINSOCK2
#include <Winsock2.h>
#endif
int main(void)
{
	static struct sockaddr_in addr;
	addr.sin_len = 1;
	return 0;
}
EOC
cyn="whether 'struct sockaddr_in' has a 'sin_len' member"
set d_sockaddr_in_sin_len
eval $trylink

: see if this is a sys/un.h system
set sys/un.h i_sysun
eval $inhdr

: does struct sockaddr_un exists?
$cat >try.c <<EOC
#$i_syssock I_SYS_SOCKET
#$i_sysun I_SYS_UN
#$i_niin I_NETINET_IN
#$i_winsock2 I_WINSOCK2
#$i_arpainet I_ARPA_INET
#include <sys/types.h>
#ifdef I_SYS_SOCKET
#include <sys/socket.h>
#endif
#ifdef I_SYS_UN
#include <sys/un.h>
#endif
#ifdef I_NETINET_IN
#include <netinet/in.h>
#endif
#ifdef I_ARPA_INET
#include <arpa/inet.h>
#endif
#ifdef I_WINSOCK2
#include <Winsock2.h>
#endif
#if !defined(AF_LOCAL) && defined(AF_UNIX)
#define AF_LOCAL AF_UNIX
#endif
int main(void)
{
	static struct sockaddr_un addr;
	addr.sun_family = AF_LOCAL;
	return 0;
}
EOC
cyn="whether 'struct sockaddr_un' is available"
set d_sockaddr_un
eval $trylink

: determine whether socker_get is available
case "$d_socker_get" in
"$undef") echo " "; echo "socker support is disabled." >&4;;
*)
	$cat >try.c <<'EOC'
#include <sys/types.h>
#include <socker.h>
int main(void)
{
  static int ret;
  ret |= socker_get(1, 2, 3, "", 5);
  return ret ? 0 : 1;
}
EOC
	sockercflags=`socker-config --cflags 2>/dev/null`
	sockerldflags=`socker-config --libs 2>/dev/null`
	saved_ccflags=$ccflags
	saved_ldflags=$ldflags
	ccflags="$ccflags $sockercflags"
	ldflags="$ldflags $sockerldflags"
	cyn="whether socket_get() allows binding to privileged ports"
	set d_socker_get
	eval $trylink
	ccflags=$saved_ccflags
	ldflags=$saved_ldflags
	case "$d_socker_get" in
	"$undef")
		sockercflags=''
		sockerldflags=''
		;;
	esac
	;;
esac

: see whether socket exists
socketlib=''
sockethdr=''
echo " "
$echo $n "Hmm... $c" >&4
if set socket val -f d_socket; eval $csym; $val; then
	echo "Looks like you have Berkeley networking support." >&4
	d_socket="$define"
	if set setsockopt val -f; eval $csym; $val; then
		d_oldsock="$undef"
	else
		echo "...but it uses the old 4.1c interface, rather than 4.2" >&4
		d_oldsock="$define"
	fi
else
	if $contains socklib libc.list >/dev/null 2>&1; then
		echo "Looks like you have Berkeley networking support." >&4
		d_socket="$define"
		: we will have to assume that it supports the 4.2 BSD interface
		d_oldsock="$undef"
	else
		echo "You don't have Berkeley networking in libc$_a..." >&4
		if test -f /usr/lib/libnet$_a; then
			( (nm $nm_opt /usr/lib/libnet$_a | eval $nm_extract) ||  \
			ar t /usr/lib/libnet$_a) 2>/dev/null >> libc.list
			if $contains socket libc.list >/dev/null 2>&1; then
			echo "...but the Wollongong group seems to have hacked it in." >&4
				socketlib="-lnet"
				sockethdr="-I/usr/netinclude"
				d_socket="$define"
				if $contains setsockopt libc.list >/dev/null 2>&1; then
					d_oldsock="$undef"
				else
					echo "...using the old 4.1c interface, rather than 4.2" >&4
					d_oldsock="$define"
				fi
			else
				echo "or even in libnet$_a, which is peculiar." >&4
				d_socket="$undef"
				d_oldsock="$undef"
			fi
		else
			echo "or anywhere else I see." >&4
			d_socket="$undef"
			d_oldsock="$undef"
		fi
	fi
fi

: see if socketpair exists
$cat >try.c <<EOC
#$i_syssock I_SYS_SOCKET
#$i_winsock2 I_WINSOCK2
#ifdef I_SYS_SOCKET
#include <sys/socket.h>
#endif
#ifdef I_WINSOCK2
#include <Winsock2.h>
#endif
int main(void)
{
	static int ret, domain, type, protocol, sv[2];
	ret |= socketpair(domain, type, protocol, sv);
	return ret ? 0 : 1;
}
EOC
cyn=socketpair
set d_sockpair
eval $trylink

: see if this is a sys/mount system
set sys/mount.h i_sysmount
eval $inhdr

: see if this is a sys/param system
set sys/param.h i_sysparam
eval $inhdr

: see if this is a sys/vfs system
set sys/vfs.h i_sysvfs
eval $inhdr

: see if statfs exists
$cat >try.c <<EOC
#$i_sysparam I_SYS_PARAM
#ifdef I_SYS_PARAM
#include <sys/param.h>
#endif
#$i_sysmount I_SYS_MOUNT
#ifdef I_SYS_MOUNT
#include <sys/mount.h>
#endif
#$i_sysvfs I_SYS_VFS
#ifdef I_SYS_VFS
#include <sys/vfs.h>
#endif
int main(void)
{
	static int ret;
	static char *p;
	static struct statfs buf;
	ret |= statfs(p, &buf);
	return ret ? 0 : 1;
}
EOC
cyn=statfs
set d_statfs 
eval $trylink

: see if statvfs exists
$cat >try.c <<EOC
#include <sys/statvfs.h>
int main(void)
{
	static int ret;
	static char *p;
	static struct statvfs buf;
	ret |= statvfs(p, &buf);
	return ret ? 0 : 1;
}
EOC
cyn=statvfs
set d_statvfs 
eval $trylink

: see if strlcat exists
$cat >try.c <<EOC
#include <string.h>
int main(void)
{
	static size_t ret, size;
	static char dst;
	ret |= strlcat(&dst, "src", size);
	return ret ? 0 : 1;
}
EOC
cyn=strlcat
set d_strlcat
eval $trylink

: see if strlcpy exists
$cat >try.c <<EOC
#include <string.h>
int main(void)
{
	static size_t ret, size;
	static char dst;
	ret |= strlcpy(&dst, "src", size);
	return ret ? 0 : 1;
}
EOC
cyn=strlcpy
set d_strlcpy
eval $trylink

: check for __sync_synchronize and friends
$cat >try.c <<EOC
int main(void)
{
	static int ret;
	int i;
	__sync_synchronize();
	ret |= __sync_bool_compare_and_swap(&i, 0, 1);
	ret += __sync_fetch_and_add(&i, 1);
	return ret;
}
EOC
cyn="whether atomic memory operations are possible"
set d_sync_atomic
eval $trylink

: see if syscall exists
$cat >try.c <<EOC
#include <sys/syscall.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static int ret, number;
	ret |= syscall(number, 0);
	return ret ? 0 : 1;
}
EOC
cyn=syscall
set d_syscall
eval $trylink

: see if sysctl exists
$cat >try.c <<EOC
#include <sys/param.h>
#include <sys/sysctl.h>
int main(void)
{
	static int ret, name;
	static unsigned int namelen;
	static void *oldp, *newp;
	static size_t oldlen, newlen;
	ret |= sysctl(&name, namelen, oldp, &oldlen, newp, newlen);
	return ret ? 0 : 1;
}
EOC
cyn=sysctl
set d_sysctl
eval $trylink

: see if system exists
$cat >try.c <<EOC
#$i_stdlib I_STDLIB
#ifdef I_STDLIB
#include <stdlib.h>
#endif
int main(void)
{
	static int ret;
	ret |= system("command");
	return ret ? 0 : 1;
}
EOC
cyn=system
set d_system
eval $trylink

: define an is-a-typedef? function
typedef='type=$1; var=$2; def=$3; shift; shift; shift; inclist=$@;
case "$inclist" in
"") inclist="sys/types.h";;
esac;
eval "varval=\$$var";
case "$varval" in
"")
	$rm -f temp.c;
	for inc in $inclist; do
		echo "#include <$inc>" >>temp.c;
	done;
	$cppstdin $cppflags $cppminus < temp.c >temp.E 2>/dev/null;
	if $contains $type temp.E >/dev/null 2>&1; then
		eval "$var=\$type";
	else
		eval "$var=\$def";
	fi;
	$rm -f temp.?;;
*) eval "$var=\$varval";;
esac'

: see if this is a sys/times.h system
set sys/times.h i_systimes
eval $inhdr

: see if times exists
echo " "
if set times val -f d_times; eval $csym; $val; then
	echo 'times() found.' >&4
	d_times="$define"
	inc=''
	case "$i_systimes" in
	"$define") inc='sys/times.h';;
	esac
	set clock_t clocktype long stdio.h sys/types.h $inc
	eval $typedef
	dflt="$clocktype"
	echo " "
	rp="What type is returned by times() on this system?"
	. ./myread
	clocktype="$ans"
else
	echo 'times() NOT found, hope that will do.' >&4
	d_times="$undef"
	clocktype='int'
fi

: see if ttyname exists
$cat >try.c <<EOC
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	char *name = ttyname(1);
	char c = *ttyname(2);
	return name[0] == c ? 0 : 1;
}
EOC
cyn=ttyname
set d_ttyname
eval $trylink

: see if this is a ucontext.h system
set ucontext.h i_ucontext
eval $inhdr

: see if this is a sys/ucontext.h system
set sys/ucontext.h i_sys_ucontext
eval $inhdr

: when both ucontext.h and sys/ucontext.h are available, check which one works
case "$i_ucontext$i_sys_ucontext" in
"$define$define")
	echo " "
	$cat >try.c <<'EOC'
#ifdef I_UCONTEXT
#include <ucontext.h>
#endif
#ifdef I_SYS_UCONTEXT
#include <sys/ucontext.h>
#endif

int main(void)
{
	static ucontext_t u;
	return (int) sizeof(u) & 0xff;
}
EOC
	$echo $n "Checking whether including <ucontext.h> alone works...$c" >&4
	working=
	if $cc $ccflags -DI_UCONTEXT -o try try.c $ldflags >/dev/null 2>&1; then
		working="$define"
	fi
	case "$working" in
	"$define")
		echo " yes." >&4
		i_sys_ucontext="$undef"
		;;
	*)
		echo "no." >&4
		echo " "
		$echo $n "Checking whether including <sys/ucontext.h> works...$c" >&4
		working=
		if $cc $ccflags -DI_SYS_UCONTEXT \
			-o try try.c $ldflags >/dev/null 2>&1
		then
			working="$define"
		fi
		case "$working" in
		"$define")
			echo " yes, ignoring <ucontext.h>." >&4
			i_ucontext="$undef"
			;;
		*) echo " no, we'll include both then." >&4;;
		esac
		;;
	esac
	;;
esac
$rm -f try.*

: check for machine context field in the ucontext structure
$cat >try.c <<EOC
#$i_ucontext I_UCONTEXT
#$i_sys_ucontext I_SYS_UCONTEXT
#ifdef I_UCONTEXT
#include <ucontext.h>
#endif
#ifdef I_SYS_UCONTEXT
#include <sys/ucontext.h>
#endif
int main(void)
{
	static ucontext_t *uc = 0;
	return (int) &uc->uc_mcontext;
}
EOC
cyn="whether 'struct ucontext' has a 'uc_mcontext' member"
set d_uctx_mctx
eval $trylink

: check for general register access through the ucontext structure
$cat >try.c <<EOC
#$i_ucontext I_UCONTEXT
#$i_sys_ucontext I_SYS_UCONTEXT
#ifdef I_UCONTEXT
#include <ucontext.h>
#endif
#ifdef I_SYS_UCONTEXT
#include <sys/ucontext.h>
#endif
int main(void)
{
	static ucontext_t uc;
	return uc.uc_mcontext.gregs[0];
}
EOC
cyn="whether 'struct ucontext' has a 'mcontext.gregs[]' member"
set d_uctx_mctx_gregs
eval $trylink

: see if we have to deal with yellow pages, now NIS.
if $test -d /usr/etc/yp || $test -d /etc/yp || $test -d /usr/lib/yp; then
	if $test -f /usr/etc/nibindd; then
		echo " "
		echo "I'm fairly confident you're on a NeXT."
		echo " "
		rp='Do you get the hosts file via NetInfo?'
		dflt=y
		case "$hostcat" in
		nidump*) ;;
		'') ;;
		*) dflt=n;;
		esac
		. ./myread
		case "$ans" in
		y*) hostcat='nidump hosts .';;
		*)	case "$hostcat" in
			nidump*) hostcat='';;
			esac
			;;
		esac
	fi
	case "$hostcat" in
	nidump*) ;;
	*)
		case "$hostcat" in
		*ypcat*) dflt=y;;
		'') if $contains '^\+' /etc/passwd >/dev/null 2>&1; then
				dflt=y
			else
				dflt=n
			fi;;
		*) dflt=n;;
		esac
		echo " "
		rp='Are you getting the hosts file via yellow pages?'
		. ./myread
		case "$ans" in
		y*) hostcat='ypcat hosts';;
		*) hostcat='cat /etc/hosts';;
		esac
		;;
	esac
fi
case "$hostcat" in
'') hostcat=':'
	$test -f /etc/hosts && hostcat='cat /etc/hosts';;
esac
case "$groupcat" in
'')	groupcat=':'
	$test -f /etc/group && groupcat='cat /etc/group';;
esac
case "$passcat" in
'') passcat=':'
	$test -f /etc/passwd && passcat='cat /etc/passwd';;
esac

: now get the host name
echo " "
echo "Figuring out host name..." >&4
case "$myhostname" in
'') cont=true
	echo 'Maybe "hostname" will work...'
	if tans=`sh -c hostname 2>&1` ; then
		myhostname=$tans
		phostname=hostname
		cont=''
	fi
	;;
*) cont='';;
esac
if $test "$cont"; then
	if ./xenix; then
		echo 'Oh, dear.  Maybe "/etc/systemid" is the key...'
		if tans=`cat /etc/systemid 2>&1` ; then
			myhostname=$tans
			phostname='cat /etc/systemid'
			echo "Whadyaknow.  Xenix always was a bit strange..."
			cont=''
		fi
	elif $test -r /etc/systemid; then
		echo "(What is a non-Xenix system doing with /etc/systemid?)"
	fi
fi
if $test "$cont"; then
	echo 'No, maybe "uuname -l" will work...'
	if tans=`sh -c 'uuname -l' 2>&1` ; then
		myhostname=$tans
		phostname='uuname -l'
	else
		echo 'Strange.  Maybe "uname -n" will work...'
		if tans=`sh -c 'uname -n' 2>&1` ; then
			myhostname=$tans
			phostname='uname -n'
		else
			echo 'Oh well, maybe I can mine it out of whoami.h...'
			if tans=`sh -c $contains' sysname $usrinc/whoami.h' 2>&1` ; then
				myhostname=`echo "$tans" | $sed 's/^.*"\(.*\)"/\1/'`
				phostname="sed -n -e '"'/sysname/s/^.*\"\\(.*\\)\"/\1/{'"' -e p -e q -e '}' <$usrinc/whoami.h"
			else
				case "$myhostname" in
				'') echo "Does this machine have an identity crisis or something?"
					phostname='';;
				*)
					echo "Well, you said $myhostname before..."
					phostname='echo $myhostname';;
				esac
			fi
		fi
	fi
fi
case "$myhostname" in
'') myhostname=noname ;;
esac
: you do not want to know about this
set $myhostname
myhostname=$1

: verify guess
if $test "$myhostname" ; then
	dflt=y
	rp='Your host name appears to be "'$myhostname'".'" Right?"
	. ./myread
	case "$ans" in
	y*) ;;
	*) myhostname='';;
	esac
fi

: bad guess or no guess
while $test "X$myhostname" = X ; do
	dflt=''
	rp="Please type the (one word) name of your host:"
	. ./myread
	myhostname="$ans"
done

: translate upper to lower if necessary
case "$myhostname" in
*[A-Z]*)
	echo "(Normalizing case in your host name)"
	myhostname=`echo $myhostname | ./tr '[A-Z]' '[a-z]'`
	;;
esac

: a little sanity check here
case "$phostname" in
'') ;;
*)
	case `$phostname | ./tr '[A-Z]' '[a-z]'` in
	$myhostname$mydomain|$myhostname) ;;
	*)
		case "$phostname" in
		sed*)
			echo "(That doesn't agree with your whoami.h file, by the way.)"
			;;
		*)
			echo "(That doesn't agree with your $phostname command, by the way.)"
			;;
		esac
	;;
	esac
	;;
esac

: see how we will look up host name
echo " "
if false; then
	: dummy stub to allow use of elif
elif set uname val -f d_uname; eval $csym; $val; then
	if ./xenix; then
		$cat <<'EOM'
uname() was found, but you're running xenix, and older versions of xenix
have a broken uname(). If you don't really know whether your xenix is old
enough to have a broken system call, use the default answer.

EOM
		dflt=y
		case "$d_uname" in
		"$define") dflt=n;;
		esac
		rp='Is your uname() broken?'
		. ./myread
		case "$ans" in
		n*) d_uname="$define"; call=uname;;
		esac
	else
		echo 'uname() found.' >&4
		d_uname="$define"
		call=uname
	fi
fi
case "$d_gethname" in
'') d_gethname="$undef";;
esac
case "$d_uname" in
'') d_uname="$undef";;
esac
case "$d_phostname" in
'') d_phostname="$undef";;
esac

: see if usleep exists
$cat >try.c <<EOC
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static unsigned ret;
	ret |= usleep(1);
	return ret ? 0 : 1;
}
EOC
cyn=usleep
set d_usleep
eval $trylink

: see if there is a vfork
$cat >try.c <<EOC
#include <sys/types.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	static pid_t ret;
	ret |= vfork();
	return ret ? 0 : 1;
}
EOC
cyn=vfork
set val
eval $trylink


: Ok, but do we want to use it. vfork is reportedly unreliable in 
: perl on Solaris 2.x, and probably elsewhere.
case "$val" in
$define)
	echo " "
	case "$usevfork" in
	false) dflt='n';;
	*) dflt='y';;
	esac
	rp="Some systems have problems with vfork().  Do you want to use it?"
	. ./myread
	case "$ans" in
	y|Y) ;;
	*)
		echo "Ok, we won't use vfork()."
		val="$undef"
		;;
	esac
	;;
esac
set d_vfork
eval $setvar
case "$d_vfork" in
$define) usevfork='true';;
*) usevfork='false';;
esac

: check for volatile keyword
echo " "
echo 'Checking to see if your C compiler knows about "volatile"...' >&4
$cat >try.c <<'EOCP'
int main(void)
{
	typedef struct _goo_struct goo_struct;
	goo_struct * volatile goo = ((goo_struct *)0);
	struct _goo_struct {
		long long_int;
		int reg_int;
		char char_var;
	};
	typedef unsigned short foo_t;
	static char *volatile foo;
	static volatile int bar;
	static volatile foo_t blech;
	foo = foo;
	(void) goo;
	(void) foo;
	(void) bar;
	(void) blech;
	return 0;
}
EOCP
if $cc -c $ccflags try.c; then
	val="$define"
	echo "Yup, it does."
else
	val="$undef"
	echo "Nope, it doesn't."
fi
set d_volatile
eval $setvar
$rm_try

: see if vsnprintf exists
$cat >try.c <<EOC
#include <stdarg.h>
#include <stdio.h>
int func(char *s, ...)
{
	static int ret;
	static char buf;
	static size_t n;
	va_list ap;
	(void) s;
	ret |= vsnprintf(&buf, n, "fmt", ap);
	return ret;
}

int main(void)
{
	return func("xxx", 1);
}
EOC
cyn=vsnprintf
set d_vsnprintf
eval $trylink

: see if this is a syswait system
set sys/wait.h i_syswait
eval $inhdr

: see if waitpid exists
$cat >try.c <<EOC
#include <sys/types.h>
#$i_syswait I_SYS_WAIT
#ifdef I_SYS_WAIT
#include <sys/wait.h>
#endif
int main(void)
{
	static pid_t ret, pid;
	static int status, options;
	options |= WNOHANG;
	options |= WUNTRACED;
	ret |= waitpid(pid, &status, options);
	return ret ? 0 : 1;
}
EOC
cyn=waitpid
set d_waitpid
eval $trylink

: preserve RCS keywords in files with variable substitution, grrr
Id='$Id'

: determine how to compile for large 64-bit file support
echo " "
echo "Checking whether we need flags for large file support..." >&4
flags='-D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64'
$cat >try.c <<EOC
#include <sys/types.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	switch (0) { case 0: case (sizeof(off_t) >= 8): break; }
	return 0;
}
EOC

result=''
set result
eval $trylink

case "$result" in
"$define")
	echo "Selected C flags already provide 64-bit file support."
	;;
"$undef")
	echo "You're not natively compiling for large file, fixing..." >&4

	saved_ccflags=$ccflags
	ccflags="$flags $ccflags"

	$cat >try.c <<EOC
#include <sys/types.h>
#$i_unistd I_UNISTD
#ifdef I_UNISTD
#include <unistd.h>
#endif
int main(void)
{
	switch (0) { case 0: case (sizeof(off_t) >= 8): break; }
	return 0;
}
EOC
	result=''
	set result
	eval $trylink

	case "$result" in
	"$define")
		echo "(Adding $flags)"
		;;
	"$undef")
		echo "(Could not compile the test program, using 32-bit files)" >&4
		ccflags=$saved_ccflags
		;;
	esac	
	;;
esac

: see if this is a inttypes.h system
set inttypes.h i_inttypes
eval $inhdr

: see if this is a limits.h system
set limits.h i_limits
eval $inhdr

: see if this is a math.h system
set math.h i_math
eval $inhdr

: see whether we need libm
$cat >try.c <<EOC
#$i_math I_MATH
#ifdef I_MATH
#include <math.h>
#endif
int main(void)
{
	static double ret;

	ret += 1.2 * pow(1.2, 1.2);
	ret += 1.2 * sqrt(ret);
	return 0 != ret;
}
EOC
set val '-lm'
eval $trylink

: check for alignment requirements
echo " "
case "$alignbytes" in
'')
	echo "Checking alignment constraints..." >&4

	for alignment in 8 4 2 1 16 32 error
	do
		$cat >try.c <<EOCP
#$i_inttypes I_INTTYPES
#ifdef I_INTTYPES
#include <inttypes.h>
#endif
#$i_limits I_LIMITS
#ifdef I_LIMITS
#include <limits.h>
#endif
#$i_math I_MATH
#ifdef I_MATH
#include <math.h>
#endif

union u {
	void *void_ptr;
	void (*func_ptr)(void);
	char c;
	short s;
	int i;
	long l;
	float f;
	double d;
#ifdef UINT32_MAX
	uint32_t u32;
#else
#warning "UINT32_MAX undefined"
#endif
#ifdef UINT16_MAX
	uint16_t u16;
#else
#warning "UINT32_MAX undefined"
#endif
#ifdef UINT64_MAX
	uint64_t u64;
#else
#warning "UINT64_MAX undefined"
#endif
#ifdef UINTMAX_MAX
	uintmax_t m;
#else
#warning "UINTMAX_MAX undefined"
#endif
#ifdef UINTPTR_MAX
	uintptr_t up;
#else
#warning "UINTPTR_MAX undefined"
#endif
};

struct s {
	char a;
	union u b;
};

#include "static_assert.h"

int
main(void)
{
	STATIC_ASSERT($alignment == ((sizeof (struct s) - (sizeof (union u)))));
	return 0;
}
EOCP

		result=''
		set result
		eval $trylink
		case "$result" in
		"$define") break;;
		esac
	done

	case "$alignment" in
	error)	dflt='8'
		echo "(I can't seem to compile the test program...)" >&4
		;;
	*)	dflt=$alignment
		;;
	esac
;;
*) dflt="$alignbytes"
	;;
esac
rp="What is the maximum alignment in bytes required for a standard type?"
. ./myread
alignbytes="$ans"

: check for ordering of bytes in a word
echo " "
$echo $n "Checking integer byte-ordering...$c" >&4
$cat >try.c <<'EOCP'
short ascii_be[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
short ascii_le[] = { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
short ebcdic_be[] = { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
short ebcdic_le[] = { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
EOCP
order=''
if $cc -c $ccflags try.c >/dev/null 2>&1; then
	if $contains BIGenDianSyS try$_o >/dev/null 2>&1; then
		order=4321
	elif $contains LiTTleEnDian try$_o >/dev/null 2>&1; then
		order=1234
	else
		$echo $n " wild guessing$c" >&4
		order=4321
	fi
fi
case "$order" in
'')
	echo " cannot compute it." >&4
	rp="Are integers stored in big-endian format?"
	case "$byteorder" in
	1234) dflt=n;;
	*) dflt=y;;
	esac
	. ./myread
	case "$ans" in
	y*) order=4321;;
	*)	order=1234;;
	esac
	;;
1234) echo " little-endian." >&4;;
4321) echo " big-endian." >&4;;
esac
byteorder=$order
$rm_try

: check for length of character
echo " "
$echo $n "Checking to see how big your characters are...$c" >&4
for size in 1 2 4 8 error; do
	$cat >try.c <<EOCP
#include "static_assert.h"
char foo;
int main()
{
	STATIC_ASSERT($size == sizeof(foo));
	return 0;
}
EOCP
	if $cc -c $ccflags try.c >/dev/null 2>&1; then break; fi
done
case "$size" in
error)
	echo " cannot compute it." >&4
	dflt=1
	rp="What is the size of a character (in bytes)?"
	. ./myread
	charsize="$ans"
	;;
*)
	case "$size" in
	1) s='';;
	*) s='s';;
	esac
	echo " $size byte$s." >&4
	charsize=$size
	;;
esac
$rm_try

: how do we catenate cpp tokens here?
echo " "
echo "Checking to see how your cpp does stuff like catenate tokens..." >&4
cpp_quote=''
$cat >cpp_stuff.c <<'EOCP'
#define RCAT(a,b)a/**/b
#define ACAT(a,b)a ## b
RCAT(Rei,ser)
ACAT(Cir,cus)
EOCP
$cppstdin $cppflags $cppminus <cpp_stuff.c >cpp_stuff.out 2>&1
if $contains 'Circus' cpp_stuff.out >/dev/null 2>&1; then
	echo "Oh!  Smells like ANSI's been here."
	echo "We can catify or stringify, separately or together!"
	cpp_stuff=42
elif $contains 'Reiser' cpp_stuff.out >/dev/null 2>&1; then
	echo "Ah, yes!  The good old days!"
	cpp_stuff=1
	$cat >cpp_stuff.c <<'EOCP'
#define SQuoTe(a)"a
#define EQuoTe(a)a"
#define CAT2(a,b)EQuoTe(SQuoTe(a)b)
CAT2(Vic,tory)
EOCP
	$cppstdin $cppflags $cppminus <cpp_stuff.c >cpp_stuff.out 2>&1
	if $contains '"Victory"' cpp_stuff.out >/dev/null 2>&1; then
		echo "I'll resort to a cute trick to also be able to stringify."
		cpp_quote='"'
	else
		$cat <<EOM
However, in the good old days we don't know how to stringify and
catify at the same time...
Hopefully, $package does not need this feature.
EOM
	fi
else
	./warn 4>&4 <<EOM
I can't seem to be able to catenate tokens with your cpp.
You're going to have to edit the values of the following
macros in config.h:

	CAT[2-5]

in order to let me compile.
EOM
	cpp_stuff="/* Help! How do we handle cpp_stuff? */*/"
fi
$rm -f cpp_stuff.*

: see if signal is declared as pointer to function returning int or void
echo " "
xxx=`./findhdr signal.h`
$test "$xxx" && $cppstdin $cppminus $cppflags < $xxx >$$.tmp 2>/dev/null
if $contains 'int.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have int (*signal())() instead of void." >&4
	val="$undef"
elif $contains 'void.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have void (*signal())() instead of int." >&4
	val="$define"
elif $contains 'extern[ 	]*[(\*]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have int (*signal())() instead of void." >&4
	val="$undef"
else
	case "$d_voidsig" in
	'')
	echo "I can't determine whether signal handler returns void or int..." >&4
		dflt=void
		rp="What type does your signal handler return?"
		. ./myread
		case "$ans" in
		v*) val="$define";;
		*) val="$undef";;
		esac;;
	"$define")
		echo "As you already told me, signal handler returns void." >&4;;
	*)
		echo "As you already told me, signal handler returns int." >&4;;
	esac
fi
set d_voidsig
eval $setvar
case "$d_voidsig" in
"$define") signal_t="void";;
*) signal_t="int";;
esac
$rm -f $$.tmp

: check for non-blocking I/O stuff
case "$h_sysfile" in
true) echo "#include <sys/file.h>" > head.c;;
*)
	case "$h_fcntl" in
	true) echo "#include <fcntl.h>" > head.c;;
	*) echo "#include <sys/fcntl.h>" > head.c;;
	esac
	;;
esac
echo " "
echo "Figuring out the flag used by open() for non-blocking I/O..." >&4
case "$o_nonblock" in
'')
	$cat head.c > try.c
	$cat >>try.c <<'EOCP'
#include <stdio.h>
int main(void) {
#ifdef O_NONBLOCK
	printf("O_NONBLOCK\n");
	return 0;
#endif
#ifdef O_NDELAY
	printf("O_NDELAY\n");
	return 0;
#endif
#ifdef FNDELAY
	printf("FNDELAY\n");
#endif
	return 0;
}
EOCP
	if $cc $ccflags $ldflags -o try try.c >/dev/null 2>&1; then
		o_nonblock=`./try`
		case "$o_nonblock" in
		'') echo "I can't figure it out, assuming O_NONBLOCK will do.";;
		*) echo "Seems like we can use $o_nonblock.";;
		esac
	else
		echo "(I can't compile the test program; pray O_NONBLOCK is right!)"
	fi
	;;
*) echo "Using $hint value $o_nonblock.";;
esac
$rm_try

echo " "
echo "Let's see what value errno gets from read() on a $o_nonblock file..." >&4
case "$eagain" in
'')
	$cat head.c > try.c
	$cat >>try.c <<EOCP
#include <errno.h>
#include <sys/types.h>
#include <signal.h>
#include <stdlib.h>
#define MY_O_NONBLOCK $o_nonblock
extern int errno;
$signal_t blech(x) int x; { exit(3); }
EOCP
	$cat >> try.c <<'EOCP'
int main()
{
	int pd[2];
	int pu[2];
	char buf[1];
	char string[100];

	pipe(pd);	/* Down: child -> parent */
	pipe(pu);	/* Up: parent -> child */
	if (0 != fork()) {
		int ret;
		close(pd[1]);	/* Parent reads from pd[0] */
		close(pu[0]);	/* Parent writes (blocking) to pu[1] */
		if (-1 == fcntl(pd[0], F_SETFL, MY_O_NONBLOCK))
			exit(1);
		signal(SIGALRM, blech);
		alarm(5);
		if ((ret = read(pd[0], buf, 1)) > 0)	/* Nothing to read! */
			exit(2);
		sprintf(string, "%d\n", ret);
		write(2, string, strlen(string));
		alarm(0);
#ifdef EAGAIN
		if (errno == EAGAIN) {
			printf("EAGAIN\n");
			goto ok;
		}
#endif
#ifdef EWOULDBLOCK
		if (errno == EWOULDBLOCK)
			printf("EWOULDBLOCK\n");
#endif
	ok:
		write(pu[1], buf, 1);	/* Unblocks child, tell it to close our pipe */
		sleep(2);				/* Give it time to close our pipe */
		alarm(5);
		ret = read(pd[0], buf, 1);	/* Should read EOF */
		alarm(0);
		sprintf(string, "%d\n", ret);
		write(3, string, strlen(string));
		exit(0);
	}

	close(pd[0]);			/* We write to pd[1] */
	close(pu[1]);			/* We read from pu[0] */
	read(pu[0], buf, 1);	/* Wait for parent to signal us we may continue */
	close(pd[1]);			/* Pipe pd is now fully closed! */
	return 0;			/* Bye bye, thank you for playing! */
}
EOCP
	if $cc $ccflags $ldflags -o try try.c >/dev/null 2>&1; then
		echo "$startsh" >mtry
		echo "./try >try.out 2>try.ret 3>try.err || exit 4" >>mtry
		chmod +x mtry
		./mtry >/dev/null 2>&1
		case $? in
		0) eagain=`$cat try.out`;;
		1) echo "Could not perform non-blocking setting!";;
		2) echo "I did a successful read() for something that was not there!";;
		3) echo "Hmm... non-blocking I/O does not seem to be working!";;
		*) echo "Something terribly wrong happened during testing.";;
		esac
		rd_nodata=`$cat try.ret`
		echo "A read() system call with no data present returns $rd_nodata."
		case "$rd_nodata" in
		0|-1) ;;
		*)
			echo "(That's peculiar, fixing that to be -1.)"
			rd_nodata=-1
			;;
		esac
		case "$eagain" in
		'')
			echo "Forcing errno EAGAIN on read() with no data available."
			eagain=EAGAIN
			;;
		*)
			echo "Your read() sets errno to $eagain when no data is available."
			;;
		esac
		status=`$cat try.err`
		case "$status" in
		0) echo "And it correctly returns 0 to signal EOF.";;
		-1) echo "But it also returns -1 to signal EOF, so be careful!";;
		*) echo "However, your read() returns '$status' on EOF??";;
		esac
		val="$define"
		if test "$status" = "$rd_nodata"; then
			./warn "your read() can't distinguish between EOF and no data!" 4>&4
			val="$undef"
		fi
	else
		echo "I can't compile the test program--assuming errno EAGAIN will do."
		eagain=EAGAIN
	fi
	set d_eofnblk
	eval $setvar
	;;
*)
	echo "Using $hint value $eagain."
	echo "Your read() returns $rd_nodata when no data is present."
	case "$d_eofnblk" in
	"$define") echo "And you can see EOF because read() returns 0.";;
	"$undef") echo "But you can't see EOF status from read() returned value.";;
	*)
		echo "(Assuming you can't see EOF status from read anyway.)"
		d_eofnblk=$undef
		;;
	esac
	;;
esac
$rm_try head.c mtry

: look whether system uses EBCDIC
echo " "
echo "Determining whether or not we are on an EBCDIC system..." >&4
$cat >try.c <<'EOM'
int main()
{
	if ('M'==0xd4) return 0;
	return 1;
}
EOM
val=$undef
set try
if eval $compile_ok; then
	if $run ./try; then
		echo "You seem to speak EBCDIC." >&4
		val="$define"
	else
		echo "Nope, no EBCDIC, probably ASCII or some ISO Latin. Or UTF-8." >&4
	fi
else
	echo "I'm unable to compile the test program." >&4
	echo "I'll assume ASCII or some ISO Latin. Or UTF8." >&4
fi
$rm_try
set ebcdic
eval $setvar

: derive which glade to use based on the configured GTK+
echo " "
case "$gtkversion" in
2) glade=glade-2;;
*) glade=glade;;
esac
echo "Compiling for GTK $gtkversion: we'll use '$glade'." >&4

: how can we find information about GLib?
echo " "
echo "Checking how we can gather information about GLib..." >&4
d_glib="$undef"
version=

if [ "$glibversion" = 1 ] && [ glib-config --cflags >/dev/null 2>&1 ]; then
	glibconfig='glib-config'
	modver=--version
elif pkg-config $glibpackage --cflags >/dev/null 2>&1; then
	glibconfig="pkg-config $glibpackage"
	modver=--modversion
elif pkg-config --cflags $glibpackage >/dev/null 2>&1; then
	version=`pkg-config --version`
	echo "(You have a weird pkg-config, version $version)"
	glibcflags=`pkg-config --cflags $glibpackage`
	glibldflags=`pkg-config --libs $glibpackage`
	version=`pkg-config --modversion $glibpackage | head -1`
else
	echo "You've got problems!  Do you have GLib installed?" >&4
	glibconfig='false'
	modver=''
fi

case "$version" in
'')
	echo "(I'll use '$glibconfig' to gather that information.)"
	glibcflags=`$glibconfig --cflags`
	glibldflags=`$glibconfig --libs`
	version=`$glibconfig $modver | head -1`
	;;
esac

case "$glibversion" in
2)
	x=
	for l in $glibldflags; do
		case "$l" in
		-lgthread-2.0) ;;
		*) x="$x $l";;
		esac
	done
	glibldflags=$x
	;;
esac

echo " "
echo "Checking whether glib.h can be compiled against..." >&4
$cat >try.c <<EOC
#include <glib.h>
#ifndef GLIB_MAJOR_VERSION
#error "glib.h not found?"
EOC
case "$d_headless" in
"$define") ;;
*) $cat >>try.c <<EOC
#else
#if GLIB_MAJOR_VERSION != $gtkversion
#error "Wrong glib.h?"
#endif
EOC
	;;
esac
$cat >>try.c <<EOC
#endif

int main(void)
{
  gpointer p;

#if $glibversion >= 2
  p = g_string_overwrite_len(NULL, 0, NULL, 0);
#else
  p = g_malloc(23);
#endif

  if (!p)
    return 1;
  return 0;
}
EOC

if $cc -o try try.c $ccflags $ldflags $glibcflags $glibldflags >/dev/null 2>&1;
then
  d_glib="$define"
  echo "We'll be using GLib version $version." >&4
else 
  ./warn "Cannot compile against GLib version '$version'" 4>&4
fi
$rm -rf try try.*

: how can we find information about GTK?
d_gtk="$undef"
version=
case "$d_headless" in
"$define")
	gtkcflags="$glibcflags"
	gtkldflags="$glibldflags"
	;;
*)
echo " "
echo "Checking how we can gather information about GTK+..." >&4
if [ "$gtkversion" = 1 ] && gtk-config --cflags >/dev/null 2>&1; then
	gtkconfig='gtk-config'
	modver=--version
elif pkg-config $gtkpackage --cflags >/dev/null 2>&1; then
	gtkconfig="pkg-config $gtkpackage"
	modver=--modversion
elif pkg-config --cflags $gtkpackage >/dev/null 2>&1; then
	version=`pkg-config --version`
	echo "(You have a weird pkg-config, version $version)"
	gtkcflags=`pkg-config --cflags $gtkpackage`
	gtkldflags=`pkg-config --libs $gtkpackage`
	version=`pkg-config --modversion $gtkpackage | head -1`
else
	echo "You've got problems!  Do you have GTK+ installed?" >&4
	gtkconfig='false'
	modver=''
fi
case "$version" in
'')
	echo "(I'll use '$gtkconfig' to gather that information.)"
	gtkcflags=`$gtkconfig --cflags`
	gtkldflags=`$gtkconfig --libs`
	version=`$gtkconfig $modver | head -1`
	;;
esac
case "$gtkversion" in
1)
	case "$version" in
	1.*)
		vint=`echo $version | $awk -F. '{print $1 * 10000 + $2 * 100 + $3;}'`
		if test 0$vint -lt 10210; then
			echo "Sorry, you have GTK+ $version, I need at least 1.2.10." >&4
			exit 1;
		else
			echo "OK, you have GTK+ $version" >&4
		fi
		;;
	*)	./warn "you asked for GTK+ $gtkversion, I found $version" 4>&4
		;;
	esac
	;;
2)
	case "$version" in
	2.*)
		vint=`echo $version | $awk -F. '{print $1 * 10000 + $2 * 100 + $3;}'`
		if test 0$vint -lt 20201; then
			echo "Sorry, you have GTK+ $version, I need at least 2.2.1." >&4
			exit 1;
		else
			echo "OK, you have GTK+ $version" >&4
		fi
		;;
	*)	./warn "you asked for GTK+ $gtkversion, I found $version" 4>&4
		;;
	esac
	;;
*)
	echo "Sorry, I don't know anything about GTK+ $version." >&4
	exit 1
	;;
esac
missing=false
allok=true
for flag in "$glibcflags"; do
	case "$gtkcflags" in
	*"$flag"*) ;;
	*) missing=true; break;;
	esac
done
if $missing; then
	echo "(Some GLib C flags are missing from GTK+ flags, adding all of them.)" >&4
	gtkcflags="$gtkcflags $glibcflags"
	allok=false
fi
missing=false
for flag in "$glibldflags"; do
	case "$gtkldflags" in
	*"$flag"*) ;;
	*) missing=true; break;;
	esac
done
if $missing; then
	echo "(Some GLib ld flags are missing from GTK+ flags, adding all of them.)" >&4
	gtkldflags="$gtkldflags $glibldflags"
	allok=false
fi
if $allok; then
	echo "Good, all the cc and ld flags from GLib are included in GTK+ flags." >&4
fi
;;
esac

case "$gtkversion" in
2)
	x=
	for l in $gtkldflags; do
		case "$l" in
		-lgio-2.0) ;;
		-lpangoft2-1.0) ;;
		-lpangocairo-1.0) ;;
		-lcairo) ;;
		-lfontconfig) ;;
		-lfreetype) ;;
		*) x="$x $l";;
		esac
	done
	gtkldflags=$x
	;;
esac

case "$d_headless" in
"$undef") echo "Checking whether Gtk+ can be compiled against..." >&4
$cat >try.c <<EOC
#include <stdlib.h>
#include <glib.h>
#include <gtk/gtk.h>
int main(void)
{
  GtkWidget *window;
  gpointer p;

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  if (!window)
    return 1;
  p = g_malloc(23);
  if (!p)
    return 1;
  return 0;
}
EOC

if $cc -o try try.c $ccflags $ldflags $gtkcflags $gtkldflags  >/dev/null 2>&1;
then
  d_gtk="$define"
  echo "We'll be using Gtk+ version $version." >&4
else 
  ./warn "Cannot compile against Gtk+ version '$version'" 4>&4
fi
$rm -rf try try.*
;;
esac

: determine our version number
echo " "
echo "Figuring out my version number..." >&4
$cat > ver <<'EOC'
/^#define GTA_VERSION	/	{ major=$3 }
/^#define GTA_SUBVERSION/	{ minor=$3 }
/^#define GTA_PATCHLEVEL/	{ tiny=$3 }
/^#define GTA_REVCHAR/		{ rev=$3; gsub("[^a-zA-Z]", "", rev); }
END {
	if (tiny) {
		printf("%u.%u.%u%s", major, minor, tiny, rev);
	} else {
		printf("%u.%u%s", major, minor, rev);
	}
}
EOC
awkp=$awk
test -x $nawk && awkp=$nawk
gtkgversion=`$awkp -f ./ver "$rsrc/src/gtk-gnutella.h"`
echo "(You have version $gtkgversion.)"
$rm -f ver

: locate a BSD compatible install program
echo " "
echo "Looking for a BSD-compatible install program..." >&4
creatdir=''
case "$install" in
'')
	tryit=''
	for dir in $pth; do
		for file in ginstall installbsd scoinst install; do
			if $test -f $dir/$file; then
				tryit="$tryit $dir/$file"
			fi
		done
	done
	$cat >try.c <<EOC
int main()
{
	printf("OK\n");
	exit(0);
}
EOC
	if $cc -o try try.c >/dev/null 2>&1; then
		cp try try.ns
		strip try >/dev/null 2>&1
	else
		echo "(I can't seem to compile a trivial C program -- bypassing.)"
		echo "try" >try
		cp try try.ns
	fi
	$cat >tryinst <<EOS
$startsh
$rm -rf foo d
\$1 -d foo/bar
$mkdir d
\$1 -c -m 764 try.ns d
\$1 -c -s -m 642 try.ns d/try
EOS
	chmod +x tryinst
	$eunicefix tryinst
	dflt=''
	either=''
	for prog in $tryit; do
		$echo $n "Checking $prog... $c"
		./tryinst $prog >/dev/null 2>&1
		if $test -d foo/bar; then
			creatdir="$prog -d"
		fi
		(ls -l d/try >try.ls; ls -l d/try.ns >tryno.ls) 2>/dev/null
		try_wc=`($wc -c try | $awk '{ print $1}') 2>/dev/null`
		tryns_wc=`($wc -c try.ns | $awk '{ print $1}') 2>/dev/null`
		d_try_wc=`($wc -c d/try | $awk '{ print $1}') 2>/dev/null`
		d_tryns_wc=`($wc -c d/try.ns | $awk '{ print $1}') 2>/dev/null`
		if ($test "X$try_wc" = "X$d_try_wc" && \
			$test "X$tryns_wc" = "X$d_tryns_wc" && \
			$contains 'rwxrw-r--' tryno.ls && \
			$contains 'rw-r---w-' try.ls) >/dev/null 2>&1
		then
			dflt="$prog"
			echo "ok, that will do."
			break
		fi
		echo "not good$either."
		either=' either'
		$rm -f try*.ls
	done
	$rm -rf foo d tryinst try try*.ls try.*
	case "$dflt" in
	'')
		echo "Hopefully, $package comes with its own install script!"
		dflt='./install'
		;;
	esac
	;;
*) dflt="$install";;
esac
$cat <<EOM

I will be requiring a BSD-compatible install program (one that allows
options like -s to strip executables or -m to specify a file mode) to
install $package.

If the question below contains a fully qualified default path, then it
is probably ok. If it is an unqualified name such as 'install', then it
means I was unable to find out a good install program I could use. If
you know of one, please tell me about it. If the default is './install',
then I shall be using the install script supplied with $package.

EOM
fn='/fe~(install,./install)'
rp='Which install program shall I use?'
. ./getfile
install="$ans"

: how can we create nested directories?
echo " "
echo "Ok, let's see how we can create nested directories..." >&4
case "$installdir" in
'')
	$mkdir -p foo/bar >/dev/null 2>&1
	if $test -d foo/bar; then
		echo "Great, we can build them using 'mkdir -p'."
		creatdir='mkdir -p'
	else
		case "$creatdir" in
		'')
			if eval "$install -d foo/bar"; $test -d foo/bar; then
				creatdir="install -d"
				echo "It looks like '$creatdir' will do it for us."
			fi
			;;
		*)
			eval "$creatdir foo/bar" >/dev/null 2>&1
			if $test -d foo/bar; then
				echo "Ah! We can use '$creatdir' to do just that."
			else
				creatdir=''
			fi
			;;
		esac
	fi
	$rm -rf foo
	case "$creatdir" in
	'')
		echo "Heck! Another ancient system lacking the comfort of modern ones!"
		echo "You can thank $package for bringing you its own install script!"
		installdir='./install -d'
		;;
	*) installdir="$creatdir";;
	esac
	;;
*) echo "As you already told me, '$installdir' should work.";;
esac

: see what memory models we can support
case "$models" in
'')
	$cat >pdp11.c <<'EOP'
int main(void) {
#ifdef pdp11
	return 0;
#else
	return 1;
#endif
}
EOP
	case "$cc" in
	'') modelcc="$cc" ;;
	*) modelcc="cc" ;;
	esac
	( $modelcc -o pdp11 pdp11.c ) >/dev/null 2>&1
	if $test -f pdp11 && ./pdp11 2>/dev/null; then
		dflt='unsplit split'
	else
		tans=`./loc . X /lib/small /lib/large /usr/lib/small /usr/lib/large /lib/medium /usr/lib/medium /lib/huge`
		case "$tans" in
		X) dflt='none';;
		*) if $test -d /lib/small || $test -d /usr/lib/small; then
				dflt='small'
			else
				dflt=''
			fi
			if $test -d /lib/medium || $test -d /usr/lib/medium; then
				dflt="$dflt medium"
			fi
			if $test -d /lib/large || $test -d /usr/lib/large; then
				dflt="$dflt large"
			fi
			if $test -d /lib/huge || $test -d /usr/lib/huge; then
				dflt="$dflt huge"
			fi
		esac
	fi;;
*) dflt="$models";;
esac
$cat <<EOM
 
Some systems have different model sizes.  On most systems they are called
small, medium, large, and huge.  On the PDP11 they are called unsplit and
split.  If your system doesn't support different memory models, say "none".
If you wish to force everything to one memory model, say "none" here and
put the appropriate flags later when it asks you for other cc and ld flags.
Venix systems may wish to put "none" and let the compiler figure things out.
(In the following question multiple model names should be space separated.)

The default for most systems is "none".

EOM
rp="Which memory models are supported?"
. ./myread
models="$ans"

case "$models" in
none)
	small=''
	medium=''
	large=''
	huge=''
	unsplit=''
	split=''
	;;
*split)
	case "$split" in
	'') if $contains '\-i' $sysman/ld.1 >/dev/null 2>&1 || \
			 $contains '\-i' $sysman/cc.1 >/dev/null 2>&1; then
			dflt='-i'
		else
			dflt='none'
		fi;;
	*) dflt="$split";;
	esac
	rp="What flag indicates separate I and D space?"
	. ./myread
	tans="$ans"
	case "$tans" in
	none) tans='';;
	esac
	split="$tans"
	unsplit='';;
*large*|*small*|*medium*|*huge*)
	case "$models" in
	*large*)
		case "$large" in
		'') dflt='-Ml';;
		*) dflt="$large";;
		esac
	rp="What flag indicates large model?"
	. ./myread
	tans="$ans"
	case "$tans" in
	none) tans='';
	esac
	large="$tans";;
	*) large='';;
	esac
	case "$models" in
	*huge*) case "$huge" in
		'') dflt='-Mh';;
		*) dflt="$huge";;
		esac
		rp="What flag indicates huge model?"
		. ./myread
		tans="$ans"
		case "$tans" in
		none) tans='';
		esac
		huge="$tans";;
	*) huge="$large";;
	esac
	case "$models" in
	*medium*) case "$medium" in
		'') dflt='-Mm';;
		*) dflt="$medium";;
		esac
		rp="What flag indicates medium model?"
		. ./myread
		tans="$ans"
		case "$tans" in
		none) tans='';
		esac
		medium="$tans";;
	*) medium="$large";;
	esac
	case "$models" in
	*small*) case "$small" in
		'') dflt='none';;
		*) dflt="$small";;
		esac
		rp="What flag indicates small model?"
		. ./myread
		tans="$ans"
		case "$tans" in
		none) tans='';
		esac
		small="$tans";;
	*) small='';;
	esac
	;;
*)
	./warn "Unrecognized memory models--you may have to edit Makefile.SH" 4>&4
	;;
esac
$rm -f pdp11.* pdp11

: check whether make sets MAKE
echo " "
echo "Checking if your $make program sets \$(MAKE)..." >&4
case "$make_set_make" in
'')
	$sed 's/^X //' > testmake.mak << 'EOF'
Xall:
X 	@echo 'maketemp="$(MAKE)"'
EOF
	case "`$make -f testmake.mak 2>/dev/null`" in
	*maketemp=*) make_set_make='#' ;;
	*)	make_set_make="MAKE=$make" ;;
	esac
	$rm -f testmake.mak
	;;
esac
case "$make_set_make" in
'#') echo "Yup, it does.";;
*) echo "Nope, it doesn't.";;
esac

: find out how to generate dependencies
echo " "
echo "Checking how to generate makefile dependencies on your machine..." >&4
toplev=`cd ..;pwd`
$cat >dep.c <<'EOCP'
#include "dep.h"
EOCP
$cat >dep.h <<'EOCP'

EOCP
takeflags='flags=""
case "$@" in
*--*)
	for arg
	do
		shift
		case "$arg" in
		--) break;;
		*) flags="$flags $arg";;
		esac
	done;;
esac'
case "$mkdep" in
'')
	;;
*)
	if test -f "$mkdep" &&
		$mkdep dep.c >dep.out 2>/dev/null &&
		$contains "dep$_o:.*dep\.h" dep.out >/dev/null 2>&1
	then
		echo "$mkdep works."
		case "$mkdep" in
		"$pkgsrc/mkdep");;
		*)	echo "(copying it to $pkgsrc)"
			cp $mkdep $pkgsrc/mkdep 2>/dev/null
	   		if $pkgsrc/mkdep dep.c >dep.out 2>/dev/null &&
				$contains "dep$_o:.*dep\.h" dep.out >/dev/null 2>&1; then
				mkdep=$pkgsrc/mkdep
			else
				echo "Hmm... The copy failed or something... Guessing again..."
				mkdep=
			fi
			;;
		esac
	else
		mkdep=
	fi
esac

case "$mkdep" in
'')
	$spitshell > ../mkdep <<EOM
$startsh
$takeflags
for srcfile
do
	$cpp -M $cppflags \$flags \$srcfile 2>/dev/null
done
exit 0
EOM
	mkdep=$toplev/mkdep
	chmod +x $mkdep
	$eunicefix $mkdep
	if $mkdep dep.c >dep.out 2>/dev/null &&
		$contains "dep$_o:.*dep\.h" dep.out >/dev/null 2>&1
	then
		echo "Looks like we can use $cpp -M."
	else
		mkdep=
	fi
	;;
esac

case "$mkdep" in
'')
	$spitshell > ../mkdep <<EOM
$startsh
$takeflags
for srcfile
do
	$cc -MM $cppflags \$flags \$srcfile 2>/dev/null
done
exit 0
EOM
	mkdep=$toplev/mkdep
	chmod +x $mkdep
	$eunicefix $mkdep
	if $mkdep dep.c >dep.out 2>/dev/null &&
		$contains "dep$_o:.*dep\.h" dep.out >/dev/null 2>&1
	then
		echo "Looks like we can use $cc -MM."
	else
		mkdep=
	fi
	;;
esac

case "$mkdep" in
'')
	$spitshell >../mkdep <<EOS
$startsh
$takeflags
for srcfile
do
	case "\$srcfile" in
	*.c) c='.c';;
	*.y) c='.y';;
	*.l) c='.l';;
	esac
	filebase=\`basename \$srcfile \$c\`
	<\$srcfile $cpp $cppminus $cppflags \$flags 2>/dev/null | \\
	$sed -e '/^# *[0-9]/!d' \\
		-e 's/^.*"\(.*\)".*\$/'\$filebase'$_o: \1/' \\
		-e 's|: \./|: |' \\
		-e 's|: *$|: '\$srcfile'|' | \\
	$grep -v '^#' | $sort | $uniq
done
exit 0
EOS
	mkdep=$toplev/mkdep
	chmod +x $mkdep
	$eunicefix $mkdep
	if $mkdep dep.c >dep.out 2>/dev/null &&
		$contains "dep$_o:.*dep\.h" dep.out >/dev/null 2>&1
	then
		echo "A shell script using $cpp does the trick."
	else
		echo "$cpp doesn't seem to be any use at all."
		$spitshell >../mkdep <<EOS
$startsh
$takeflags
files="\$@"
set X \$flags
shift
inc='.'
while test \$# -gt 0
do
	case "\$1" in
	-I) 
		shift
		inc="\$inc:\$1"
		;;
	-I*)
		dir=\`echo \$1 | sed -e 's/^-I//'\`
		inc="\$inc:\$dir"
		;;
	esac
	shift
done
set X \$files
shift
tmpdir="${TMPDIR:-/tmp}"
trap "$rm -f "$tmpdir/mkdep\$\$"; exit 1" 1 2 3 15
for srcfile
do
	case "\$srcfile" in
	*.c) c='.c';;
	*.y) c='.y';;
	*.l) c='.l';;
	esac
	filebase=\`basename \$srcfile \$c\`
	echo \$filebase$_o: \$srcfile
	$grep '^#[  ]*include' \$srcfile /dev/null | \
	$sed -n -e 's/#[   ]*include[  ]*//' \\
		-e '/<\(.*\)>/ d' \\
		-e 's/:[^"]*"\([^"]*\)".*/: \1/' \\
		-e "s/\\.c:/$_o:/p" > "$tmpdir/mkdep\$\$"
	IFS=': '
	while read file dep; do
		for dir in \$inc; do
			if $test -f "\$dir/\$dep"; then
				dep="\$dir/\$dep"
				break
			fi
		done
		echo "\$file: \$dep" | $sed -e 's,: \./,: ,'
	done <"$tmpdir/mkdep\$\$"
	IFS=' '
	$rm -f "$tmpdir/mkdep\$\$" 
done
exit 0
EOS
		mkdep=$toplev/mkdep
		chmod +x $mkdep
		$eunicefix $mkdep
		if $mkdep dep.c >dep.out 2>/dev/null &&
			$contains "dep$_o:.*dep\.h" dep.out >/dev/null 2>&1
		then
			cat << EOM

I can use a script with grep instead, but it will make some incorrect
dependencies, since it doesn't understand about conditional compilation.
Moreover, some dependencies may be missing, because scanning won't be
a recursive process.
If you have a program which generates makefile dependencies, you may want
to use it.  If not, you can use the script and edit the Makefile by hand
if you need to.
EOM
		else
			mkdep=
			cat << EOM

I can't seem to generate makefile dependencies at all!  Perhaps you have a
program that does?  If you don't, you might look at the mkdep script to
see if you can create one which works.
EOM
		fi
	fi
esac
echo " "
dflt="$mkdep"
fn=f~/
rp="Name of program to make makefile dependencies?"
. ./getfile
mkdep="$ans"
$rm -f dep.c dep.h dep$_o dep.out

: check whether msgmerge supports --update
echo " "
echo "Let's see whether your $msgmerge supports the --update flag..." >&4
$msgmerge --help | $grep -- --update >msghelp
if $contains update msghelp >/dev/null 2>&1; then
	echo "Good, it does."
	msgmerge_update="$msgmerge --update"
else
	echo "Sorry, it does not: we'll try to do without it."
	msgmerge_update=":"
fi
$rm -f msghelp

: Cruising for prototypes
echo " "
$echo $n "Does the C compiler support function prototypes? $c" >&4
$cat >try.c <<'EOCP'
int main(int argc, char *argv[]) { (void) argc; (void) argv; return 0; }
EOCP

set prototype
eval $trylink

case "$prototype" in
"$define")	echo 'Yes.' >&4;;
*)		echo 'No.' >&4;;
esac

: see if ar generates random libraries by itself
echo " "
echo "Checking how to generate random libraries on your machine..." >&4
echo 'int bar1() { return bar2(); }' > bar1.c
echo 'int bar2() { return 2; }' > bar2.c
$cat > foo.c <<'EOP'
int main() { printf("%d\n", bar1()); return 0; }
EOP
$cc $ccflags -c bar1.c >/dev/null 2>&1
$cc $ccflags -c bar2.c >/dev/null 2>&1
$cc $ccflags -c foo.c >/dev/null 2>&1
$ar rc bar$_a bar2$_o bar1$_o >/dev/null 2>&1
if $cc $ccflags $ldflags -o foobar foo$_o bar$_a $libs > /dev/null 2>&1 &&
	./foobar >/dev/null 2>&1; then
	echo "ar appears to generate random libraries itself."
	orderlib=false
	ranlib=":"
elif $ar ts bar$_a >/dev/null 2>&1 &&
	$cc $ccflags $ldflags -o foobar foo$_o bar$_a $libs > /dev/null 2>&1 &&
	./foobar >/dev/null 2>&1; then
		echo "a table of contents needs to be added with 'ar ts'."
		orderlib=false
		ranlib="$ar ts"
else
	case "$ranlib" in
	:) ranlib='';;
	'')
		ranlib=`./loc ranlib X /usr/bin /bin /usr/local/bin`
		$test -f $ranlib || ranlib=''
		;;
	esac
	if $test -n "$ranlib"; then
		echo "your system has '$ranlib'; we'll use that."
		orderlib=false
	else
		echo "your system doesn't seem to support random libraries"
		echo "so we'll use lorder and tsort to order the libraries."
		orderlib=true
		ranlib=":"
	fi
fi
$rm -f foo* bar* 

: Trace out the files included by signal.h, then look for SIGxxx names.
if [ "X$fieldn" = X ]; then
	: Just make some guesses.  We check them later.
	xxx='/usr/include/signal.h /usr/include/sys/signal.h'
else
	xxx=`echo '#include <signal.h>' |
	$cppstdin $cppminus $cppflags 2>/dev/null |
	$grep '^[ 	]*#.*include' | 
	$awk "{print \\$$fieldn}" | $sed 's!"!!g' | \
		$sed 's!\\\\\\\\!/!g' | $sort | $uniq`
fi
xxxfiles=''
for xx in $xxx /dev/null ; do
	$test -f "$xx" && xxxfiles="$xxxfiles $xx"
done
case "$xxxfiles" in
'')	xxxfiles=`./findhdr signal.h` ;;
esac
xxx=`awk '
$1 ~ /^#define$/ && $2 ~ /^SIG[A-Z0-9]*$/ && $2 !~ /SIGARRAYSIZE/ && $2 !~ /SIGSTKSIZE/ && $2 !~ /SIGSTKSZ/ && $3 !~ /void/ {
	print substr($2, 4, 20)
}
$1 == "#" && $2 ~ /^define$/ && $3 ~ /^SIG[A-Z0-9]*$/ && $3 !~ /SIGARRAYSIZE/ && $4 !~ /void/ {
	print substr($3, 4, 20)
}' $xxxfiles`
: Append some common names just in case the awk scan failed.
xxx="$xxx ABRT ALRM BUS CANCEL CHLD CLD CONT DIL EMT FPE"
xxx="$xxx FREEZE HUP ILL INT IO IOT KILL LOST LWP PHONE"
xxx="$xxx PIPE POLL PROF PWR QUIT RTMAX RTMIN SEGV STKFLT STOP"
xxx="$xxx SYS TERM THAW TRAP TSTP TTIN TTOU URG USR1 USR2"
xxx="$xxx USR3 USR4 VTALRM WAITING WINCH WIND WINDOW XCPU XFSZ"

: generate a few handy files for later
$cat > signal.c <<'EOCP'
#include <sys/types.h>
#include <signal.h>
#include <stdio.h>
int main() {

/* Strange style to avoid deeply-nested #if/#else/#endif */
#ifndef NSIG
#  ifdef _NSIG
#    define NSIG (_NSIG)
#  endif
#endif

#ifndef NSIG
#  ifdef SIGMAX
#    define NSIG (SIGMAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef SIG_MAX
#    define NSIG (SIG_MAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef MAXSIG
#    define NSIG (MAXSIG+1)
#  endif
#endif

#ifndef NSIG
#  ifdef MAX_SIG
#    define NSIG (MAX_SIG+1)
#  endif
#endif

#ifndef NSIG
#  ifdef SIGARRAYSIZE
#    define NSIG (SIGARRAYSIZE+1) /* Not sure of the +1 */
#  endif
#endif

#ifndef NSIG
#  ifdef _sys_nsig
#    define NSIG (_sys_nsig) /* Solaris 2.5 */
#  endif
#endif

/* Default to some arbitrary number that's big enough to get most
   of the common signals.
*/
#ifndef NSIG
#    define NSIG 50
#endif

printf("NSIG %d\n", NSIG);

#ifndef JUST_NSIG

EOCP

echo $xxx | $tr ' ' $trnl | $sort | $uniq | $awk '
{
	printf "#ifdef SIG"; printf $1; printf "\n"
	printf "printf(\""; printf $1; printf " %%d\\n\",SIG";
	printf $1; printf ");\n"
	printf "#endif\n"
}
END {
	printf "#endif /* JUST_NSIG */\n";
	printf "return 0;\n}\n";
}
' >>signal.c
$cat >signal.awk <<'EOP'
BEGIN { ndups = 0 }
$1 ~ /^NSIG$/ { nsig = $2 }
($1 !~ /^NSIG$/) && (NF == 2) {
    if ($2 > maxsig) { maxsig = $2 }
    if (sig_name[$2]) {
	dup_name[ndups] = $1
	dup_num[ndups] = $2
	ndups++ 
    }
    else {
	sig_name[$2] = $1
	sig_num[$2] = $2
    }
}
END { 
    if (nsig == 0) {
    	nsig = maxsig + 1
    }
    printf("NSIG %d\n", nsig);
    for (n = 1; n < nsig; n++) {
 	if (sig_name[n]) {
 	    printf("%s %d\n", sig_name[n], sig_num[n])
	}
 	else {
 	    printf("NUM%d %d\n", n, n) 
 	}
    }
    for (n = 0; n < ndups; n++) {
 	printf("%s %d\n", dup_name[n], dup_num[n])
    }
}
EOP
$cat >signal_cmd <<EOS
$startsh
if $test -s signal.lst; then
    echo "Using your existing signal.lst file"
	exit 0
fi
xxx="$xxx"
EOS
$cat >>signal_cmd <<'EOS'

set signal
if eval $compile_ok; then
	$run ./signal$_exe | ($sort -n -k 2 2>/dev/null || $sort -n +1) | \
		$uniq | $awk -f signal.awk >signal.lst
else
	echo "(I can't seem be able to compile the whole test program)" >&4
	echo "(I'll try it in little pieces.)" >&4
	set signal -DJUST_NSIG
	if eval $compile_ok; then
		$run ./signal$_exe > signal.nsg
		$cat signal.nsg
	else
		echo "I can't seem to figure out how many signals you have." >&4
		echo "Guessing 50." >&4
		echo 'NSIG 50' > signal.nsg
	fi
	: Now look at all the signal names, one at a time.
	for xx in `echo $xxx | $tr ' ' $trnl | $sort | $uniq`; do
		$cat > signal.c <<EOCP
#include <sys/types.h>
#include <signal.h>
#include <stdio.h>
int main() {
printf("$xx %d\n", SIG${xx});
return 0;
}
EOCP
		set signal
		if eval $compile; then
			echo "SIG${xx} found."
			$run ./signal$_exe  >> signal.ls1
		else
			echo "SIG${xx} NOT found."
		fi
	done
	if $test -s signal.ls1; then
		$cat signal.nsg signal.ls1 |
			$sort -n | $uniq | $awk -f signal.awk >signal.lst
	fi

fi
if $test -s signal.lst; then
	:
else
	echo "(AAK! I can't compile the test programs -- Guessing)" >&4
	echo 'kill -l' >signal
	set X `csh -f <signal`
	$rm -f signal
	shift
	case $# in
	0) set HUP INT QUIT ILL TRAP ABRT EMT FPE KILL BUS SEGV SYS PIPE ALRM TERM;;
	esac
	echo $@ | $tr ' ' $trnl | \
 	    $awk '{ printf "%s %d\n", $1, ++s; }
 		  END { printf "NSIG %d\n", ++s }' >signal.lst
fi
$rm -f signal.c signal$_exe signal$_o signal.nsg signal.ls1
EOS
chmod a+x signal_cmd
$eunicefix signal_cmd

: generate list of signal names
echo " "
case "$sig_name_init" in
'') doinit=yes ;;
*)  case "$sig_num_init" in
    ''|*,*) doinit=yes ;;
    esac ;;
esac
case "$doinit" in
yes)
	echo "Generating a list of signal names and numbers..." >&4
	. ./signal_cmd
 	sig_count=`$awk '/^NSIG/ { printf "%d", $2 }' signal.lst`
 	sig_name=`$awk 'BEGIN { printf "ZERO " }
 			!/^NSIG/ { printf "%s ", $1 }' signal.lst`
 	sig_num=`$awk  'BEGIN { printf "0 " }
 			!/^NSIG/ { printf "%d ", $2 }' signal.lst`
 	sig_name_init=`$awk 'BEGIN	{ printf "\"ZERO\", " }
 			     !/^NSIG/	{ printf "\"%s\", ", $1 }
 			     END	{ printf "0\n" }' signal.lst`
 	sig_num_init=`$awk  'BEGIN	{ printf "0, " }
 			     !/^NSIG/	{ printf "%d, ", $2}
 			     END	{ printf "0\n"}' signal.lst`
	;;
esac
echo "The following $sig_count signals are available:"
echo " "
echo $sig_name | $awk \
'BEGIN { linelen = 0 }
{
	for (i = 1; i <= NF; i++) {
		name = "SIG" $i " "
		linelen = linelen + length(name)
		if (linelen > 70) {
			printf "\n"
			linelen = length(name)
		}
		printf "%s", name
	}
	printf "\n"
}'
sig_size=`echo $sig_name | awk '{print NF}'`
$rm -f signal signal.c signal.awk signal.lst signal_cmd 

: see if difftime exists
$cat >try.c <<EOC
#include <time.h>
int main(void)
{
	static double ret;
	static time_t t0, t1;
	ret = difftime(t1, t0) * 1.0;
	return ret ? 0 : 1;
}
EOC
cyn=difftime
set d_difftime
eval $trylink

: see whether difftime should be used
case "$d_difftime" in
"$define")
	$cat >try.c <<EOC
#include "static_assert.h"
#include <time.h>
int main(void)
{
	STATIC_ASSERT((time_t) -1 < 0);
	return 0;
}
EOC
	cyn="whether difftime() can be avoided"
	set avoid_difftime
	eval $trylink
	;;
*) avoid_difftime="$define";;
esac
case "$avoid_difftime" in
"$define") val="$undef";;
*) val="$define";;
esac
set use_difftime
eval $setvar

: check for void type
echo " "
echo "Checking to see how well your C compiler groks the void type..." >&4
$cat >flags <<EOM

  Support flag bits are:
    1: basic void declarations.
    2: arrays of pointers to functions returning void.
    4: operations between pointers to and addresses of void functions.
    8: generic void pointers.

EOM
case "$voidflags" in
'')
	$cat >try.c <<'EOCP'
extern int doit();
#if TRY & 1
void sub() {
#else
sub() {
#endif
	extern void moo();	/* function returning void */
	void (*goo)();		/* ptr to func returning void */
#if TRY & 2
	static void (*foo[10])();
#endif
#if TRY & 8
	void *hue;			/* generic ptr */
	char buf[] = "buf";
	int *iptr;
#endif

#if TRY & 2
	if (doit()) {
		foo[0] = moo;
		(*foo[0])();
	}
#endif
#if TRY & 4
	if (doit())
		goo = moo;
	if (goo == moo)
		doit();
#endif
#if TRY & 8
	hue = buf;
	if (doit())
		iptr = hue;
	(void) iptr;
#endif
	doit();
}
EOCP
	if $cc $ccflags -c -DTRY=$defvoidused try.c >.out 2>&1 ; then
		voidflags=$defvoidused
		echo "Good.  It appears to support void to the level $package wants."
		if $contains warning .out >/dev/null 2>&1; then
			echo "However, you might get some warnings that look like this:"
			$sed -e 's/^/	/' .out
		fi
	else
echo "Hmm, your compiler has some difficulty with void. Checking further..." >&4
		$cat >&4 flags
		$rm -f flags
		if $cc $ccflags -c -DTRY=1 try.c >/dev/null 2>&1; then
			echo "It supports 1..."
			if $cc $ccflags -c -DTRY=3 try.c >/dev/null 2>&1; then
				echo "It also supports 2..."
				if $cc $ccflags -c -DTRY=7 try.c >/dev/null 2>&1; then
					voidflags=7
					echo "And it supports 4 but not 8 definitely."
				else
					echo "It doesn't support 4..."
					if $cc $ccflags -c -DTRY=11 try.c >/dev/null 2>&1; then
						voidflags=11
						echo "But it supports 8."
					else
						voidflags=3
						echo "Neither does it support 8."
					fi
				fi
			else
				echo "It does not support 2..."
				if $cc $ccflags -c -DTRY=13 try.c >/dev/null 2>&1; then
					voidflags=13
					echo "But it supports 4 and 8."
				else
					if $cc $ccflags -c -DTRY=5 try.c >/dev/null 2>&1; then
						voidflags=5
						echo "And it supports 4 but has not heard about 8."
					else
						echo "However it supports 8 but not 4."
					fi
				fi
			fi
		else
			echo "There is no support at all for void."
			voidflags=0
		fi
	fi
esac
case "$voidflags" in
"$defvoidused") ;;
*)
	dflt="$voidflags";
	test -f flags && $cat flags
	rp="Your void support flags add up to what?"
	. ./myread
	voidflags="$ans"
	;;
esac
$rm_try flags

: determine compiler compiler
echo " "
comp='yacc'
if $test -f "$byacc"; then
	comp="byacc or $comp"
fi
if $test -f "$bison"; then
	comp="$comp or bison -y"
fi
case "$yacc" in
'')
	yacc=`./loc yacc yacc $pth`
	if $test -f "$yacc"; then
		dflt='yacc'
	elif $test -f "$byacc"; then
		dflt='byacc'
	elif $test -f "$bison"; then
		dflt='bison'
	else
		dflt=''
	fi
	;;
*) dflt="$yacc";;
esac
rp="Which compiler compiler ($comp) shall I use?"
. ./myread
yacc="$ans"
case "$yacc" in
*bis*)
	case "$yacc" in
	*-y*) ;;
	*)
		yacc="$yacc -y"
		echo "(Adding -y option to bison to get yacc-compatible behaviour.)"
		;;
	esac
	;;
esac

: see if we need extra yacc flags
dflt="$yaccflags"
case "$dflt" in
'') dflt=none;;
esac
$cat <<EOH

Your yacc program may need extra flags to normally process the parser sources.
Do NOT specify any -d or -v flags here, since those are explicitly known
by the various Makefiles. However, if your machine has strange/undocumented
options (like -Sr# on SCO to specify the maximum number of grammar rules), then
please add them here.  To use no flags, specify the word "none".

EOH
rp="Any additional yacc flags?"
. ./myread
case "$ans" in
none) yaccflags='';;
*) yaccflags="$ans";;
esac

: see if alloca.h is available
$cat >try.c <<EOC
#include <alloca.h>
int main(void)
{
	void *ret = alloca(1);
	return (unsigned long) ret & 0x1;
}
EOC
set i_alloca
eval $trylink

: see if fcntl.h is there
val=''
set fcntl.h val
eval $inhdr

: see if we can include fcntl.h
case "$val" in
"$define")
	echo " "
	if $h_fcntl; then
		val="$define"
		echo "We'll be including <fcntl.h>." >&4
	else
		val="$undef"
		if $h_sysfile; then
	echo "We don't need to include <fcntl.h> if we include <sys/file.h>." >&4
		else
			echo "We won't be including <fcntl.h>." >&4
		fi
	fi
	;;
*)
	h_fcntl=false
	val="$undef"
	;;
esac
set i_fcntl
eval $setvar

: see if this is a ifaddrs.h system
set ifaddrs.h i_ifaddrs
eval $inhdr

: see if this is a invent.h system
set invent.h i_invent
eval $inhdr

: see if this is a langinfo system
set langinfo.h i_langinfo
eval $inhdr

: see if this is a linux/netlink.h system
set linux/netlink.h i_linux_netlink
eval $inhdr

: see if this is a linux/rtnetlink.h system
set linux/rtnetlink.h i_linux_rtnetlink
eval $inhdr

: see if this is a net/route.h system
set net/route.h i_netroute
eval $inhdr

: see if this is a pthread.h system
set pthread.h i_pthread
eval $inhdr

: see if this is a pwd.h system
set pwd.h i_pwd
eval $inhdr

case "$i_pwd" in
$define)
	xxx=`./findhdr pwd.h`
	$cppstdin $cppflags $cppminus < $xxx >$$.h

	if $contains 'pw_quota' $$.h >/dev/null 2>&1; then
		val="$define"
	else
		val="$undef"
	fi
	set d_pwquota
	eval $setvar

	if $contains 'pw_age' $$.h >/dev/null 2>&1; then
		val="$define"
	else
		val="$undef"
	fi
	set d_pwage
	eval $setvar

	if $contains 'pw_change' $$.h >/dev/null 2>&1; then
		val="$define"
	else
		val="$undef"
	fi
	set d_pwchange
	eval $setvar

	if $contains 'pw_class' $$.h >/dev/null 2>&1; then
		val="$define"
	else
		val="$undef"
	fi
	set d_pwclass
	eval $setvar

	if $contains 'pw_expire' $$.h >/dev/null 2>&1; then
		val="$define"
	else
		val="$undef"
	fi
	set d_pwexpire
	eval $setvar

	if $contains 'pw_comment' $$.h >/dev/null 2>&1; then
		val="$define"
	else
		val="$undef"
	fi
	set d_pwcomment
	eval $setvar

	$rm -f $$.h
	;;
*)
	val="$undef"; 
	set d_pwquota; eval $setvar
	set d_pwage; eval $setvar
	set d_pwchange; eval $setvar
	set d_pwclass; eval $setvar
	set d_pwexpire; eval $setvar
	set d_pwcomment; eval $setvar
	;;
esac

: see if regex is available
set regex.h i_regex
eval $inhdr

: see if this is a sched.h system
set sched.h i_sched
eval $inhdr

: see if stdarg is available
echo " "
if $test `./findhdr stdarg.h`; then
	echo "<stdarg.h> found." >&4
	valstd="$define"
else
	echo "<stdarg.h> NOT found." >&4
	valstd="$undef"
fi

: see if varags is available
echo " "
if $test `./findhdr varargs.h`; then
	echo "<varargs.h> found." >&4
else
	echo "<varargs.h> NOT found, but that's ok (I hope)." >&4
fi

: set up the varargs testing programs
$cat > varargs.c <<EOP
#ifdef I_STDARG
#include <stdarg.h>
#endif
#ifdef I_VARARGS
#include <varargs.h>
#endif

#ifdef I_STDARG
int f(char *p, ...)
#else
int f(va_alist)
va_dcl
#endif
{
	va_list ap;
#ifndef I_STDARG
	char *p;
#endif
#ifdef I_STDARG
	va_start(ap,p);
#else
	va_start(ap);
	p = va_arg(ap, char *);
#endif
	va_end(ap);
	return 0;
}
EOP
$cat > varargs <<EOP
$startsh
if $cc -c $ccflags -D\$1 varargs.c; then
	echo "true"
else
	echo "false"
fi
$rm -f varargs$_o
EOP
chmod +x varargs

: now check which varargs header should be included
echo " "
i_varhdr=''
case "$valstd" in
"$define")
	if `./varargs I_STDARG`; then
		val='stdarg.h'
	elif `./varargs I_VARARGS`; then
		val='varargs.h'
	fi
	;;
*)
	if `./varargs I_VARARGS`; then
		val='varargs.h'
	fi
	;;
esac
case "$val" in
'')
	./warn "I could not find the definition for va_dcl... You have problems..." 4>&4
	val="$undef"; set i_stdarg; eval $setvar
	val="$undef"; set i_varargs; eval $setvar
	;;
*) 
	set i_varhdr
	eval $setvar
	case "$i_varhdr" in
	stdarg.h)
		val="$define"; set i_stdarg; eval $setvar
		val="$undef"; set i_varargs; eval $setvar
		;;
	varargs.h)
		val="$undef"; set i_stdarg; eval $setvar
		val="$define"; set i_varargs; eval $setvar
		;;
	esac
	echo "We'll include <$i_varhdr> to get va_dcl definition." >&4;;
esac
$rm -f varargs*

: see if this is a sys/ipc system
set sys/ipc.h i_sysipc
eval $inhdr

: see if this is a sys/sem system
set sys/sem.h i_syssem
eval $inhdr

: see if this is a sys/sendfile system
set sys/sendfile.h i_syssendfile
eval $inhdr

: see if this is a sys/statvfs system
set sys/statvfs.h i_sysstatvfs
eval $inhdr

: see if this is a sys/sysctl system
set sys/sysctl.h i_syssysctl
eval $inhdr

: see if this is a sys/utsname system
set sys/utsname.h i_sysutsname
eval $inhdr

: see if this is a iconv.h system
set iconv.h i_iconv
eval $inhdr

: see whether we can omit the frame pointer
needframe=
case "$gccversion" in
'') ;;
*)
	echo " "
	needframe=y
	case "$d_backtrace" in
	"$define") needframe=n;;
	esac
	$cat >try.c <<'EOC'
int main()
{
	return 0;
}
EOC
	;;
esac
case "$needframe" in
n)
	if
		$cc $ccflags -momit-leaf-frame-pointer $ldflags \
			-o try try.c >/dev/null 2>&1
	then
		case "$ccflags $optimize" in
		*-momit-leaf-frame-pointer*) ;;
		*-O0*) ;;
		*-O*)
			ccflags="-momit-leaf-frame-pointer $ccflags"
			echo "Added -momit-leaf-frame-pointer to the cc flags." >&4
			;;
		esac
	else
		case "$ccflags" in
		*-momit-leaf-frame-pointer*)
			echo "Stripping -momit-leaf-frame-pointer from cc flags." >&4
			ccflags=`echo $ccflags | $sed 's/ *-momit-leaf-frame-pointer//'`
		;;
		esac
	fi
	;;
y)
	if
		$cc $ccflags -fno-omit-frame-pointer $ldflags \
			-o try try.c >/dev/null 2>&1
	then
		case "$ccflags" in
		*-fno-omit-frame-pointer*) ;;
		*)
			ccflags="-fno-omit-frame-pointer $ccflags"
			echo "Added -fno-omit-frame-pointer to the cc flags." >&4
			;;
		esac
	else
		case "$ccflags" in
		*-fno-omit-frame-pointer*)
			echo "Stripping -fno-omit-frame-pointer from cc flags." >&4
			ccflags=`echo $ccflags | $sed 's/ *-fno-omit-frame-pointer//'`
		;;
		esac
	fi
	;;
esac
$rm -f try try.c

: see if deflate exists
$cat >try.c <<EOC
#include <zlib.h>
int main(void)
{
	static int ret, flush;
	static z_stream zs;
	flush |= Z_FULL_FLUSH;
	flush |= Z_SYNC_FLUSH;
	flush |= Z_FINISH;
	ret |= deflate(&zs, flush);
	return ret ? 0 : 1;
}
EOC
cyn=deflate
set d_deflate '-lz'
eval $trylink

: see if inflate exists
$cat >try.c <<EOC
#include <zlib.h>
int main(void)
{
	static int ret, flush;
	static z_stream zs;
	flush |= Z_SYNC_FLUSH;
	flush |= Z_FULL_FLUSH;
	flush |= Z_FINISH;
	ret |= inflate(&zs, flush);
	return ret ? 0 : 1;
}
EOC
cyn=inflate
set d_inflate '-lz'
eval $trylink

: see if this is a zlib.h system
set zlib.h i_zlib
eval $inhdr

: determine whether sendfile works with 64-bit file support
$cat >try.c <<EOC
#$i_syssendfile I_SYS_SENDFILE
#ifdef I_SYS_SENDFILE
#include <sys/sendfile.h>
#endif
int main(void)
{
	return 0;
}
EOC
cyn="whether sendfile() works with current compiling flags"
result=''
set result
eval $trylink
case "$result" in
"$undef")
	i_syssendfile="$undef"
	d_sendfile="$undef"
	;;
esac

: see if iconv exists
$cat >try.c <<EOC
#include <sys/types.h>
#$i_iconv I_ICONV
#ifdef I_ICONV
#include <iconv.h>
#endif
int main(void)
{
	static size_t n, srcleft, dstleft;
	static char *src, *dst;
	static int ret;
	iconv_t cd;
	cd = iconv_open("ISO8859-1", "UTF-8");
	n |= iconv(cd, (void *) &src, &srcleft, (void *) &dst, &dstleft);
	ret |= iconv_close(cd);
	return 0 != ret;
}
EOC
cyn=iconv
set d_iconv '-liconv'
eval $trylink

: check whether -mieee should be used
flag='-mieee'
case "$gccversion" in
'');;
*)
	$cat >try.c <<EOC
int main(void)
{
#if !(defined(__GNUC__) && (defined(_alpha) || defined(__alpha__)))
	switch (sizeof(int[-23])) { case 1: case 1: }
#endif
	return 0;
}
EOC
	saved_ccflags=$ccflags
	ccflags="$flag $ccflags"
	cyn="whether '$flag' should be used" >&4
	result=''
	set result
	eval $trylink
	case "$result" in
	"$define") ;;
	*) ccflags=$saved_ccflags;;
	esac
	;;
esac

: check whether -pipe should be used
flag='-pipe'
case "$gccversion" in
'');;
*)
	case "$ccflags $optimize" in
	*-save-temps*);;
	*-pipe*);;
	*)
		$cat >try.c <<'EOC'
int main(void)
{
	return 0;
}
EOC
		saved_ccflags=$ccflags
		ccflags="$flag $ccflags"

		result=''
		cyn="whether '$flag' is accepted by $cc" >&4
		set result
		eval $trylink
	
		case "$result" in
		"$define")
			$cat >try.c <<EOC
main("This is not C")
{
	(. || 
	switch (**1) { case 1: case 1: }
}
EOC
			result=''
			set result
			eval $trylink
	
			case "$result" in
			"$define")
				echo "However with $flag the compiler seems to see no code." >&4
				ccflags=$saved_ccflags
				;;
			esac
			;;
		*) ccflags=$saved_ccflags;;
		esac
		;;
	esac
	;;
esac

: end of configuration questions
echo " "
echo "End of configuration questions."

glib_used=glib-${glibversion}.x
frontend="GTK1"
case "$gtkversion" in
2) frontend="GTK2";;
esac

case "$d_headless" in
"$define") frontend="none";;
esac

dbus=no
case "$d_dbus" in
"$define") dbus=yes;;
esac

zlib=no
case "$i_zlib$d_deflate$d_inflate" in
"$define$define$define") zlib=yes;;
esac

gnutls=no
case "$d_gnutls" in
"$define") gnutls=yes;;
esac

remote=no
case "$d_remotectrl" in
"$define") remote=yes;;
esac

nls=no
case "$d_enablenls" in
"$define") nls=yes;;
esac

iconv=no
case "$d_iconv" in
"$define") iconv=yes;;
esac

which apt-get >/dev/null 2>&1 && aptget=echo || aptget=:
which yum >/dev/null 2>&1 && yum=echo || yum=:

$cat >&4 <<EOM

Feature Summary (Version $gtkgversion):
-------------------------------------------------
GLib version                       : $glib_used
GUI front-end                      : $frontend
GnuTLS support                     : $gnutls
NLS (Native Language Support)      : $nls
DBus support (experimental)        : $dbus
Remote Shell Interface (deprecated): $remote
-------------------------------------------------
EOM

bailout=no

case "$d_glib" in
"$undef")
	bailout=yes
	echo 'ERROR: Cannot compile against GLib. Library or header files might be missing.' >&4
	case "$glibversion" in
	1) $aptget 'ADVICE: Run "apt-get install libglib1.2-dev".' >&4
	   $yum 'ADVICE: Run "yum install glib-devel".' >&4
	;;
	2) $aptget 'ADVICE: Run "apt-get install libglib2.0-dev".' >&4
	   $yum 'ADVICE: Run "yum install glib2-devel".' >&4
	;;
	esac
	;;
esac

if [ "$zlib" != yes ]; then
	bailout=yes
	echo 'ERROR: Cannot compile against zlib. Library or header files might be missing.' >&4
	$aptget 'ADVICE: Run "apt-get install zlib1g-dev".' >&4
	$yum 'ADVICE: Run "yum install zlib-devel".' >&4
fi

if [ "$iconv" != yes ]; then
	bailout=yes
	echo 'ERROR: Cannot find iconv(). Library or header files might be missing.' >&4
fi

if [ "$frontend" != none ]; then
case "$d_gtk" in
"$undef")
	bailout=yes
	echo 'ERROR: Cannot compile against Gtk+. Library or header files might be missing.' >&4
	case "$gtkversion" in
	1) $aptget 'ADVICE: Run "apt-get install libgtk1.2-dev".' >&4
	   $yum 'ADVICE: Run "yum install gtk-devel".' >&4
	;;
	2) $aptget 'ADVICE: Run "apt-get install libgtk2.0-dev".' >&4
	   $yum 'ADVICE: Run "yum install gtk2-devel".' >&4
	;;
	esac
	;;
esac
fi

if [ "$bailout" != no ]; then
	cat >&4 <<EOM
If you need help to resolve the compile problem, please send a mail to

	gtk-gnutella-devel (at) lists.sourceforge.net

or submit a bug report here:

	http://sourceforge.net/tracker/?atid=104467&group_id=4467&func=browse

You might also want to have a look at the README files in advance.
EOM

	exit 1
fi

: back to where it started
if test -d ../UU; then
	cd ..
fi

: configuration may be unconditionally patched via a 'config.arch' file
if $test -f config.arch; then
	echo "I see a config.arch file, loading it." >&4
	. ./config.arch
fi

: configuration may be patched via a 'config.over' file
if $test -f config.over; then
	echo " "
	dflt=y
	rp='I see a config.over file.  Do you wish to load it?'
	. UU/myread
	case "$ans" in
	n*) echo "OK, I'll ignore it.";;
	*)	. ./config.over
		echo "Configuration override changes have been loaded."
		;;
	esac
fi

: in case they want portability, strip down executable paths
case "$d_portable" in
"$define")
	echo " "
	echo "Stripping down executable paths..." >&4
	xsed=$sed
	for file in $loclist $trylist; do
		eval sfile="\$$file"
		sfile=`echo $sfile | $xsed -e 's,.*/\(.*\),\1,'`
		eval $file="$sfile"
	done
	;;
esac

: create config.sh file
echo " "
echo "Creating config.sh..." >&4
$spitshell <<EOT >config.sh
$startsh
#
# This file was produced by running the Configure script. It holds all the
# definitions figured out by Configure. Should you modify one of these values,
# do not forget to propagate your changes by running "Configure -der". You may
# instead choose to run each of the .SH files by yourself, or "Configure -S".
#

# Package name      : $package
# Source directory  : $src
# Configuration time: $cf_time
# Configured by     : $cf_by
# Target system     : $myuname

EOT
$test -f UU/cmdline.opt && $cat UU/cmdline.opt >> config.sh
$spitshell <<EOT >>config.sh

Author='$Author'
Date='$Date'
Header='$Header'
Id='$Id'
Locker='$Locker'
Log='$Log'
RCSfile='$RCSfile'
Revision='$Revision'
Source='$Source'
State='$State'
_a='$_a'
_exe='$_exe'
_o='$_o'
afs='$afs'
afsroot='$afsroot'
alignbytes='$alignbytes'
aphostname='$aphostname'
ar='$ar'
archlib='$archlib'
archlibexp='$archlibexp'
archname='$archname'
archobjs='$archobjs'
awk='$awk'
bash='$bash'
bin='$bin'
binexp='$binexp'
bison='$bison'
byacc='$byacc'
byteorder='$byteorder'
c='$c'
cat='$cat'
cc='$cc'
ccflags='$ccflags'
ccname='$ccname'
ccversion='$ccversion'
cf_by='$cf_by'
cf_time='$cf_time'
charsize='$charsize'
chgrp='$chgrp'
chmod='$chmod'
chown='$chown'
clocktype='$clocktype'
comm='$comm'
compress='$compress'
contains='$contains'
cp='$cp'
cpio='$cpio'
cpp='$cpp'
cpp_quote='$cpp_quote'
cpp_stuff='$cpp_stuff'
cppfilter='$cppfilter'
cppflags='$cppflags'
cpplast='$cpplast'
cppminus='$cppminus'
cpprun='$cpprun'
cppstdin='$cppstdin'
csh='$csh'
d_access='$d_access'
d_alarm='$d_alarm'
d_arc4random='$d_arc4random'
d_archlib='$d_archlib'
d_attribut='$d_attribut'
d_backtrace='$d_backtrace'
d_bcmp='$d_bcmp'
d_bcopy='$d_bcopy'
d_bfd_lib='$d_bfd_lib'
d_bfd_section='$d_bfd_section'
d_bindtxtcode='$d_bindtxtcode'
d_bsd='$d_bsd'
d_bsearch='$d_bsearch'
d_built_bswap32='$d_built_bswap32'
d_built_bswap64='$d_built_bswap64'
d_built_clz='$d_built_clz'
d_built_ctz='$d_built_ctz'
d_built_popcount='$d_built_popcount'
d_bzero='$d_bzero'
d_can64='$d_can64'
d_clearenv='$d_clearenv'
d_clock_getres='$d_clock_getres'
d_clock_gettime='$d_clock_gettime'
d_closefrom='$d_closefrom'
d_const='$d_const'
d_dbus='$d_dbus'
d_deflate='$d_deflate'
d_dev_poll='$d_dev_poll'
d_difftime='$d_difftime'
d_dirent_d_namlen='$d_dirent_d_namlen'
d_dirent_d_type='$d_dirent_d_type'
d_dirfd='$d_dirfd'
d_dirnamlen='$d_dirnamlen'
d_dladdr='$d_dladdr'
d_dos='$d_dos'
d_enablenls='$d_enablenls'
d_end_symbol='$d_end_symbol'
d_eofnblk='$d_eofnblk'
d_epoll='$d_epoll'
d_etext_symbol='$d_etext_symbol'
d_eunice='$d_eunice'
d_fchdir='$d_fchdir'
d_fdatasync='$d_fdatasync'
d_fdopendir='$d_fdopendir'
d_fork='$d_fork'
d_fstatat='$d_fstatat'
d_fsync='$d_fsync'
d_ftime='$d_ftime'
d_getaddrinfo='$d_getaddrinfo'
d_geteuid='$d_geteuid'
d_gethname='$d_gethname'
d_getifaddrs='$d_getifaddrs'
d_getinvent='$d_getinvent'
d_getlogin='$d_getlogin'
d_getnameinfo='$d_getnameinfo'
d_getppid='$d_getppid'
d_getprogname='$d_getprogname'
d_getpwnam='$d_getpwnam'
d_getpwuid='$d_getpwuid'
d_getrlimit='$d_getrlimit'
d_gettblsz='$d_gettblsz'
d_gettext='$d_gettext'
d_gettimeod='$d_gettimeod'
d_getuid='$d_getuid'
d_glib='$d_glib'
d_gnulibc='$d_gnulibc'
d_gnutls='$d_gnutls'
d_gtk='$d_gtk'
d_headless='$d_headless'
d_herror='$d_herror'
d_hstrerror='$d_hstrerror'
d_iconv='$d_iconv'
d_ieee754='$d_ieee754'
d_ilp32='$d_ilp32'
d_ilp64='$d_ilp64'
d_index='$d_index'
d_inflate='$d_inflate'
d_iptos='$d_iptos'
d_ipv6='$d_ipv6'
d_isascii='$d_isascii'
d_kevent_int_udata='$d_kevent_int_udata'
d_kqueue='$d_kqueue'
d_linux='$d_linux'
d_locale_charset='$d_locale_charset'
d_lp64='$d_lp64'
d_lstat='$d_lstat'
d_madvise='$d_madvise'
d_memalign='$d_memalign'
d_memcpy='$d_memcpy'
d_memmove='$d_memmove'
d_mempcpy='$d_mempcpy'
d_memrchr='$d_memrchr'
d_memset='$d_memset'
d_mmap='$d_mmap'
d_msghdr_msg_flags='$d_msghdr_msg_flags'
d_mymalloc='$d_mymalloc'
d_nanosleep='$d_nanosleep'
d_nls='$d_nls'
d_official='$d_official'
d_oldsock='$d_oldsock'
d_open3='$d_open3'
d_openat='$d_openat'
d_os2='$d_os2'
d_pause='$d_pause'
d_phostname='$d_phostname'
d_pipe2='$d_pipe2'
d_poll='$d_poll'
d_popcount='$d_popcount'
d_popen='$d_popen'
d_portable='$d_portable'
d_posix_fadvise='$d_posix_fadvise'
d_posix_memalign='$d_posix_memalign'
d_pread='$d_pread'
d_preadv='$d_preadv'
d_proginvocname='$d_proginvocname'
d_ptattr_setstack='$d_ptattr_setstack'
d_pwage='$d_pwage'
d_pwchange='$d_pwchange'
d_pwclass='$d_pwclass'
d_pwcomment='$d_pwcomment'
d_pwexpire='$d_pwexpire'
d_pwquota='$d_pwquota'
d_pwrite='$d_pwrite'
d_pwritev='$d_pwritev'
d_recvmsg='$d_recvmsg'
d_regcomp='$d_regcomp'
d_regparm='$d_regparm'
d_remotectrl='$d_remotectrl'
d_rusage='$d_rusage'
d_sbrk='$d_sbrk'
d_sched_yield='$d_sched_yield'
d_select='$d_select'
d_semctl='$d_semctl'
d_semget='$d_semget'
d_semop='$d_semop'
d_semtimedop='$d_semtimedop'
d_sendfile='$d_sendfile'
d_setenv='$d_setenv'
d_setproctitle='$d_setproctitle'
d_setprogname='$d_setprogname'
d_setsid='$d_setsid'
d_sigaction='$d_sigaction'
d_sigaltstack='$d_sigaltstack'
d_sigprocmask='$d_sigprocmask'
d_sigsetjmp='$d_sigsetjmp'
d_sockaddr_in_sin_len='$d_sockaddr_in_sin_len'
d_sockaddr_un='$d_sockaddr_un'
d_socker_get='$d_socker_get'
d_socket='$d_socket'
d_sockpair='$d_sockpair'
d_statfs='$d_statfs'
d_statvfs='$d_statvfs'
d_strchr='$d_strchr'
d_strlcat='$d_strlcat'
d_strlcpy='$d_strlcpy'
d_sync_atomic='$d_sync_atomic'
d_syscall='$d_syscall'
d_sysctl='$d_sysctl'
d_system='$d_system'
d_times='$d_times'
d_ttyname='$d_ttyname'
d_uctx_mctx='$d_uctx_mctx'
d_uctx_mctx_gregs='$d_uctx_mctx_gregs'
d_uname='$d_uname'
d_useglib1='$d_useglib1'
d_useglib2='$d_useglib2'
d_usegtk1='$d_usegtk1'
d_usegtk2='$d_usegtk2'
d_usleep='$d_usleep'
d_vfork='$d_vfork'
d_voidsig='$d_voidsig'
d_volatile='$d_volatile'
d_vsnprintf='$d_vsnprintf'
d_waitpid='$d_waitpid'
d_windows='$d_windows'
d_xenix='$d_xenix'
date='$date'
dbuscflags='$dbuscflags'
dbusconfig='$dbusconfig'
dbusldflags='$dbusldflags'
defvoidused='$defvoidused'
direntrytype='$direntrytype'
eagain='$eagain'
ebcdic='$ebcdic'
echo='$echo'
egrep='$egrep'
emacs='$emacs'
enablenls='$enablenls'
eunicefix='$eunicefix'
expr='$expr'
fieldn='$fieldn'
find='$find'
firstmakefile='$firstmakefile'
flex='$flex'
freetype='$freetype'
from='$from'
gcc='$gcc'
gccosandvers='$gccosandvers'
gccversion='$gccversion'
glade='$glade'
glibcflags='$glibcflags'
glibconfig='$glibconfig'
glibldflags='$glibldflags'
glibpackage='$glibpackage'
glibpth='$glibpth'
glibversion='$glibversion'
gmake='$gmake'
gmsgfmt='$gmsgfmt'
gnulibc_version='$gnulibc_version'
gnutlscflags='$gnutlscflags'
gnutlsconfig='$gnutlsconfig'
gnutlsldflags='$gnutlsldflags'
grep='$grep'
groupcat='$groupcat'
gtkcflags='$gtkcflags'
gtkconfig='$gtkconfig'
gtkgversion='$gtkgversion'
gtkldflags='$gtkldflags'
gtkpackage='$gtkpackage'
gtkversion='$gtkversion'
gzip='$gzip'
h_fcntl='$h_fcntl'
h_sysfile='$h_sysfile'
hint='$hint'
hostcat='$hostcat'
huge='$huge'
i_alloca='$i_alloca'
i_arpainet='$i_arpainet'
i_dirent='$i_dirent'
i_dlfcn='$i_dlfcn'
i_execinfo='$i_execinfo'
i_fcntl='$i_fcntl'
i_iconv='$i_iconv'
i_ifaddrs='$i_ifaddrs'
i_inttypes='$i_inttypes'
i_invent='$i_invent'
i_langinfo='$i_langinfo'
i_libcharset='$i_libcharset'
i_libintl='$i_libintl'
i_limits='$i_limits'
i_linux_netlink='$i_linux_netlink'
i_linux_rtnetlink='$i_linux_rtnetlink'
i_malloc='$i_malloc'
i_math='$i_math'
i_mswsock='$i_mswsock'
i_netdb='$i_netdb'
i_netif='$i_netif'
i_netroute='$i_netroute'
i_niin='$i_niin'
i_niip='$i_niip'
i_poll='$i_poll'
i_pthread='$i_pthread'
i_pwd='$i_pwd'
i_regex='$i_regex'
i_sched='$i_sched'
i_stdarg='$i_stdarg'
i_stdlib='$i_stdlib'
i_string='$i_string'
i_sys_ucontext='$i_sys_ucontext'
i_sysfile='$i_sysfile'
i_sysin='$i_sysin'
i_sysipc='$i_sysipc'
i_sysmman='$i_sysmman'
i_sysmount='$i_sysmount'
i_sysparam='$i_sysparam'
i_syspoll='$i_syspoll'
i_sysresrc='$i_sysresrc'
i_sysselct='$i_sysselct'
i_syssem='$i_syssem'
i_syssendfile='$i_syssendfile'
i_syssock='$i_syssock'
i_sysstat='$i_sysstat'
i_sysstatvfs='$i_sysstatvfs'
i_syssysctl='$i_syssysctl'
i_systime='$i_systime'
i_systimeb='$i_systimeb'
i_systimek='$i_systimek'
i_systimes='$i_systimes'
i_systypes='$i_systypes'
i_sysun='$i_sysun'
i_sysutsname='$i_sysutsname'
i_sysvfs='$i_sysvfs'
i_syswait='$i_syswait'
i_time='$i_time'
i_ucontext='$i_ucontext'
i_unistd='$i_unistd'
i_varargs='$i_varargs'
i_varhdr='$i_varhdr'
i_winsock2='$i_winsock2'
i_ws2tcpip='$i_ws2tcpip'
i_zlib='$i_zlib'
ieee754_byteorder='$ieee754_byteorder'
ilp='$ilp'
incpath='$incpath'
inews='$inews'
install='$install'
installarchlib='$installarchlib'
installbin='$installbin'
installdir='$installdir'
installmansrc='$installmansrc'
installprivlib='$installprivlib'
intsize='$intsize'
issymlink='$issymlink'
ksh='$ksh'
large='$large'
ldflags='$ldflags'
less='$less'
libc='$libc'
libnames='$libnames'
libpth='$libpth'
libs='$libs'
libscheck='$libscheck'
libsdirs='$libsdirs'
libsfiles='$libsfiles'
libsfound='$libsfound'
libspath='$libspath'
libswanted='$libswanted'
line='$line'
lint='$lint'
lkflags='$lkflags'
ln='$ln'
lns='$lns'
locale='$locale'
localeexp='$localeexp'
locincpth='$locincpth'
loclibpth='$loclibpth'
longsize='$longsize'
lp='$lp'
lpr='$lpr'
ls='$ls'
mail='$mail'
mailx='$mailx'
make='$make'
make_set_make='$make_set_make'
mallocobj='$mallocobj'
mallocsrc='$mallocsrc'
malloctype='$malloctype'
manext='$manext'
mansrc='$mansrc'
mansrcexp='$mansrcexp'
medium='$medium'
mips_type='$mips_type'
mkdep='$mkdep'
mkdir='$mkdir'
models='$models'
more='$more'
msgfmt='$msgfmt'
msgmerge='$msgmerge'
msgmerge_update='$msgmerge_update'
mv='$mv'
myarchname='$myarchname'
mydomain='$mydomain'
myhostname='$myhostname'
myuname='$myuname'
n='$n'
nawk='$nawk'
nm='$nm'
nm_opt='$nm_opt'
nm_so_opt='$nm_so_opt'
nofile='$nofile'
nroff='$nroff'
o_nonblock='$o_nonblock'
official='$official'
optimize='$optimize'
orderlib='$orderlib'
osname='$osname'
osvers='$osvers'
package='$package'
passcat='$passcat'
perl='$perl'
pg='$pg'
phostname='$phostname'
pkgsrc='$pkgsrc'
plibpth='$plibpth'
pmake='$pmake'
pr='$pr'
prefix='$prefix'
prefixexp='$prefixexp'
privlib='$privlib'
privlibexp='$privlibexp'
prototype='$prototype'
pthread='$pthread'
ptrsize='$ptrsize'
ranlib='$ranlib'
rd_nodata='$rd_nodata'
remotectrl='$remotectrl'
rm='$rm'
rm_try='$rm_try'
rmail='$rmail'
run='$run'
runnm='$runnm'
sed='$sed'
sendmail='$sendmail'
sh='$sh'
shar='$shar'
sharpbang='$sharpbang'
shortsize='$shortsize'
shsharp='$shsharp'
sig_count='$sig_count'
sig_name='$sig_name'
sig_name_init='$sig_name_init'
sig_num='$sig_num'
sig_num_init='$sig_num_init'
sig_size='$sig_size'
signal_t='$signal_t'
sleep='$sleep'
smail='$smail'
small='$small'
so='$so'
sockercflags='$sockercflags'
sockerldflags='$sockerldflags'
sockethdr='$sockethdr'
socketlib='$socketlib'
sort='$sort'
spackage='$spackage'
spitshell='$spitshell'
split='$split'
src='$src'
startsh='$startsh'
strings='$strings'
submit='$submit'
sysman='$sysman'
tablesize='$tablesize'
tail='$tail'
tar='$tar'
targetarch='$targetarch'
tbl='$tbl'
tee='$tee'
test='$test'
timeincl='$timeincl'
to='$to'
touch='$touch'
tr='$tr'
trnl='$trnl'
troff='$troff'
uname='$uname'
uniq='$uniq'
use_difftime='$use_difftime'
usecrosscompile='$usecrosscompile'
usemymalloc='$usemymalloc'
usenm='$usenm'
usevfork='$usevfork'
usrinc='$usrinc'
uuname='$uuname'
vi='$vi'
voidflags='$voidflags'
wc='$wc'
xgettext='$xgettext'
xlibpth='$xlibpth'
yacc='$yacc'
yaccflags='$yaccflags'
zcat='$zcat'
zip='$zip'
EOT

: add special variables
$test -f $src/patchlevel.h && \
awk '/^#define/ {printf "%s=%s\n",$2,$3}' $src/patchlevel.h >>config.sh
$test -f $src/revision.h && \
sed -ne 's/^#define \([A-Za-z0-9_]*\) ".*: \([0-9]*\).*"/\1=\2/p' \
	< $src/revision.h >>config.sh
echo "CONFIG=true" >>config.sh

: propagate old symbols
if $test -f UU/config.sh; then
	<UU/config.sh $sort | $uniq >UU/oldconfig.sh
	$sed -n 's/^\([a-zA-Z_0-9]*\)=.*/\1/p' \
		config.sh config.sh UU/oldconfig.sh |\
		$sort | $uniq -u >UU/oldsyms
	set X `cat UU/oldsyms`
	shift
	case $# in
	0) ;;
	*)
		cat <<EOM
Hmm...You had some extra variables I don't know about...I'll try to keep 'em...
EOM
		echo ": Variables propagated from previous config.sh file." >>config.sh
		for sym in `cat UU/oldsyms`; do
			echo "    Propagating $hint variable "'$'"$sym..."
			eval 'tmp="$'"${sym}"'"'
			echo "$tmp" | \
				sed -e "s/'/'\"'\"'/g" -e "s/^/$sym='/" -e "s/$/'/" >>config.sh
		done
		;;
	esac
fi

: Finish up by extracting the .SH files
case "$alldone" in
exit)
	echo "Stopping at your request, leaving temporary files around."
	exit 0
	;;
cont)
	;;
'')
	dflt=''
	nostick=true
	$cat <<EOM

If you'd like to make any changes to the config.sh file before I begin
to configure things, do it as a shell escape now (e.g. !vi config.sh).

EOM
	rp="Press return or use a shell escape to edit config.sh:"
	. UU/myread
	nostick=''
	case "$ans" in
	'') ;;
	*) : in case they cannot read
		sh 1>&4 -c "$ans";;
	esac
	;;
esac

: if this fails, just run all the .SH files by hand
. ./config.sh

echo " "
exec 1>&4
pwd=`pwd`
. ./UU/extract
cd "$pwd"

if $contains '^depend:' [Mm]akefile >/dev/null 2>&1; then
	dflt=y
	case "$silent" in
	true) ;;
	*)
		$cat <<EOM

Now you need to generate make dependencies by running "$make depend".
You might prefer to run it in background: "$make depend > makedepend.out &"
It can take a while, so you might not want to run it right now.

EOM
		;;
	esac
	rp="Run $make depend now?"
	. UU/myread
	case "$ans" in
	y*)
		$make depend && echo "Now you must run '$make'."
		;;
	*)
		echo "You must run '$make depend' then '$make'."
		;;
	esac
elif test -f [Mm]akefile; then
	echo " "
	echo "Now you must run a $make."
else
	echo "Configure done."
fi

if $test -f Policy.sh; then
    $cat <<EOM

If you compile $package on a different machine or from a different object
directory, copy the Policy.sh file from this object directory to the
new one before you run Configure -- this will help you with most of
the policy defaults.

EOM
fi
if $test -f UU/config.msg; then
    echo "Hmm.  I also noted the following information while running:"
    echo " "
    $cat UU/config.msg >&4
fi
$rm -f kit*isdone ark*isdone
$rm -rf UU

: End of Configure

