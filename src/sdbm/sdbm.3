.\" $Id: sdbm.3,v 1.2 90/12/13 13:00:57 oz Exp $
.TH SDBM 3 "1 March 1990"
.SH NAME
sdbm, sdbm_open, sdbm_prep, sdbm_close, sdbm_unlink, sdbm_fetch, sdbm_store, sdbm_replace, sdbm_delete, sdbm_exists, sdbm_firstkey, sdbm_nextkey, sdbm_hash, sdbm_rdonly, sdbm_error, sdbm_clearerr, sdbm_dirfno, sdbm_pagfno, sdbm_datfno \- data base subroutines
.SH SYNOPSIS
.nf
.ft B
#include <sdbm.h>
.sp
typedef struct {
	char *dptr;
	size_t dsize;
} datum;
.sp
datum nullitem = { NULL, 0 };
.sp
\s-1DBM\s0 *sdbm_open(char *file, int flags, int mode)
\s-1DBM\s0 *sdbm_prep(char *dirname, char *pagname, char *datname,
        int flags, int mode)
void sdbm_close(\s-1DBM\s0 *db)
void sdbm_unlink(\s-1DBM\s0 *db)
int sdbm_rebuild(\s-1DBM\s0 *db)
.sp
datum sdbm_fetch(\s-1DBM\s0 *db, key)
int sdbm_store(\s-1DBM\s0 *db, datum key, datum val, int flags)
int sdbm_replace(\s-1DBM\s0 *db, datum key, datum val, bool *existed)
int sdbm_delete(\s-1DBM\s0 *db, datum key)
int sdbm_exists(\s-1DBM\s0 *db, datum key)
.sp
datum sdbm_firstkey(\s-1DBM\s0 *db)
datum sdbm_firstkey_safe(\s-1DBM\s0 *db)
datum sdbm_nextkey(\s-1DBM\s0 *db)
datum sdbm_value(\s-1DBM\s0 *db)
int sdbm_deletekey(\s-1DBM\s0 *db)
void sdbm_endkey(\s-1DBM\s0 *db)
.sp
long sdbm_hash(char *string, size_t len)
.sp
ssize_t sdbm_sync(\s-1DBM\s0 *db)
ssize_t sdbm_count(const \s-1DBM\s0 *db)
ssize_t sdbm_delta(const \s-1DBM\s0 *db)
void sdbm_delta_reset(\s-1DBM\s0 *db)
.sp
int sdbm_set_cache(\s-1DBM\s0 *db, long pages)
int sdbm_set_wdelay(\s-1DBM\s0 *db, bool on)
int sdbm_set_volatile(\s-1DBM\s0 *db, bool yes)
.sp
long sdbm_get_cache(const \s-1DBM\s0 *db)
bool sdbm_get_wdelay(const \s-1DBM\s0 *db)
bool sdbm_is_volatile(const \s-1DBM\s0 *db)
.sp
void sdbm_set_name(\s-1DBM\s0 *db, const char *string)
const char *sdbm_name(const \s-1DBM\s0 *db)
.sp
int sdbm_rename(\s-1DBM\s0 *db, char *base)
int sdbm_rename_files(\s-1DBM\s0 *db,
	char *dirname, char *pagname, char *datname)
.sp
bool sdbm_rdonly(const \s-1DBM\s0 *db)
bool sdbm_error(const \s-1DBM\s0 *db)
bool sdbm_shrink(\s-1DBM\s0 *db)
bool sdbm_clear(\s-1DBM\s0 *db)
void sdbm_clearerr(\s-1DBM\s0 *db)
int sdbm_dirfno(\s-1DBM\s0 *db)
int sdbm_pagfno(\s-1DBM\s0 *db)
int sdbm_datfno(\s-1DBM\s0 *db)
.sp
bool sdbm_is_storable(size_t key, size_t value)
.sp
void sdbm_thread_safe(\s-1DBM\s0 *db)
void sdbm_lock(\s-1DBM\s0 *db)
void sdbm_unlock(\s-1DBM\s0 *db)
bool sdbm_is_thread_safe(const \s-1DBM\s0 *db)
bool sdbm_is_locked(const \s-1DBM\s0 *db)
\s-1DBM\s0 *sdbm_ref(const \s-1DBM\s0 *db)
void sdbm_unref(const \s-1DBM\s0 **db_ptr)
int sdbm_refcnt(const \s-1DBM\s0 *db)
int sdbm_rebuild_async(\s-1DBM\s0 *db)
.sp
size_t sdbm_foreach(\s-1DBM\s0 *db, int flags, sdbm_cb_t cb, void *arg);
size_t sdbm_foreach_remove(\s-1DBM\s0 *db, int flags, sdbm_cbr_t cb, void *arg);
.sp
size_t sdbm_loose_foreach(\s-1DBM\s0 *db, int flags, sdbm_cb_t cb, void *arg);
size_t sdbm_loose_foreach_remove(\s-1DBM\s0 *db,
        int flags, sdbm_cbr_t cb, void *arg);
.ft R
.fi
.SH DESCRIPTION
.IX "database library" sdbm "" "\fLsdbm\fR"
.IX sdbm_open "" "\fLsdbm_open\fR \(em open \fLsdbm\fR database"
.IX sdbm_prep "" "\fLsdbm_prep\fR \(em prepare \fLsdbm\fR database"
.IX sdbm_close "" "\fLsdbm_close\fR \(em close \fLsdbm\fR routine"
.IX sdbm_unlink "" "\fLsdbm_unlink\fR \(em close and unlink \fLsdbm\fR files"
.IX sdbm_fetch "" "\fLsdbm_fetch\fR \(em fetch \fLsdbm\fR database data"
.IX sdbm_store "" "\fLsdbm_store\fR \(em add data to \fLsdbm\fR database"
.IX sdbm_replace "" "\fLsdbm_replace\fR \(em replace data in \fLsdbm\fR database"
.IX sdbm_delete "" "\fLsdbm_delete\fR \(em remove data from \fLsdbm\fR database"
.IX sdbm_exists "" "\fLsdbm_exists\fR \(em test \fLsdbm\fR key existence"
.IX sdbm_firstkey "" "\fLsdbm_firstkey\fR \(em start iterator on \fLsdbm\fR database"
.IX sdbm_firstkey_safe "" "\fLsdbm_firstkey_safe\fR \(em start iterator on \fLsdbm\fR database with extended page checks"
.IX sdbm_nextkey "" "\fLsdbm_nextkey\fR \(em move iterator on \fLsdbm\fR database"
.IX sdbm_value "" "\fLsdbm_value\fR \(em current value in \fLsdbm\fR database iterator"
.IX sdbm_deletekey "" "\fLsdbm_deletekey\fR \(em delete current key in \fLsdbm\fR database"
.IX sdbm_hash "" "\fLsdbm_hash\fR \(em string hash for \fLsdbm\fR database"
.IX sdbm_rdonly "" "\fLsdbm_rdonly\fR \(em return \fLsdbm\fR database read-only mode"
.IX sdbm_error "" "\fLsdbm_error\fR \(em return \fLsdbm\fR database error condition"
.IX sdbm_shrink "" "\fLsdbm_shrink\fR \(em attempt to shrink files on disk"
.IX sdbm_clear "" "\fLsdbm_clear\fR \(em erase all data but keep database opened"
.IX sdbm_clearerr "" "\fLsdbm_clearerr\fR \(em clear \fLsdbm\fR database error condition"
.IX sdbm_dirfno "" "\fLsdbm_dirfno\fR \(em return \fLsdbm\fR database bitmap file descriptor"
.IX sdbm_pagfno "" "\fLsdbm_pagfno\fR \(em return \fLsdbm\fR database page file descriptor"
.IX sdbm_datfno "" "\fLsdbm_datfno\fR \(em return \fLsdbm\fR database data file descriptor"
.IX "database functions \(em \fLsdbm\fR"  sdbm_open  ""  \fLsdbm_open\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_prep  ""  \fLsdbm_prep\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_close  ""  \fLsdbm_close\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_unlink  ""  \fLsdbm_unlink\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_fetch  ""  \fLsdbm_fetch\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_store  ""  \fLsdbm_store\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_delete  ""  \fLsdbm_delete\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_firstkey  ""  \fLsdbm_firstkey\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_firstkey_safe  ""  \fLsdbm_firstkey_safe\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_nextkey  ""  \fLsdbm_nextkey\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_value  ""  \fLsdbm_value\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_deletekey  ""  \fLsdbm_deletekey\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_rdonly  ""  \fLsdbm_rdonly\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_error  ""  \fLsdbm_error\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_shrink  ""  \fLsdbm_shrink\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_clear  ""  \fLsdbm_clear\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_clearerr  ""  \fLsdbm_clearerr\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_dirfno  ""  \fLsdbm_dirfno\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_pagfno  ""  \fLsdbm_pagfno\fP
.IX "database functions \(em \fLsdbm\fR"  sdbm_datfno  ""  \fLsdbm_datfno\fP
.LP
This package allows an application to maintain a mapping of <key,value> pairs
in disk files.  This is not to be considered a real database system, but is
still useful in many simple applications built around fast retrieval of a data
value from a key.  This implementation uses an external hashing scheme,
called Dynamic Hashing, as described by Per-Aake Larson in BIT 18 (1978) pp.
184-201.  Retrieval of any item usually requires a single disk access, unless
some keys or values are large enough to be stored via indirections, in which
case more disk accesses are required.
The application interface is compatible with the
.IR ndbm (3)
library.
.LP
An
.B sdbm
database is kept in two files usually given the extensions
.B \.dir
and
.BR \.pag .
The
.B \.dir
file contains a bitmap representing a forest of binary hash trees, the leaves
of which indicate data pages in the
.B \.pag
file.
When facing large keys or values that would not otherwise fit in one page,
a third file (carrying the
.B \.dat
extension) is created to store the large data, with indirection pointers
left in the
.B \.pag
file to be able to access the underlying data.
.LP
A
.BR \.tmp
file can also be created to store all the temporary file extensions used by
the database during a rebuild operation.  If the process is killed in the
middle of a rebuild, the left-over files can then be properly reclaimed when
the application calls
.BR sdbm_prep (\|)
or
.BR sdbm_open (\|)
in a later invocation, from another process.
.LP
The application interface uses the
.B datum
structure to describe both
.I keys
and
.IR value s.
A
.B datum
specifies a byte sequence of
.I dsize
size pointed to by
.IR dptr .
If you use
.SM ASCII
strings as
.IR key s
or
.IR value s,
then you must decide whether or not to include the terminating
.SM NUL
byte which sometimes defines strings.  Including it will require larger
database files, but it will be possible to get sensible output from a
.IR strings (1)
command applied to the data file.
.LP
In order to allow a process using this package to manipulate multiple
databases, the applications interface always requires a
.IR handle ,
a
.BR "DBM\ *" ,
to identify the database to be manipulated.  Such a handle can be obtained
from the only routines that do not require it, namely
.BR sdbm_open (\|)
or
.BR sdbm_prep (\|).
Either of these will open or create the two or three necessary files.  The
difference is that the latter allows explicitly naming the bitmap and data
files whereas
.BR sdbm_open (\|)
will take a base file name and call
.BR sdbm_prep (\|)
with the default extensions.  Furthermore, giving a
.B NULL
pointer for
.B datname
in
.BR sdbm_prep (\|)
will disable support for large keys and values.
The
.I flags
and
.I mode
parameters are the same as for
.BR open (2).
.LP
To free the resources occupied while a database handle is active, call
.BR sdbm_close (\|).
The
.BR sdbm_unlink (\|)
call is similar to
.BR sdbm_close (\|)
but will additionally force the deletion of the database files.
.LP
Given a handle, one can retrieve data associated with a key by using the
.BR sdbm_fetch (\|)
routine, and associate data with a key by using the
.BR sdbm_store (\|)
routine.
.BR sdbm_exists (\|)
will say whether a given key exists in the database.
.LP
The values of the
.I flags
parameter for
.BR sdbm_store (\|)
can be either
.BR \s-1DBM_INSERT\s0 ,
which will not change an existing entry with the same key, or
.BR \s-1DBM_REPLACE\s0 ,
which will replace an existing entry with the same key.
Keys are unique within the database.
.LP
To replace a possibly existing key and know whether the key existed or was
actually created, use
.BR sdbm_replace (\|)
and the parameter
.B existed
will be set upon return to indicate whether the key existed already,
provided the call is not returning -1.
.LP
To delete a key and its associated value use the
.BR sdbm_delete (\|)
routine.
.LP
To retrieve every key/value pairss in the database, use a loop like:
.sp
.nf
.ft B
for (key = sdbm_firstkey(db); key.dptr != NULL; key = sdbm_nextkey(db)) {
    datum value = sdbm_value(db);
}
.ft R
.fi
.LP
The order of retrieval is unspecified.  During traversal, no insertion or
deletion of any other key should occur.  However, the current key may be
deleted through the
.BR sdbm_deletekey (\|)
routine.  Usage of
.BR sdbm_value (\|)
or
.BR sdbm_deletekey (\|)
outside of the outlined iterator loop is forbidden.  Should that happen, an
error is returned (either
.B nullitem
or
.BR -1 )
and
.B errno
is set to
.BR \s-1ENOENT\s0 .
.LP
The iteration may begin with
.BR sdbm_firstkey_safe (\|)
instead, which will activate extended checks of each page: keys not belonging
to the page are deleted on the fly.  This is useful when iterating over a
database which could have been corrupted due to I/O errors, and the
.B \.dir
and
.B \.pag
files are not consistent with eachother.
.LP
If for some reason the iteration must be aborted before
.BR sdbm_nextkey (\|)
or
.BR sdbm_firstkey (\|)
return
.BR nullitem ,
then the
.BR sdbm_endkey (\|)
routine must be called to clear the iteration context and mark the end
of the iteration loop.
.LP
If you determine that the performance of the database is inadequate or
you notice clustering or other effects that may be due to the hashing
algorithm used by this package, you can override it by supplying your
own
.BR sdbm_hash (\|)
routine.  Doing so will make the database unintelligable to any other
applications that do not use your specialized hash function.
.sp
.LP
The following functions are also defined in the header file:
.IP
.BR sdbm_rdonly (\|)
returns true if the database has been opened read\-only.
.IP
.BR sdbm_error (\|)
returns true if an I/O error has occurred.  After a write I/O error,
the database is put in read-only mode until
.BR sdbm_clearerr (\|)
has been called, to prevent cascading errors.
.IP
.BR sdbm_clearerr (\|)
allows you to clear the error flag if you think you know what the error
was and insist on ignoring it.
.IP
.BR sdbm_dirfno (\|)
returns the file descriptor associated with the bitmap file.
.IP
.BR sdbm_pagfno (\|)
returns the file descriptor associated with the page file.
.IP
.BR sdbm_datfno (\|)
returns the file descriptor associated with the data file (large keys and
values), or
.B -1
if the file was not opened yet because it was not needed so far.
.IP
.BR sdbm_name (\|)
returns the database name previously set using
.BR sdbm_set_name (\|)
or a string starting with "file " and followed by the pathname of the
.B .pag
file if no name was set yet.
.IP
.BR sdbm_is_storable (\|)
indicates whether a combination of key and value sizes can fit within the size
constraints we have.
.IP
.BR sdbm_shrink (\|)
attempts to shrink the allocated files on disk to reclaim unused trailing
space, after many value deletions for instance.  Returns
.B FALSE
on errors.
.IP
.BR sdbm_count (\|)
quickly counts the amount of entries (key/value pairs) in the database by
scanning the whole
database file.  Returns
.B -1
on error.
.IP
.BR sdbm_delta (\|)
returns the algebraic count of entries added (if positive) or removed
(if negative) from the database since the last reset of the counter.
This is simply the result of
.I added
minus
.I deleted
pairs.
It is initially set to
.B 0
after the database has been opened.
.IP
.BR sdbm_delta_reset (\|)
resets the algebraic count of
.I added
minus
.I deleted
pairs to
.BR 0 .
.IP
.BR sdbm_clear (\|)
erases all the data held in the database but keeps it opened.
Returns
.B -1
on error.
It also issues a
.BR sdbm_delta_reset (\|)
call.
.IP
.BR sdbm_rename (\|)
renames the database files using the specified name base (without a
.BR .pag
or other
.BR .dir
extension) and transparently re-opens the database using the new files.
Returns -1 on error.
.IP
.BR sdbm_rename_files (\|)
works like
.BR sdbm_rename (\|)
but with the new filenames explicitly given.
.IP
.BR sdbm_rebuild (\|)
rebuilds the database, hopefully leading to a more compact on-disk
representation. It returns -1 on failure.  It is also possible to rebuild
the database asynchronously, from a separate thread by using
.BR sdbm_rebuild_async (\|)
instead: concurrent usage from other threads is possible during that
asynchronous rebuild.
.SH ITERATING
It is possible to use high-level iterators on the database to process all the
items (key / value pairs) via a common routine.  That processing callback
of type
.B sdbm_cb_t
has the following signature:
.sp
.nf
.ft B
void callback(const datum key, const datum value, void *arg);
.ft R
.fi
.LP
The
.B key
and
.B value
arguments are the current item key and value, and
.B arg
is an opaque argument given as context to the routine.  To invoke the callback
on all the items, one uses:
.sp
.nf
.ft B
sdbm_foreach(db, flags, callback, arg);
.ft R
.fi
.LP
The
.B arg
here will be passed as-is to the callback routine for every item.  The
.B flags
govern the way the traversal is made.  It can be a combination of the following
flags, or 0 to use the default processing:
.B \s-1DBM_F_SAFE\s0
will activate key checking during the iteration whilst
.B \s-1DBM_F_SKIP\s0
will skip unreadable values, especially for big values that cannot be correctly
fetched from the data file.
.LP
The
.BR sdbm_foreach (\|)
routine returns the number of items that were successfully iterated over,
in other words, the amount of entries in the databse.  It is possible to
use a
.B NULL
argument for the callback parameter to have
.BR sdbm_foreach (\|)
simply iterate over the database to count the items.
.LP
Using
.BR sdbm_foreach_remove (\|),
one can also iterate over all the items and use a callback of type
.B sdbm_cbr_t
whose signature is:
.sp
.nf
.ft B
bool callback(const datum key, const datum value, void *arg);
.ft R
.fi
.LP
It returns a boolean value, with
.B \s-1TRUE\s0
indicating that the item being iterated over should be removed and
.B \s-1FALSE\s0
indicating that the item is to be kept.
.LP
The
.BR sdbm_foreach_remove (\|)
routine returns the number of items that were successfully iterated over, and
for which the callback returned
.BR \s-1FALSE\s0 ,
in other words, it returns the amount of remaining entries in the database.
.SH THREAD SAFETY
By default, the database handles can only be used by the thread that created
them.  However, invoking
.BR sdbm_thread_safe (\|)
on a newly created database will allow safe concurrent accesses to the
database: this locks the database handle for the duration of the call and
routines which return a
.B datum
will make sure that the data returned are thread-private, making the necessary
copy to allow concurrent updates to the database after the value was returned.
.LP
For multiple operations that need to be performed consistently over the
database without interruptions by other threads, one may call
.BR sdbm_lock (\|)
to begin the critical section and
.BR sdbm_unlock (\|)
to end the critical section.  Calls can nest as long as they are paired
correctly.  It is forbidden to use these routines on a database that was
not marked as being concurrent via
.BR sdbm_thread_safe (\|)
beforehand.
.LP
The
.BR sdbm_is_thread_safe (\|)
and
.BR sdbm_is_locked (\|)
predicates can be used in assertions to check respectively whether the database
was flagged as being thread-safe and whether it is currently locked by the
calling thread.  The
.BR sdbm_is_locked (\|)
routine will always return
.BR \s-1FALSE\s0
for databases that have not been marked thread-safe.
.LP
Concurrent iterations on the database are forbidden, and this is enforced by
having the iterators return
.B nullitem
and set
.B errno
to
.BR \s-1EPERM\s0 .
.LP
When iterating, it is required to take the DB lock during the whole operation.
Iterating routines such as
.BR sdbm_firstkey (\|)
or
.BR sdbm_value (\|)
do not return a thread-private datum and enforce the requirement that the
database be locked.
.LP
When passing the database descriptor to other threads, be sure to use
.BR sdbm_ref (\|)
on the receiving side to properly account for the extra reference.  The
.BR sdbm_close (\|)
call will panic when attempting to close a descriptor that has more than one
reference still.  Thus, when sharing descriptors, it is more suitable to call
.BR sdbm_unref (\|)
which will only close when the last reference is gone and which nullifies the
pointer to the descriptor in the thread, preventing further access through
that variable since the reference was dropped.
.LP
Iterating over a large database can take a very long time, and locks the
database for the whole duration of the iteration.  However, sometimes the
application does not require such a
.I strict
iterating policy, but can very well cope with a
.I loose
iterating policy.  The
.BR sdbm_loose_foreach (\|)
and
.BR sdbm_loose_foreach_remove (\|)
routines do just that: they do not grab the lock for the entire duration
of the iteration, allowing concurrent updates to be done by other threads.
However, they do not guarantee that all the items will be traversed, that
no item will not be traversed more than once, that the traversed items
hold the latest value (in case of concurrent update), or even that the
items still exist (in case of concurrent deletion).
.LP
However, the loose traversal guarantees that the keys and values passed
to the callbacks are consistent, and especially that values are not
containing parts of several concurrent updates.  Furthermore, the delete
operation in
.BR sdbm_loose_foreach_remove (\|)
only takes place if no changes occurred on the page where the item lies
since it was given to the callback, to avoid deleting a record for the
wrong reasons.
.LP
By passing the
.B \s-1DBM_F_ALLKEYS\s0
flag to the loosely iterating routines, the database is locked as pages are
processed, meaning all the keys are guaranteed to be traversed and all
deletions will succeed.  However, callbacks are invoked with
the database locked and that reduces opportunities for more concurrency.
The lock is yield back after each processed page.
.SH PAGE CACHING
This
.B sdbm
library is equipped with an LRU (Least Recently Used) page cache whose aim
is to reduce the amount of
.BR read (\|)
system calls performed when accessing data.  By default, it is set to cache
64 pages, but this may be changed at any time by calling
.BR sdbm_set_cache (\|)
with the amount of pages desired for caching. Use 1 to disable LRU caching
altogether and only keep the last loaded page in memory.
.LP
It is also possible to enhance the performance of
.B sdbm
by turning write delay on via
.BR sdbm_set_wdelay (\|)
at any time.
This will also greatly reduce the amount of
.BR write (\|)
system calls performed when changing data, but it could make the database
inconsistent in the advent of a crash before
.BR sdbm_close (\|)
can be called.  To mitigate that risk, the application can call
.BR sdbm_sync (\|)
on a regular basis (say every 5 seconds).  That call returns the amount of
pages flushed if everything was OK, and -1 if an I/O error occurred during
flushing.
.LP
Even with deferred writes, there are important operations that are nonetheless
flushed immediately to disk, when splitting a page for instance.  Otherwise,
in the advent of a crash, the disk data could contain twice the same key / value
pair.  However, if the database is recreated from scratch each time it is
opened, there is no need for this precaution, since disk consistency does not
matter then.  The database is said to be
.I volatile
and this behaviour can be turned on by calling
.BR sdbm_set_volatile (\|)
with a
.B \s-1TRUE\s0
argument.  In which case it also automatically enables delayed writes and
the database files will be deleted when
.BR sdbm_close (\|)
is called.
.LP
To know how a database descriptor has been configured, one can call
.BR sdbm_get_cache (\|)
to get the amount of pages configured for LRU caching, use
.BR sdbm_get_wdelay (\|)
to know whether deferred writes have been enabled, and check volatility by
calling
.BR sdbm_is_volatile (\|).
.SH SEE ALSO
.IR open (2).
.SH DIAGNOSTICS
Functions that return a
.B "DBM\ *"
handle will use
.SM NULL
to indicate an error.
Functions that return an
.B int
will use \-1 to indicate an error.  The normal returned value in that case is 0.
Functions that return a
.B datum
will return
.B nullitem
to indicate an error.
.LP
As a special case,
.BR sdbm_store (\|),
when called with the
.B \s-1DBM_INSERT\s0
flag and the key happens to already exist in the database, will return 1
and
.B errno
is set to
.BR \s-1EEXIST\s0 .
.LP
In general, if a function parameter is invalid,
.B errno
will be set to
.BR \s-1EINVAL\s0 .
If a write operation is requested on a read-only database,
.B errno
will be set to
.BR \s-1ENOPERM\s0 .
If a memory allocation (using
.IR malloc (3))
failed,
.B errno
will be set to
.BR \s-1ENOMEM\s0 .
For I/O operation failures
.B errno
will contain the value set by the relevant failed system call, either
.IR read (2),
.IR write (2),
or
.IR lseek (2).
.LP
When a
.BR sdbm_rename (\|)
or
.BR sdbm_rebuild (\|)
operation fails, the database handle may be left in a broken state, causing
any further access to the database to fail with
.B errno
set to
.BR \s-1ESTALE\s0 .
At this point, the database handle should be closed.
.LP
If the
.BR sdbm_rebuild (\|)
routine is called from within an iteration loop, it will fail and set
.B errno
to
.BR \s-1EBUSY\s0 .
That same error is also returned when
.BR sdbm_rebuild_async (\|)
is called whilst another asynchronous rebuilding is in progress.
.LP
Conversely, if
.BR sdbm_nextkey (\|) ,
.BR sdbm_value (\|)
or
.BR sdbm_deletekey (\|)
are called outside an iteration loop, they will fail with
.B errno
set to
.B \s-1ENOENT\s0
and they will loudly complain to indicate misuse.
.LP
When dealing with large keys or values, an inconsistency in the
.B .pag
or
.B .dat
files (such as bad block number list, requesting access of unallocated data
blocks, etc...) is reported by setting
.B errno
to
.BR \s-1EFAULT\s0 .
.SH AUTHORS
"Ozan S. Yigit" <oz@nexus.yorku.ca>
.sp
Raphael Manfredi <Raphael_Manfredi@pobox.com> (for
.B gtk-gnutella
extensions)
.SH BUGS
The sum of key and value data sizes must not exceed
.B \s-1PAIRMAX\s0
(1008 bytes) if large key/value support was disabled by calling
.BR sdbm_prep (\|)
with a
.B NULL
value for
.BR datname .
Otherwise, with large key/value support enabled, the sum of key and value
data sizes cannot exceed 250 KiB currently, but the real limit can be
lower depending on the respective sizes of keys and values. Use
.BR sdbm_is_storable (\|)
to be sure.
.LP
The sum of the key and value data sizes where several keys hash to the
same value must fit within one bitmap page.
.LP
The
.B \.pag
file will contain holes, so its apparent size is larger than its contents.
When copied through the filesystem the holes will be filled.
.LP
The contents of
.B datum
values returned are in volatile storage.  If you want to retain the values
pointed to, you must copy them immediately before another call to this package.
.LP
The only safe way for multiple processes to (read and) update a database at
the same time, is to implement a private locking scheme outside this package
and open and close the database between lock acquisitions.  It is safe for
multiple processes to concurrently access a database read-only.
.SH APPLICATIONS PORTABILITY
For complete source code compatibility with the Berkeley Unix
.IR ndbm (3)
library, the 
.B sdbm.h
header file should be installed in
.BR /usr/include/ndbm.h .
.LP
The
.B nullitem
data item, and the
.BR sdbm_prep (\|),
.BR sdbm_hash (\|),
.BR sdbm_rdonly (\|),
.BR sdbm_dirfno (\|),
and
.BR sdbm_pagfno (\|)
functions are unique to this package.
.LP
The following functions:
.sp
.in +5
.BR sdbm_datfno (\|)
.br
.BR sdbm_replace (\|)
.br
.BR sdbm_firstkey_safe (\|)
.br
.BR sdbm_deletekey (\|)
.br
.BR sdbm_endkey (\|)
.br
.BR sdbm_value (\|)
.br
.BR sdbm_is_storable (\|)
.br
.BR sdbm_count (\|)
.br
.BR sdbm_delta (\|)
.br
.BR sdbm_delta_reset (\|)
.br
.BR sdbm_sync (\|)
.br
.BR sdbm_shrink (\|)
.br
.BR sdbm_clear (\|)
.br
.BR sdbm_unlink (\|)
.br
.BR sdbm_rename (\|)
.br
.BR sdbm_rename_files (\|)
.br
.BR sdbm_rebuild (\|)
.br
.BR sdbm_rebuild_async (\|)
.br
.BR sdbm_get_cache (\|)
.br
.BR sdbm_get_wdelay (\|)
.br
.BR sdbm_is_volatile (\|)
.br
.BR sdbm_set_cache (\|)
.br
.BR sdbm_set_wdelay (\|)
.br
.BR sdbm_set_volatile (\|)
.br
.BR sdbm_set_name (\|)
.br
.BR sdbm_name (\|)
.br
.BR sdbm_thread_safe (\|)
.br
.BR sdbm_is_thread_safe (\|)
.br
.BR sdbm_lock (\|)
.br
.BR sdbm_unlock (\|)
.br
.BR sdbm_is_locked (\|)
.br
.BR sdbm_ref (\|)
.br
.BR sdbm_unref (\|)
.br
.BR sdbm_refcnt (\|)
.br
.BR sdbm_foreach (\|)
.br
.BR sdbm_foreach_remove (\|)
.br
.BR sdbm_loose_foreach (\|)
.br
.BR sdbm_loose_foreach_remove (\|)
.br
.sp
.in -5
are additions made by Raphael Manfredi for
.B gtk-gnutella
but anyone is welcome reusing these extensions.
.LP
Support for large keys and values was added by Raphael Manfredi in a way
that is backward compatible (i.e. databases not requiring this feature
should see no difference).  When activated (as needed), a third file is
created to store the larger keys and values, ending with the extension
.BR \.dat .
.LP
The API was also made thread-safe by Raphael Manfredi.
