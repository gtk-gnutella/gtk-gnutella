/*
 * Copyright (c) 2001-2003, Richard Eckart
 *
 * THIS FILE IS AUTOGENERATED! DO NOT EDIT!
 * This file is generated from gnet_props.ag using autogen.
 * Autogen is available at http://autogen.sourceforge.net/.
 *
 *----------------------------------------------------------------------
 * This file is part of gtk-gnutella.
 *
 *  gtk-gnutella is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  gtk-gnutella is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with gtk-gnutella; if not, write to the Free Software
 *  Foundation, Inc.:
 *      59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *----------------------------------------------------------------------
 */



#include "lib/prop.h"
#include "lib/eval.h"
#include "lib/mutex.h"
#include "lib/omalloc.h"

#include "gnet_property.h"

/*
 * Includes specified by "uses"-statement in .ag file
 */
#include "core/sockets.h"
#include "core/bsched.h"
#include "lib/misc.h"
#include "if/core/nodes.h"
#include "if/core/sockets.h"
#include "dht/kuid.h"
#include "if/dht/routing.h"
#include "upnp/upnp.h"

#include "lib/override.h"		/* Must be the last header included */


gboolean gnet_property_variable_reading_hostfile     = FALSE;
static const gboolean gnet_property_variable_reading_hostfile_default = FALSE;
gboolean gnet_property_variable_reading_ultrafile     = FALSE;
static const gboolean gnet_property_variable_reading_ultrafile_default = FALSE;
gboolean gnet_property_variable_ancient_version     = FALSE;
static const gboolean gnet_property_variable_ancient_version_default = FALSE;
char   *gnet_property_variable_new_version_str     = NULL;
static const char   *gnet_property_variable_new_version_str_default = NULL;
guint32  gnet_property_variable_up_connections     = 42;
static const guint32  gnet_property_variable_up_connections_default = 42;
guint32  gnet_property_variable_normal_connections     = 0;
static const guint32  gnet_property_variable_normal_connections_default = 0;
guint32  gnet_property_variable_max_connections     = 50;
static const guint32  gnet_property_variable_max_connections_default = 50;
guint32  gnet_property_variable_node_leaf_count     = 0;
static const guint32  gnet_property_variable_node_leaf_count_default = 0;
guint32  gnet_property_variable_node_normal_count     = 0;
static const guint32  gnet_property_variable_node_normal_count_default = 0;
guint32  gnet_property_variable_node_ultra_count     = 0;
static const guint32  gnet_property_variable_node_ultra_count_default = 0;
guint32  gnet_property_variable_max_downloads     = 100;
static const guint32  gnet_property_variable_max_downloads_default = 100;
guint32  gnet_property_variable_max_host_downloads     = 1;
static const guint32  gnet_property_variable_max_host_downloads_default = 1;
guint32  gnet_property_variable_max_uploads     = 4;
static const guint32  gnet_property_variable_max_uploads_default = 4;
guint32  gnet_property_variable_max_uploads_ip     = 1;
static const guint32  gnet_property_variable_max_uploads_ip_default = 1;
host_addr_t  gnet_property_variable_local_ip;
host_addr_t  gnet_property_variable_local_ip6;
time_t  gnet_property_variable_current_ip_stamp     = 0;
static const time_t  gnet_property_variable_current_ip_stamp_default = 0;
time_t  gnet_property_variable_current_ip6_stamp     = 0;
static const time_t  gnet_property_variable_current_ip6_stamp_default = 0;
guint32  gnet_property_variable_average_ip_uptime     = 0;
static const guint32  gnet_property_variable_average_ip_uptime_default = 0;
guint32  gnet_property_variable_average_ip6_uptime     = 0;
static const guint32  gnet_property_variable_average_ip6_uptime_default = 0;
time_t  gnet_property_variable_start_stamp     = 0;
static const time_t  gnet_property_variable_start_stamp_default = 0;
guint32  gnet_property_variable_average_servent_uptime     = 0;
static const guint32  gnet_property_variable_average_servent_uptime_default = 0;
guint32  gnet_property_variable_listen_port     = 1;
static const guint32  gnet_property_variable_listen_port_default = 1;
host_addr_t  gnet_property_variable_forced_local_ip;
host_addr_t  gnet_property_variable_forced_local_ip6;
guint32  gnet_property_variable_connection_speed     = 0;
static const guint32  gnet_property_variable_connection_speed_default = 0;
gboolean gnet_property_variable_compute_connection_speed     = TRUE;
static const gboolean gnet_property_variable_compute_connection_speed_default = TRUE;
guint32  gnet_property_variable_search_max_items     = 50;
static const guint32  gnet_property_variable_search_max_items_default = 50;
guint32  gnet_property_variable_ul_usage_min_percentage     = 70;
static const guint32  gnet_property_variable_ul_usage_min_percentage_default = 70;
guint32  gnet_property_variable_download_connecting_timeout     = 90;
static const guint32  gnet_property_variable_download_connecting_timeout_default = 90;
guint32  gnet_property_variable_download_push_sent_timeout     = 90;
static const guint32  gnet_property_variable_download_push_sent_timeout_default = 90;
guint32  gnet_property_variable_download_connected_timeout     = 180;
static const guint32  gnet_property_variable_download_connected_timeout_default = 180;
guint32  gnet_property_variable_download_retry_timeout_min     = 20;
static const guint32  gnet_property_variable_download_retry_timeout_min_default = 20;
guint32  gnet_property_variable_download_retry_timeout_max     = 3600;
static const guint32  gnet_property_variable_download_retry_timeout_max_default = 3600;
guint32  gnet_property_variable_download_max_retries     = 16;
static const guint32  gnet_property_variable_download_max_retries_default = 16;
guint32  gnet_property_variable_download_retry_timeout_delay     = 120;
static const guint32  gnet_property_variable_download_retry_timeout_delay_default = 120;
guint32  gnet_property_variable_download_retry_busy_delay     = 60;
static const guint32  gnet_property_variable_download_retry_busy_delay_default = 60;
guint32  gnet_property_variable_download_retry_refused_delay     = 180;
static const guint32  gnet_property_variable_download_retry_refused_delay_default = 180;
guint32  gnet_property_variable_download_retry_stopped_delay     = 15;
static const guint32  gnet_property_variable_download_retry_stopped_delay_default = 15;
guint32  gnet_property_variable_download_overlap_range     = 512;
static const guint32  gnet_property_variable_download_overlap_range_default = 512;
guint32  gnet_property_variable_upload_connecting_timeout     = 90;
static const guint32  gnet_property_variable_upload_connecting_timeout_default = 90;
guint32  gnet_property_variable_upload_connected_timeout     = 180;
static const guint32  gnet_property_variable_upload_connected_timeout_default = 180;
guint32  gnet_property_variable_search_reissue_timeout     = 3600;
static const guint32  gnet_property_variable_search_reissue_timeout_default = 3600;
guint32  gnet_property_variable_ban_ratio_fds     = 25;
static const guint32  gnet_property_variable_ban_ratio_fds_default = 25;
guint32  gnet_property_variable_ban_max_fds     = 100;
static const guint32  gnet_property_variable_ban_max_fds_default = 100;
guint32  gnet_property_variable_banned_count     = 0;
static const guint32  gnet_property_variable_banned_count_default = 0;
guint32  gnet_property_variable_max_banned_fd     = 100;
static const guint32  gnet_property_variable_max_banned_fd_default = 100;
guint32  gnet_property_variable_incoming_connecting_timeout     = 60;
static const guint32  gnet_property_variable_incoming_connecting_timeout_default = 60;
guint32  gnet_property_variable_node_connecting_timeout     = 30;
static const guint32  gnet_property_variable_node_connecting_timeout_default = 30;
guint32  gnet_property_variable_node_connected_timeout     = 180;
static const guint32  gnet_property_variable_node_connected_timeout_default = 180;
guint32  gnet_property_variable_node_sendqueue_size     = 98304;
static const guint32  gnet_property_variable_node_sendqueue_size_default = 98304;
guint32  gnet_property_variable_node_tx_flowc_timeout     = 180;
static const guint32  gnet_property_variable_node_tx_flowc_timeout_default = 180;
guint32  gnet_property_variable_node_rx_flowc_ratio     = 70;
static const guint32  gnet_property_variable_node_rx_flowc_ratio_default = 70;
guint32  gnet_property_variable_max_ttl     = 4;
static const guint32  gnet_property_variable_max_ttl_default = 4;
guint32  gnet_property_variable_my_ttl     = 4;
static const guint32  gnet_property_variable_my_ttl_default = 4;
guint32  gnet_property_variable_hard_ttl_limit     = 15;
static const guint32  gnet_property_variable_hard_ttl_limit_default = 15;
guint32  gnet_property_variable_dbg     = 0;
static const guint32  gnet_property_variable_dbg_default = 0;
guint32  gnet_property_variable_ban_debug     = 0;
static const guint32  gnet_property_variable_ban_debug_default = 0;
guint32  gnet_property_variable_cpu_debug     = 0;
static const guint32  gnet_property_variable_cpu_debug_default = 0;
guint32  gnet_property_variable_dmesh_debug     = 0;
static const guint32  gnet_property_variable_dmesh_debug_default = 0;
guint32  gnet_property_variable_gmsg_debug     = 0;
static const guint32  gnet_property_variable_gmsg_debug_default = 0;
guint32  gnet_property_variable_share_debug     = 0;
static const guint32  gnet_property_variable_share_debug_default = 0;
guint32  gnet_property_variable_node_debug     = 0;
static const guint32  gnet_property_variable_node_debug_default = 0;
guint32  gnet_property_variable_socket_debug     = 0;
static const guint32  gnet_property_variable_socket_debug_default = 0;
guint32  gnet_property_variable_bootstrap_debug     = 0;
static const guint32  gnet_property_variable_bootstrap_debug_default = 0;
guint32  gnet_property_variable_http_debug     = 0;
static const guint32  gnet_property_variable_http_debug_default = 0;
guint32  gnet_property_variable_download_debug     = 0;
static const guint32  gnet_property_variable_download_debug_default = 0;
guint32  gnet_property_variable_fileinfo_debug     = 0;
static const guint32  gnet_property_variable_fileinfo_debug_default = 0;
guint32  gnet_property_variable_upload_debug     = 0;
static const guint32  gnet_property_variable_upload_debug_default = 0;
guint32  gnet_property_variable_lib_debug     = 0;
static const guint32  gnet_property_variable_lib_debug_default = 0;
guint32  gnet_property_variable_bitzi_debug     = 0;
static const guint32  gnet_property_variable_bitzi_debug_default = 0;
guint32  gnet_property_variable_url_debug     = 0;
static const guint32  gnet_property_variable_url_debug_default = 0;
guint32  gnet_property_variable_dh_debug     = 0;
static const guint32  gnet_property_variable_dh_debug_default = 0;
guint32  gnet_property_variable_dq_debug     = 0;
static const guint32  gnet_property_variable_dq_debug_default = 0;
guint32  gnet_property_variable_vmsg_debug     = 0;
static const guint32  gnet_property_variable_vmsg_debug_default = 0;
guint32  gnet_property_variable_query_debug     = 0;
static const guint32  gnet_property_variable_query_debug_default = 0;
guint32  gnet_property_variable_search_debug     = 0;
static const guint32  gnet_property_variable_search_debug_default = 0;
guint32  gnet_property_variable_udp_debug     = 0;
static const guint32  gnet_property_variable_udp_debug_default = 0;
guint32  gnet_property_variable_qrp_debug     = 0;
static const guint32  gnet_property_variable_qrp_debug_default = 0;
guint32  gnet_property_variable_routing_debug     = 0;
static const guint32  gnet_property_variable_routing_debug_default = 0;
guint32  gnet_property_variable_ggep_debug     = 0;
static const guint32  gnet_property_variable_ggep_debug_default = 0;
guint32  gnet_property_variable_pcache_debug     = 0;
static const guint32  gnet_property_variable_pcache_debug_default = 0;
guint32  gnet_property_variable_hsep_debug     = 0;
static const guint32  gnet_property_variable_hsep_debug_default = 0;
guint32  gnet_property_variable_tls_debug     = 0;
static const guint32  gnet_property_variable_tls_debug_default = 0;
guint32  gnet_property_variable_parq_debug     = 0;
static const guint32  gnet_property_variable_parq_debug_default = 0;
gboolean gnet_property_variable_parq_optimistic     = TRUE;
static const gboolean gnet_property_variable_parq_optimistic_default = TRUE;
guint32  gnet_property_variable_parq_size_always_continue     = 8192;
static const guint32  gnet_property_variable_parq_size_always_continue_default = 8192;
guint32  gnet_property_variable_parq_time_always_continue     = 5;
static const guint32  gnet_property_variable_parq_time_always_continue_default = 5;
guint32  gnet_property_variable_parq_ban_bad_maxcountwait     = 10;
static const guint32  gnet_property_variable_parq_ban_bad_maxcountwait_default = 10;
guint32  gnet_property_variable_track_props     = 0;
static const guint32  gnet_property_variable_track_props_default = 0;
gboolean gnet_property_variable_stop_host_get     = FALSE;
static const gboolean gnet_property_variable_stop_host_get_default = FALSE;
gboolean gnet_property_variable_bws_in_enabled     = FALSE;
static const gboolean gnet_property_variable_bws_in_enabled_default = FALSE;
gboolean gnet_property_variable_bws_out_enabled     = FALSE;
static const gboolean gnet_property_variable_bws_out_enabled_default = FALSE;
gboolean gnet_property_variable_bws_gin_enabled     = FALSE;
static const gboolean gnet_property_variable_bws_gin_enabled_default = FALSE;
gboolean gnet_property_variable_bws_glin_enabled     = FALSE;
static const gboolean gnet_property_variable_bws_glin_enabled_default = FALSE;
gboolean gnet_property_variable_bws_gout_enabled     = FALSE;
static const gboolean gnet_property_variable_bws_gout_enabled_default = FALSE;
gboolean gnet_property_variable_bws_glout_enabled     = FALSE;
static const gboolean gnet_property_variable_bws_glout_enabled_default = FALSE;
gboolean gnet_property_variable_bw_ul_usage_enabled     = FALSE;
static const gboolean gnet_property_variable_bw_ul_usage_enabled_default = FALSE;
gboolean gnet_property_variable_bw_allow_stealing     = TRUE;
static const gboolean gnet_property_variable_bw_allow_stealing_default = TRUE;
gboolean gnet_property_variable_clear_complete_downloads     = TRUE;
static const gboolean gnet_property_variable_clear_complete_downloads_default = TRUE;
gboolean gnet_property_variable_clear_failed_downloads     = TRUE;
static const gboolean gnet_property_variable_clear_failed_downloads_default = TRUE;
gboolean gnet_property_variable_clear_unavailable_downloads     = TRUE;
static const gboolean gnet_property_variable_clear_unavailable_downloads_default = TRUE;
gboolean gnet_property_variable_clear_finished_downloads     = FALSE;
static const gboolean gnet_property_variable_clear_finished_downloads_default = FALSE;
gboolean gnet_property_variable_search_remove_downloaded     = FALSE;
static const gboolean gnet_property_variable_search_remove_downloaded_default = FALSE;
gboolean gnet_property_variable_force_local_ip     = FALSE;
static const gboolean gnet_property_variable_force_local_ip_default = FALSE;
gboolean gnet_property_variable_force_local_ip6     = FALSE;
static const gboolean gnet_property_variable_force_local_ip6_default = FALSE;
gboolean gnet_property_variable_bind_to_forced_local_ip     = FALSE;
static const gboolean gnet_property_variable_bind_to_forced_local_ip_default = FALSE;
gboolean gnet_property_variable_bind_to_forced_local_ip6     = FALSE;
static const gboolean gnet_property_variable_bind_to_forced_local_ip6_default = FALSE;
gboolean gnet_property_variable_use_netmasks     = FALSE;
static const gboolean gnet_property_variable_use_netmasks_default = FALSE;
gboolean gnet_property_variable_allow_private_network_connection     = FALSE;
static const gboolean gnet_property_variable_allow_private_network_connection_default = FALSE;
gboolean gnet_property_variable_use_ip_tos     = FALSE;
static const gboolean gnet_property_variable_use_ip_tos_default = FALSE;
gboolean gnet_property_variable_download_delete_aborted     = TRUE;
static const gboolean gnet_property_variable_download_delete_aborted_default = TRUE;
gboolean gnet_property_variable_proxy_auth     = FALSE;
static const gboolean gnet_property_variable_proxy_auth_default = FALSE;
char   *gnet_property_variable_socks_user     = "username";
static const char   *gnet_property_variable_socks_user_default = "username";
char   *gnet_property_variable_socks_pass     = "password";
static const char   *gnet_property_variable_socks_pass_default = "password";
host_addr_t  gnet_property_variable_proxy_addr;
char   *gnet_property_variable_proxy_hostname     = "";
static const char   *gnet_property_variable_proxy_hostname_default = "";
guint32  gnet_property_variable_proxy_port     = 0x0000;
static const guint32  gnet_property_variable_proxy_port_default = 0x0000;
guint32  gnet_property_variable_proxy_protocol     = PROXY_NONE;
static const guint32  gnet_property_variable_proxy_protocol_default = PROXY_NONE;
prop_def_choice_t gnet_property_variable_proxy_protocol_choices[] = { 
    {N_("No proxy"), PROXY_NONE},
    {N_("HTTP"), PROXY_HTTP},
    {N_("SOCKS v4"), PROXY_SOCKSV4},
    {N_("SOCKS v5"), PROXY_SOCKSV5},
    {NULL, 0}
};
guint32  gnet_property_variable_network_protocol     = NET_USE_BOTH;
static const guint32  gnet_property_variable_network_protocol_default = NET_USE_BOTH;
prop_def_choice_t gnet_property_variable_network_protocol_choices[] = { 
    {N_("IPv4 only"), NET_USE_IPV4},
    {N_("IPv6 only"), NET_USE_IPV6},
    {N_("IPv4 and IPv6"), NET_USE_BOTH},
    {NULL, 0}
};
gboolean gnet_property_variable_use_ipv6_trt     = FALSE;
static const gboolean gnet_property_variable_use_ipv6_trt_default = FALSE;
host_addr_t  gnet_property_variable_ipv6_trt_prefix;
guint32  gnet_property_variable_hosts_in_catcher     = 0;
static const guint32  gnet_property_variable_hosts_in_catcher_default = 0;
guint32  gnet_property_variable_hosts_in_ultra_catcher     = 0;
static const guint32  gnet_property_variable_hosts_in_ultra_catcher_default = 0;
guint32  gnet_property_variable_hosts_in_bad_catcher     = 0;
static const guint32  gnet_property_variable_hosts_in_bad_catcher_default = 0;
guint32  gnet_property_variable_max_hosts_cached     = 10000;
static const guint32  gnet_property_variable_max_hosts_cached_default = 10000;
guint32  gnet_property_variable_max_ultra_hosts_cached     = 10000;
static const guint32  gnet_property_variable_max_ultra_hosts_cached_default = 10000;
guint32  gnet_property_variable_max_bad_hosts_cached     = 8000;
static const guint32  gnet_property_variable_max_bad_hosts_cached_default = 8000;
guint32  gnet_property_variable_max_high_ttl_msg     = 10;
static const guint32  gnet_property_variable_max_high_ttl_msg_default = 10;
guint32  gnet_property_variable_max_high_ttl_radius     = 2;
static const guint32  gnet_property_variable_max_high_ttl_radius_default = 2;
guint32  gnet_property_variable_bw_http_in     = 8192;
static const guint32  gnet_property_variable_bw_http_in_default = 8192;
guint32  gnet_property_variable_bw_http_out     = 8192;
static const guint32  gnet_property_variable_bw_http_out_default = 8192;
guint32  gnet_property_variable_bw_gnet_in     = 8192;
static const guint32  gnet_property_variable_bw_gnet_in_default = 8192;
guint32  gnet_property_variable_bw_gnet_out     = 8192;
static const guint32  gnet_property_variable_bw_gnet_out_default = 8192;
guint32  gnet_property_variable_bw_gnet_lin     = 3072;
static const guint32  gnet_property_variable_bw_gnet_lin_default = 3072;
guint32  gnet_property_variable_bw_gnet_lout     = 2048;
static const guint32  gnet_property_variable_bw_gnet_lout_default = 2048;
guint32  gnet_property_variable_search_queries_forward_size     = 256;
static const guint32  gnet_property_variable_search_queries_forward_size_default = 256;
guint32  gnet_property_variable_search_queries_kick_size     = 1024;
static const guint32  gnet_property_variable_search_queries_kick_size_default = 1024;
guint32  gnet_property_variable_search_answers_forward_size     = 16384;
static const guint32  gnet_property_variable_search_answers_forward_size_default = 16384;
guint32  gnet_property_variable_search_answers_kick_size     = 65536;
static const guint32  gnet_property_variable_search_answers_kick_size_default = 65536;
guint32  gnet_property_variable_search_muid_track_amount     = 100000;
static const guint32  gnet_property_variable_search_muid_track_amount_default = 100000;
guint32  gnet_property_variable_other_messages_kick_size     = 40960;
static const guint32  gnet_property_variable_other_messages_kick_size_default = 40960;
guint32  gnet_property_variable_hops_random_factor     = 0;
static const guint32  gnet_property_variable_hops_random_factor_default = 0;
gboolean gnet_property_variable_send_pushes     = TRUE;
static const gboolean gnet_property_variable_send_pushes_default = TRUE;
guint32  gnet_property_variable_min_dup_msg     = 5;
static const guint32  gnet_property_variable_min_dup_msg_default = 5;
guint32  gnet_property_variable_min_dup_ratio     = 150;
static const guint32  gnet_property_variable_min_dup_ratio_default = 150;
char   *gnet_property_variable_scan_extensions     = "aac;avi;bin;bz2;7z;cue;dmg;deb;divx;flac;flc;fli;gif;gz;ifo;iso;it;jpeg;jpg;m4a;mjpg;mka;mkv;mod;mov;mp1;mp2;mp3;mp4;mpa;mpeg;mpega;mpg;mpv;nes;oga;ogg;ogm;ogv;qt;pdf;png;ps;ram;rar;rm;rom;rpm;s3m;shn;sid;smc;smd;spx;srt;stm;tar;tbz2;tgz;bittorrent;torrent;txt;vob;voc;vqf;wav;webm;xm;xvid;zip;zoo";
static const char   *gnet_property_variable_scan_extensions_default = "aac;avi;bin;bz2;7z;cue;dmg;deb;divx;flac;flc;fli;gif;gz;ifo;iso;it;jpeg;jpg;m4a;mjpg;mka;mkv;mod;mov;mp1;mp2;mp3;mp4;mpa;mpeg;mpega;mpg;mpv;nes;oga;ogg;ogm;ogv;qt;pdf;png;ps;ram;rar;rm;rom;rpm;s3m;shn;sid;smc;smd;spx;srt;stm;tar;tbz2;tgz;bittorrent;torrent;txt;vob;voc;vqf;wav;webm;xm;xvid;zip;zoo";
gboolean gnet_property_variable_scan_ignore_symlink_dirs     = FALSE;
static const gboolean gnet_property_variable_scan_ignore_symlink_dirs_default = FALSE;
gboolean gnet_property_variable_scan_ignore_symlink_regfiles     = FALSE;
static const gboolean gnet_property_variable_scan_ignore_symlink_regfiles_default = FALSE;
char   *gnet_property_variable_save_file_path     = "~/gtk-gnutella-downloads/incomplete";
static const char   *gnet_property_variable_save_file_path_default = "~/gtk-gnutella-downloads/incomplete";
char   *gnet_property_variable_move_file_path     = "~/gtk-gnutella-downloads/complete";
static const char   *gnet_property_variable_move_file_path_default = "~/gtk-gnutella-downloads/complete";
char   *gnet_property_variable_bad_file_path     = "~/gtk-gnutella-downloads/corrupt";
static const char   *gnet_property_variable_bad_file_path_default = "~/gtk-gnutella-downloads/corrupt";
char   *gnet_property_variable_shared_dirs_paths     = "";
static const char   *gnet_property_variable_shared_dirs_paths_default = "";
char   *gnet_property_variable_local_netmasks_string     = "";
static const char   *gnet_property_variable_local_netmasks_string_default = "";
guint32  gnet_property_variable_total_downloads     = 0;
static const guint32  gnet_property_variable_total_downloads_default = 0;
guint32  gnet_property_variable_ul_running     = 0;
static const guint32  gnet_property_variable_ul_running_default = 0;
guint32  gnet_property_variable_ul_quick_running     = 0;
static const guint32  gnet_property_variable_ul_quick_running_default = 0;
guint32  gnet_property_variable_ul_registered     = 0;
static const guint32  gnet_property_variable_ul_registered_default = 0;
guint32  gnet_property_variable_total_uploads     = 0;
static const guint32  gnet_property_variable_total_uploads_default = 0;
char   gnet_property_variable_servent_guid[GUID_RAW_SIZE];
static const char   gnet_property_variable_servent_guid_default[GUID_RAW_SIZE];

char   gnet_property_variable_kuid[KUID_RAW_SIZE];
static const char   gnet_property_variable_kuid_default[KUID_RAW_SIZE];

gboolean gnet_property_variable_use_swarming     = TRUE;
static const gboolean gnet_property_variable_use_swarming_default = TRUE;
gboolean gnet_property_variable_use_aggressive_swarming     = TRUE;
static const gboolean gnet_property_variable_use_aggressive_swarming_default = TRUE;
guint32  gnet_property_variable_dl_minchunksize     = 512*1024;
static const guint32  gnet_property_variable_dl_minchunksize_default = 512*1024;
guint32  gnet_property_variable_dl_maxchunksize     = 10*1024*1024;
static const guint32  gnet_property_variable_dl_maxchunksize_default = 10*1024*1024;
gboolean gnet_property_variable_auto_download_identical     = TRUE;
static const gboolean gnet_property_variable_auto_download_identical_default = TRUE;
gboolean gnet_property_variable_auto_feed_download_mesh     = TRUE;
static const gboolean gnet_property_variable_auto_feed_download_mesh_default = TRUE;
gboolean gnet_property_variable_strict_sha1_matching     = TRUE;
static const gboolean gnet_property_variable_strict_sha1_matching_default = TRUE;
gboolean gnet_property_variable_is_firewalled     = TRUE;
static const gboolean gnet_property_variable_is_firewalled_default = TRUE;
gboolean gnet_property_variable_is_inet_connected     = TRUE;
static const gboolean gnet_property_variable_is_inet_connected_default = TRUE;
gboolean gnet_property_variable_is_udp_firewalled     = TRUE;
static const gboolean gnet_property_variable_is_udp_firewalled_default = TRUE;
gboolean gnet_property_variable_recv_solicited_udp     = FALSE;
static const gboolean gnet_property_variable_recv_solicited_udp_default = FALSE;
gboolean gnet_property_variable_gnet_compact_query     = TRUE;
static const gboolean gnet_property_variable_gnet_compact_query_default = TRUE;
gboolean gnet_property_variable_download_optimistic_start     = FALSE;
static const gboolean gnet_property_variable_download_optimistic_start_default = FALSE;
gboolean gnet_property_variable_library_rebuilding     = FALSE;
static const gboolean gnet_property_variable_library_rebuilding_default = FALSE;
gboolean gnet_property_variable_sha1_rebuilding     = FALSE;
static const gboolean gnet_property_variable_sha1_rebuilding_default = FALSE;
gboolean gnet_property_variable_sha1_verifying     = FALSE;
static const gboolean gnet_property_variable_sha1_verifying_default = FALSE;
gboolean gnet_property_variable_file_moving     = FALSE;
static const gboolean gnet_property_variable_file_moving_default = FALSE;
gboolean gnet_property_variable_prefer_compressed_gnet     = TRUE;
static const gboolean gnet_property_variable_prefer_compressed_gnet_default = TRUE;
gboolean gnet_property_variable_online_mode     = TRUE;
static const gboolean gnet_property_variable_online_mode_default = TRUE;
gboolean gnet_property_variable_download_require_urn     = FALSE;
static const gboolean gnet_property_variable_download_require_urn_default = FALSE;
gboolean gnet_property_variable_download_require_server_name     = TRUE;
static const gboolean gnet_property_variable_download_require_server_name_default = TRUE;
guint32  gnet_property_variable_max_ultrapeers     = 4;
static const guint32  gnet_property_variable_max_ultrapeers_default = 4;
guint32  gnet_property_variable_quick_connect_pool_size     = 10;
static const guint32  gnet_property_variable_quick_connect_pool_size_default = 10;
guint32  gnet_property_variable_max_leaves     = 150;
static const guint32  gnet_property_variable_max_leaves_default = 150;
guint32  gnet_property_variable_search_handle_ignored_files     = 0;
static const guint32  gnet_property_variable_search_handle_ignored_files_default = 0;
prop_def_choice_t gnet_property_variable_search_handle_ignored_files_choices[] = { 
    {N_("displayed normally"), 0},
    {N_("displayed marked"), 1},
    {N_("not displayed"), 2},
    {NULL, 0}
};
guint32  gnet_property_variable_configured_peermode     = NODE_P_AUTO;
static const guint32  gnet_property_variable_configured_peermode_default = NODE_P_AUTO;
prop_def_choice_t gnet_property_variable_configured_peermode_choices[] = { 
    {N_("auto (recommended)"), NODE_P_AUTO},
    {N_("ultra node"), NODE_P_ULTRA},
    {N_("leaf node"), NODE_P_LEAF},
    {NULL, 0}
};
guint32  gnet_property_variable_current_peermode     = 0;
static const guint32  gnet_property_variable_current_peermode_default = 0;
prop_def_choice_t gnet_property_variable_current_peermode_choices[] = { 
    {N_("ultra node"), NODE_P_ULTRA},
    {N_("leaf node"), NODE_P_LEAF},
    {NULL, 0}
};
guint32  gnet_property_variable_sys_nofile     = 1024;
static const guint32  gnet_property_variable_sys_nofile_default = 1024;
guint64  gnet_property_variable_sys_physmem     = 65536;
static const guint64  gnet_property_variable_sys_physmem_default = 65536;
guint32  gnet_property_variable_dl_queue_count     = 0;
static const guint32  gnet_property_variable_dl_queue_count_default = 0;
guint32  gnet_property_variable_dl_running_count     = 0;
static const guint32  gnet_property_variable_dl_running_count_default = 0;
guint32  gnet_property_variable_dl_active_count     = 0;
static const guint32  gnet_property_variable_dl_active_count_default = 0;
guint32  gnet_property_variable_dl_aqueued_count     = 0;
static const guint32  gnet_property_variable_dl_aqueued_count_default = 0;
guint32  gnet_property_variable_dl_pqueued_count     = 0;
static const guint32  gnet_property_variable_dl_pqueued_count_default = 0;
guint32  gnet_property_variable_fi_all_count     = 0;
static const guint32  gnet_property_variable_fi_all_count_default = 0;
guint32  gnet_property_variable_fi_with_source_count     = 0;
static const guint32  gnet_property_variable_fi_with_source_count_default = 0;
guint32  gnet_property_variable_dl_qalive_count     = 0;
static const guint32  gnet_property_variable_dl_qalive_count_default = 0;
guint64  gnet_property_variable_dl_byte_count     = 0;
static const guint64  gnet_property_variable_dl_byte_count_default = 0;
guint64  gnet_property_variable_ul_byte_count     = 0;
static const guint64  gnet_property_variable_ul_byte_count_default = 0;
gboolean gnet_property_variable_pfsp_server     = TRUE;
static const gboolean gnet_property_variable_pfsp_server_default = TRUE;
guint32  gnet_property_variable_pfsp_first_chunk     = 524288;
static const guint32  gnet_property_variable_pfsp_first_chunk_default = 524288;
guint32  gnet_property_variable_pfsp_minimum_filesize     = 1048576;
static const guint32  gnet_property_variable_pfsp_minimum_filesize_default = 1048576;
guint32  gnet_property_variable_crawler_visit_count     = 0;
static const guint32  gnet_property_variable_crawler_visit_count_default = 0;
guint32  gnet_property_variable_udp_crawler_visit_count     = 0;
static const guint32  gnet_property_variable_udp_crawler_visit_count_default = 0;
gboolean gnet_property_variable_host_runs_ntp     = FALSE;
static const gboolean gnet_property_variable_host_runs_ntp_default = FALSE;
gboolean gnet_property_variable_ntp_detected     = FALSE;
static const gboolean gnet_property_variable_ntp_detected_default = FALSE;
guint32  gnet_property_variable_clock_skew     = 0;
static const guint32  gnet_property_variable_clock_skew_default = 0;
gboolean gnet_property_variable_node_monitor_unstable_ip     = FALSE;
static const gboolean gnet_property_variable_node_monitor_unstable_ip_default = FALSE;
gboolean gnet_property_variable_node_monitor_unstable_servents     = FALSE;
static const gboolean gnet_property_variable_node_monitor_unstable_servents_default = FALSE;
gboolean gnet_property_variable_dl_remove_file_on_mismatch     = FALSE;
static const gboolean gnet_property_variable_dl_remove_file_on_mismatch_default = FALSE;
guint32  gnet_property_variable_dl_mismatch_backout     = 50000;
static const guint32  gnet_property_variable_dl_mismatch_backout_default = 50000;
char   *gnet_property_variable_server_hostname     = "";
static const char   *gnet_property_variable_server_hostname_default = "";
gboolean gnet_property_variable_give_server_hostname     = FALSE;
static const gboolean gnet_property_variable_give_server_hostname_default = FALSE;
guint32  gnet_property_variable_reserve_gtkg_nodes     = 0;
static const guint32  gnet_property_variable_reserve_gtkg_nodes_default = 0;
guint32  gnet_property_variable_unique_nodes     = 100;
static const guint32  gnet_property_variable_unique_nodes_default = 100;
guint32  gnet_property_variable_download_rx_size     = 64;
static const guint32  gnet_property_variable_download_rx_size_default = 64;
guint32  gnet_property_variable_node_rx_size     = 16;
static const guint32  gnet_property_variable_node_rx_size_default = 16;
guint32  gnet_property_variable_upload_tx_size     = 64;
static const guint32  gnet_property_variable_upload_tx_size_default = 64;
guint32  gnet_property_variable_dl_http_latency     = 0;
static const guint32  gnet_property_variable_dl_http_latency_default = 0;
time_t  gnet_property_variable_node_last_ultra_check     = 0;
static const time_t  gnet_property_variable_node_last_ultra_check_default = 0;
time_t  gnet_property_variable_node_last_ultra_leaf_switch     = 0;
static const time_t  gnet_property_variable_node_last_ultra_leaf_switch_default = 0;
gboolean gnet_property_variable_up_req_avg_servent_uptime     = FALSE;
static const gboolean gnet_property_variable_up_req_avg_servent_uptime_default = FALSE;
gboolean gnet_property_variable_up_req_avg_ip_uptime     = FALSE;
static const gboolean gnet_property_variable_up_req_avg_ip_uptime_default = FALSE;
gboolean gnet_property_variable_up_req_node_uptime     = FALSE;
static const gboolean gnet_property_variable_up_req_node_uptime_default = FALSE;
gboolean gnet_property_variable_up_req_not_firewalled     = FALSE;
static const gboolean gnet_property_variable_up_req_not_firewalled_default = FALSE;
gboolean gnet_property_variable_up_req_enough_conn     = FALSE;
static const gboolean gnet_property_variable_up_req_enough_conn_default = FALSE;
gboolean gnet_property_variable_up_req_enough_fd     = FALSE;
static const gboolean gnet_property_variable_up_req_enough_fd_default = FALSE;
gboolean gnet_property_variable_up_req_enough_mem     = FALSE;
static const gboolean gnet_property_variable_up_req_enough_mem_default = FALSE;
gboolean gnet_property_variable_up_req_enough_bw     = FALSE;
static const gboolean gnet_property_variable_up_req_enough_bw_default = FALSE;
gboolean gnet_property_variable_up_req_good_udp     = FALSE;
static const gboolean gnet_property_variable_up_req_good_udp_default = FALSE;
guint32  gnet_property_variable_search_queue_size     = 256;
static const guint32  gnet_property_variable_search_queue_size_default = 256;
guint32  gnet_property_variable_search_queue_spacing     = 10;
static const guint32  gnet_property_variable_search_queue_spacing_default = 10;
gboolean gnet_property_variable_enable_shell     = FALSE;
static const gboolean gnet_property_variable_enable_shell_default = FALSE;
guint32  gnet_property_variable_remote_shell_timeout     = 180;
static const guint32  gnet_property_variable_remote_shell_timeout_default = 180;
guint32  gnet_property_variable_entry_removal_timeout     = 5;
static const guint32  gnet_property_variable_entry_removal_timeout_default = 5;
gboolean gnet_property_variable_node_watch_similar_queries     = TRUE;
static const gboolean gnet_property_variable_node_watch_similar_queries_default = TRUE;
guint32  gnet_property_variable_node_queries_half_life     = 5;
static const guint32  gnet_property_variable_node_queries_half_life_default = 5;
guint32  gnet_property_variable_node_requery_threshold     = 1700;
static const guint32  gnet_property_variable_node_requery_threshold_default = 1700;
time_t  gnet_property_variable_library_rescan_started     = 0;
static const time_t  gnet_property_variable_library_rescan_started_default = 0;
time_t  gnet_property_variable_library_rescan_finished     = 0;
static const time_t  gnet_property_variable_library_rescan_finished_default = 0;
guint32  gnet_property_variable_library_rescan_duration     = 0;
static const guint32  gnet_property_variable_library_rescan_duration_default = 0;
time_t  gnet_property_variable_qrp_indexing_started     = 0;
static const time_t  gnet_property_variable_qrp_indexing_started_default = 0;
guint32  gnet_property_variable_qrp_indexing_duration     = 0;
static const guint32  gnet_property_variable_qrp_indexing_duration_default = 0;
guint32  gnet_property_variable_qrp_memory     = 0;
static const guint32  gnet_property_variable_qrp_memory_default = 0;
time_t  gnet_property_variable_qrp_timestamp     = 0;
static const time_t  gnet_property_variable_qrp_timestamp_default = 0;
guint32  gnet_property_variable_qrp_computation_time     = 0;
static const guint32  gnet_property_variable_qrp_computation_time_default = 0;
time_t  gnet_property_variable_qrp_patch_timestamp     = 0;
static const time_t  gnet_property_variable_qrp_patch_timestamp_default = 0;
guint32  gnet_property_variable_qrp_patch_computation_time     = 0;
static const guint32  gnet_property_variable_qrp_patch_computation_time_default = 0;
guint32  gnet_property_variable_qrp_generation     = 0;
static const guint32  gnet_property_variable_qrp_generation_default = 0;
guint32  gnet_property_variable_qrp_slots     = 0;
static const guint32  gnet_property_variable_qrp_slots_default = 0;
guint32  gnet_property_variable_qrp_slots_filled     = 0;
static const guint32  gnet_property_variable_qrp_slots_filled_default = 0;
guint32  gnet_property_variable_qrp_fill_ratio     = 0;
static const guint32  gnet_property_variable_qrp_fill_ratio_default = 0;
guint32  gnet_property_variable_qrp_conflict_ratio     = 0;
static const guint32  gnet_property_variable_qrp_conflict_ratio_default = 0;
guint32  gnet_property_variable_qrp_hashed_keywords     = 0;
static const guint32  gnet_property_variable_qrp_hashed_keywords_default = 0;
guint32  gnet_property_variable_qrp_patch_raw_length     = 0;
static const guint32  gnet_property_variable_qrp_patch_raw_length_default = 0;
guint32  gnet_property_variable_qrp_patch_length     = 0;
static const guint32  gnet_property_variable_qrp_patch_length_default = 0;
guint32  gnet_property_variable_qrp_patch_comp_ratio     = 0;
static const guint32  gnet_property_variable_qrp_patch_comp_ratio_default = 0;
guint32  gnet_property_variable_ancient_version_left_days     = 365;
static const guint32  gnet_property_variable_ancient_version_left_days_default = 365;
gboolean gnet_property_variable_file_descriptor_shortage     = FALSE;
static const gboolean gnet_property_variable_file_descriptor_shortage_default = FALSE;
gboolean gnet_property_variable_file_descriptor_runout     = FALSE;
static const gboolean gnet_property_variable_file_descriptor_runout_default = FALSE;
gboolean gnet_property_variable_convert_spaces     = FALSE;
static const gboolean gnet_property_variable_convert_spaces_default = FALSE;
gboolean gnet_property_variable_convert_evil_chars     = TRUE;
static const gboolean gnet_property_variable_convert_evil_chars_default = TRUE;
gboolean gnet_property_variable_convert_old_filenames     = FALSE;
static const gboolean gnet_property_variable_convert_old_filenames_default = FALSE;
gboolean gnet_property_variable_tls_enforce     = FALSE;
static const gboolean gnet_property_variable_tls_enforce_default = FALSE;
gboolean gnet_property_variable_gnet_deflate_enabled     = TRUE;
static const gboolean gnet_property_variable_gnet_deflate_enabled_default = TRUE;
gboolean gnet_property_variable_enable_udp     = TRUE;
static const gboolean gnet_property_variable_enable_udp_default = TRUE;
gboolean gnet_property_variable_process_oob_queries     = TRUE;
static const gboolean gnet_property_variable_process_oob_queries_default = TRUE;
gboolean gnet_property_variable_send_oob_queries     = TRUE;
static const gboolean gnet_property_variable_send_oob_queries_default = TRUE;
gboolean gnet_property_variable_proxy_oob_queries     = TRUE;
static const gboolean gnet_property_variable_proxy_oob_queries_default = TRUE;
gboolean gnet_property_variable_uploads_stalling     = FALSE;
static const gboolean gnet_property_variable_uploads_stalling_default = FALSE;
gboolean gnet_property_variable_use_global_hostiles_txt     = TRUE;
static const gboolean gnet_property_variable_use_global_hostiles_txt_default = TRUE;
gboolean gnet_property_variable_use_so_linger     = FALSE;
static const gboolean gnet_property_variable_use_so_linger_default = FALSE;
guint32  gnet_property_variable_tcp_defer_accept_timeout     = 10;
static const guint32  gnet_property_variable_tcp_defer_accept_timeout_default = 10;
gboolean gnet_property_variable_browse_host_enabled     = FALSE;
static const gboolean gnet_property_variable_browse_host_enabled_default = FALSE;
guint32  gnet_property_variable_html_browse_count     = 0;
static const guint32  gnet_property_variable_html_browse_count_default = 0;
guint32  gnet_property_variable_html_browse_served     = 0;
static const guint32  gnet_property_variable_html_browse_served_default = 0;
guint32  gnet_property_variable_qhits_browse_count     = 0;
static const guint32  gnet_property_variable_qhits_browse_count_default = 0;
guint32  gnet_property_variable_qhits_browse_served     = 0;
static const guint32  gnet_property_variable_qhits_browse_served_default = 0;
gboolean gnet_property_variable_overloaded_cpu     = FALSE;
static const gboolean gnet_property_variable_overloaded_cpu_default = FALSE;
guint32  gnet_property_variable_download_buffer_size     = 131072;
static const guint32  gnet_property_variable_download_buffer_size_default = 131072;
gboolean gnet_property_variable_browse_copied_to_passive     = FALSE;
static const gboolean gnet_property_variable_browse_copied_to_passive_default = FALSE;
gboolean gnet_property_variable_display_metric_units     = FALSE;
static const gboolean gnet_property_variable_display_metric_units_default = FALSE;
guint32  gnet_property_variable_rudp_debug     = 0;
static const guint32  gnet_property_variable_rudp_debug_default = 0;
guint32  gnet_property_variable_dht_debug     = 0;
static const guint32  gnet_property_variable_dht_debug_default = 0;
guint32  gnet_property_variable_oob_proxy_debug     = 0;
static const guint32  gnet_property_variable_oob_proxy_debug_default = 0;
gboolean gnet_property_variable_enable_local_socket     = TRUE;
static const gboolean gnet_property_variable_enable_local_socket_default = TRUE;
guint32  gnet_property_variable_max_simultaneous_downloads_per_file     = 40;
static const guint32  gnet_property_variable_max_simultaneous_downloads_per_file_default = 40;
gboolean gnet_property_variable_dump_received_gnutella_packets     = FALSE;
static const gboolean gnet_property_variable_dump_received_gnutella_packets_default = FALSE;
gboolean gnet_property_variable_search_results_expose_relative_paths     = FALSE;
static const gboolean gnet_property_variable_search_results_expose_relative_paths_default = FALSE;
guint32  gnet_property_variable_shell_debug     = 0;
static const guint32  gnet_property_variable_shell_debug_default = 0;
guint32  gnet_property_variable_download_queue_frozen     = 0;
static const guint32  gnet_property_variable_download_queue_frozen_default = 0;
guint32  gnet_property_variable_sq_debug     = 0;
static const guint32  gnet_property_variable_sq_debug_default = 0;
guint32  gnet_property_variable_push_proxy_debug     = 0;
static const guint32  gnet_property_variable_push_proxy_debug_default = 0;
guint32  gnet_property_variable_thex_files_requested     = 0;
static const guint32  gnet_property_variable_thex_files_requested_default = 0;
guint32  gnet_property_variable_thex_files_served     = 0;
static const guint32  gnet_property_variable_thex_files_served_default = 0;
guint32  gnet_property_variable_tigertree_debug     = 0;
static const guint32  gnet_property_variable_tigertree_debug_default = 0;
gboolean gnet_property_variable_tth_rebuilding     = FALSE;
static const gboolean gnet_property_variable_tth_rebuilding_default = FALSE;
gboolean gnet_property_variable_tth_verifying     = FALSE;
static const gboolean gnet_property_variable_tth_verifying_default = FALSE;
guint32  gnet_property_variable_search_max_results     = 1000;
static const guint32  gnet_property_variable_search_max_results_default = 1000;
guint32  gnet_property_variable_browse_host_max_results     = 10000;
static const guint32  gnet_property_variable_browse_host_max_results_default = 10000;
time_t  gnet_property_variable_latest_svn_release_date     = 0;
static const time_t  gnet_property_variable_latest_svn_release_date_default = 0;
guint32  gnet_property_variable_latest_svn_release_revision     = 0;
static const guint32  gnet_property_variable_latest_svn_release_revision_default = 0;
char   *gnet_property_variable_latest_svn_release_signature     = "";
static const char   *gnet_property_variable_latest_svn_release_signature_default = "";
guint32  gnet_property_variable_tls_cache_max_hosts     = 10000;
static const guint32  gnet_property_variable_tls_cache_max_hosts_default = 10000;
guint32  gnet_property_variable_tls_cache_max_time     = 43200;
static const guint32  gnet_property_variable_tls_cache_max_time_default = 43200;
gboolean gnet_property_variable_tth_auto_discovery     = TRUE;
static const gboolean gnet_property_variable_tth_auto_discovery_default = TRUE;
gboolean gnet_property_variable_enable_hackarounds     = TRUE;
static const gboolean gnet_property_variable_enable_hackarounds_default = TRUE;
guint32  gnet_property_variable_g2_cache_max_hosts     = 10000;
static const guint32  gnet_property_variable_g2_cache_max_hosts_default = 10000;
guint32  gnet_property_variable_g2_cache_max_time     = 43200;
static const guint32  gnet_property_variable_g2_cache_max_time_default = 43200;
guint32  gnet_property_variable_g2_debug     = 0;
static const guint32  gnet_property_variable_g2_debug_default = 0;
gboolean gnet_property_variable_dl_resource_switching     = TRUE;
static const gboolean gnet_property_variable_dl_resource_switching_default = TRUE;
gboolean gnet_property_variable_parq_enabled     = TRUE;
static const gboolean gnet_property_variable_parq_enabled_default = TRUE;
guint32  gnet_property_variable_pfsp_last_chunk     = 524288;
static const guint32  gnet_property_variable_pfsp_last_chunk_default = 524288;
gboolean gnet_property_variable_beautify_filenames     = FALSE;
static const gboolean gnet_property_variable_beautify_filenames_default = FALSE;
gboolean gnet_property_variable_enable_dht     = TRUE;
static const gboolean gnet_property_variable_enable_dht_default = TRUE;
guint32  gnet_property_variable_cq_debug     = 0;
static const guint32  gnet_property_variable_cq_debug_default = 0;
guint32  gnet_property_variable_dht_lookup_debug     = 0;
static const guint32  gnet_property_variable_dht_lookup_debug_default = 0;
guint32  gnet_property_variable_dht_storage_debug     = 0;
static const guint32  gnet_property_variable_dht_storage_debug_default = 0;
guint32  gnet_property_variable_dht_publish_debug     = 0;
static const guint32  gnet_property_variable_dht_publish_debug_default = 0;
guint32  gnet_property_variable_bw_dht_lookup_out     = 2048;
static const guint32  gnet_property_variable_bw_dht_lookup_out_default = 2048;
guint32  gnet_property_variable_bw_dht_lookup_in     = 8192;
static const guint32  gnet_property_variable_bw_dht_lookup_in_default = 8192;
gboolean gnet_property_variable_sticky_guid     = TRUE;
static const gboolean gnet_property_variable_sticky_guid_default = TRUE;
gboolean gnet_property_variable_sticky_kuid     = TRUE;
static const gboolean gnet_property_variable_sticky_kuid_default = TRUE;
guint32  gnet_property_variable_dht_ulq_debug     = 0;
static const guint32  gnet_property_variable_dht_ulq_debug_default = 0;
gboolean gnet_property_variable_dht_storage_in_memory     = FALSE;
static const gboolean gnet_property_variable_dht_storage_in_memory_default = FALSE;
guint32  gnet_property_variable_download_trace     = SOCK_TRACE_NONE;
static const guint32  gnet_property_variable_download_trace_default = SOCK_TRACE_NONE;
prop_def_choice_t gnet_property_variable_download_trace_choices[] = { 
    {N_("none"), SOCK_TRACE_NONE},
    {N_("input only"), SOCK_TRACE_IN},
    {N_("output only"), SOCK_TRACE_OUT},
    {N_("input & output"), SOCK_TRACE_BOTH},
    {NULL, 0}
};
guint32  gnet_property_variable_upload_trace     = SOCK_TRACE_NONE;
static const guint32  gnet_property_variable_upload_trace_default = SOCK_TRACE_NONE;
prop_def_choice_t gnet_property_variable_upload_trace_choices[] = { 
    {N_("none"), SOCK_TRACE_NONE},
    {N_("input only"), SOCK_TRACE_IN},
    {N_("output only"), SOCK_TRACE_OUT},
    {N_("input & output"), SOCK_TRACE_BOTH},
    {NULL, 0}
};
guint32  gnet_property_variable_gnet_trace     = SOCK_TRACE_NONE;
static const guint32  gnet_property_variable_gnet_trace_default = SOCK_TRACE_NONE;
prop_def_choice_t gnet_property_variable_gnet_trace_choices[] = { 
    {N_("none"), SOCK_TRACE_NONE},
    {N_("input only"), SOCK_TRACE_IN},
    {N_("output only"), SOCK_TRACE_OUT},
    {N_("input & output"), SOCK_TRACE_BOTH},
    {NULL, 0}
};
guint32  gnet_property_variable_push_proxy_trace     = SOCK_TRACE_NONE;
static const guint32  gnet_property_variable_push_proxy_trace_default = SOCK_TRACE_NONE;
prop_def_choice_t gnet_property_variable_push_proxy_trace_choices[] = { 
    {N_("none"), SOCK_TRACE_NONE},
    {N_("input only"), SOCK_TRACE_IN},
    {N_("output only"), SOCK_TRACE_OUT},
    {N_("input & output"), SOCK_TRACE_BOTH},
    {NULL, 0}
};
guint32  gnet_property_variable_http_trace     = SOCK_TRACE_NONE;
static const guint32  gnet_property_variable_http_trace_default = SOCK_TRACE_NONE;
prop_def_choice_t gnet_property_variable_http_trace_choices[] = { 
    {N_("none"), SOCK_TRACE_NONE},
    {N_("input only"), SOCK_TRACE_IN},
    {N_("output only"), SOCK_TRACE_OUT},
    {N_("input & output"), SOCK_TRACE_BOTH},
    {NULL, 0}
};
guint32  gnet_property_variable_verify_debug     = 0;
static const guint32  gnet_property_variable_verify_debug_default = 0;
guint32  gnet_property_variable_local_addr_cache_max_hosts     = 100;
static const guint32  gnet_property_variable_local_addr_cache_max_hosts_default = 100;
guint32  gnet_property_variable_local_addr_cache_max_time     = 604800;
static const guint32  gnet_property_variable_local_addr_cache_max_time_default = 604800;
guint32  gnet_property_variable_local_addr_debug     = 0;
static const guint32  gnet_property_variable_local_addr_debug_default = 0;
gboolean gnet_property_variable_dump_transmitted_gnutella_packets     = FALSE;
static const gboolean gnet_property_variable_dump_transmitted_gnutella_packets_default = FALSE;
guint32  gnet_property_variable_mq_tcp_debug     = 0;
static const guint32  gnet_property_variable_mq_tcp_debug_default = 0;
guint32  gnet_property_variable_mq_udp_debug     = 0;
static const guint32  gnet_property_variable_mq_udp_debug_default = 0;
guint32  gnet_property_variable_node_udp_sendqueue_size     = 98304;
static const guint32  gnet_property_variable_node_udp_sendqueue_size_default = 98304;
guint32  gnet_property_variable_clock_debug     = 0;
static const guint32  gnet_property_variable_clock_debug_default = 0;
guint32  gnet_property_variable_fw_debug     = 0;
static const guint32  gnet_property_variable_fw_debug_default = 0;
guint32  gnet_property_variable_host_debug     = 0;
static const guint32  gnet_property_variable_host_debug_default = 0;
guint32  gnet_property_variable_dht_roots_debug     = 0;
static const guint32  gnet_property_variable_dht_roots_debug_default = 0;
guint32  gnet_property_variable_lib_stats     = 0;
static const guint32  gnet_property_variable_lib_stats_default = 0;
gboolean gnet_property_variable_spam_lut_in_memory     = TRUE;
static const gboolean gnet_property_variable_spam_lut_in_memory_default = TRUE;
guint32  gnet_property_variable_spam_debug     = 0;
static const guint32  gnet_property_variable_spam_debug_default = 0;
guint32  gnet_property_variable_lockfile_debug     = 0;
static const guint32  gnet_property_variable_lockfile_debug_default = 0;
guint32  gnet_property_variable_zalloc_debug     = 0;
static const guint32  gnet_property_variable_zalloc_debug_default = 0;
guint32  gnet_property_variable_palloc_debug     = 0;
static const guint32  gnet_property_variable_palloc_debug_default = 0;
guint32  gnet_property_variable_rxbuf_debug     = 0;
static const guint32  gnet_property_variable_rxbuf_debug_default = 0;
gboolean gnet_property_variable_zalloc_always_gc     = FALSE;
static const gboolean gnet_property_variable_zalloc_always_gc_default = FALSE;
guint32  gnet_property_variable_vmm_debug     = 0;
static const guint32  gnet_property_variable_vmm_debug_default = 0;
guint32  gnet_property_variable_shutdown_debug     = 0;
static const guint32  gnet_property_variable_shutdown_debug_default = 0;
char   *gnet_property_variable_country_limits     = "";
static const char   *gnet_property_variable_country_limits_default = "";
guint32  gnet_property_variable_ctl_debug     = 0;
static const guint32  gnet_property_variable_ctl_debug_default = 0;
gboolean gnet_property_variable_log_dropped_gnutella     = FALSE;
static const gboolean gnet_property_variable_log_dropped_gnutella_default = FALSE;
guint32  gnet_property_variable_whitelist_debug     = 0;
static const guint32  gnet_property_variable_whitelist_debug_default = 0;
guint32  gnet_property_variable_dht_tcache_debug     = 0;
static const guint32  gnet_property_variable_dht_tcache_debug_default = 0;
guint32  gnet_property_variable_publisher_debug     = 0;
static const guint32  gnet_property_variable_publisher_debug_default = 0;
guint32  gnet_property_variable_dht_trace     = SOCK_TRACE_NONE;
static const guint32  gnet_property_variable_dht_trace_default = SOCK_TRACE_NONE;
prop_def_choice_t gnet_property_variable_dht_trace_choices[] = { 
    {N_("none"), SOCK_TRACE_NONE},
    {N_("input only"), SOCK_TRACE_IN},
    {N_("output only"), SOCK_TRACE_OUT},
    {N_("input & output"), SOCK_TRACE_BOTH},
    {NULL, 0}
};
gboolean gnet_property_variable_bws_dht_out_enabled     = FALSE;
static const gboolean gnet_property_variable_bws_dht_out_enabled_default = FALSE;
guint32  gnet_property_variable_bw_dht_out     = 12288;
static const guint32  gnet_property_variable_bw_dht_out_default = 12288;
guint32  gnet_property_variable_node_dht_sendqueue_size     = 131072;
static const guint32  gnet_property_variable_node_dht_sendqueue_size_default = 131072;
guint32  gnet_property_variable_bsched_debug     = 0;
static const guint32  gnet_property_variable_bsched_debug_default = 0;
guint32  gnet_property_variable_dht_stable_debug     = 0;
static const guint32  gnet_property_variable_dht_stable_debug_default = 0;
guint32  gnet_property_variable_reload_debug     = 0;
static const guint32  gnet_property_variable_reload_debug_default = 0;
guint32  gnet_property_variable_move_debug     = 0;
static const guint32  gnet_property_variable_move_debug_default = 0;
guint32  gnet_property_variable_qhit_debug     = 0;
static const guint32  gnet_property_variable_qhit_debug_default = 0;
guint32  gnet_property_variable_version_debug     = 0;
static const guint32  gnet_property_variable_version_debug_default = 0;
guint64  gnet_property_variable_cpu_freq_min     = 0;
static const guint64  gnet_property_variable_cpu_freq_min_default = 0;
guint64  gnet_property_variable_cpu_freq_max     = 0;
static const guint64  gnet_property_variable_cpu_freq_max_default = 0;
guint32  gnet_property_variable_dht_boot_status     = 0;
static const guint32  gnet_property_variable_dht_boot_status_default = 0;
prop_def_choice_t gnet_property_variable_dht_boot_status_choices[] = { 
    {N_("none"), DHT_BOOT_NONE},
    {N_("seeded"), DHT_BOOT_SEEDED},
    {N_("own KUID lookup"), DHT_BOOT_OWN},
    {N_("completing"), DHT_BOOT_COMPLETING},
    {N_("completed"), DHT_BOOT_COMPLETED},
    {N_("shutdown"), DHT_BOOT_SHUTDOWN},
    {NULL, 0}
};
guint32  gnet_property_variable_dht_configured_mode     = 1;
static const guint32  gnet_property_variable_dht_configured_mode_default = 1;
prop_def_choice_t gnet_property_variable_dht_configured_mode_choices[] = { 
    {N_("active (recommended)"), DHT_MODE_ACTIVE},
    {N_("passive"), DHT_MODE_PASSIVE},
    {NULL, 0}
};
guint32  gnet_property_variable_dht_current_mode     = 1;
static const guint32  gnet_property_variable_dht_current_mode_default = 1;
prop_def_choice_t gnet_property_variable_dht_current_mode_choices[] = { 
    {N_("active (recommended)"), DHT_MODE_ACTIVE},
    {N_("passive"), DHT_MODE_PASSIVE},
    {NULL, 0}
};
guint32  gnet_property_variable_omalloc_debug     = 0;
static const guint32  gnet_property_variable_omalloc_debug_default = 0;
guint32  gnet_property_variable_hcache_debug     = 0;
static const guint32  gnet_property_variable_hcache_debug_default = 0;
char   gnet_property_variable_randomness[KUID_RAW_SIZE];
static const char   gnet_property_variable_randomness_default[KUID_RAW_SIZE];

guint32  gnet_property_variable_average_servent_downtime     = 0;
static const guint32  gnet_property_variable_average_servent_downtime_default = 0;
time_t  gnet_property_variable_shutdown_time     = 0;
static const time_t  gnet_property_variable_shutdown_time_default = 0;
guint32  gnet_property_variable_alive_debug     = 0;
static const guint32  gnet_property_variable_alive_debug_default = 0;
guint32  gnet_property_variable_vxml_debug     = 0;
static const guint32  gnet_property_variable_vxml_debug_default = 0;
guint32  gnet_property_variable_upnp_debug     = 0;
static const guint32  gnet_property_variable_upnp_debug_default = 0;
guint32  gnet_property_variable_soap_debug     = 0;
static const guint32  gnet_property_variable_soap_debug_default = 0;
guint32  gnet_property_variable_soap_trace     = SOCK_TRACE_NONE;
static const guint32  gnet_property_variable_soap_trace_default = SOCK_TRACE_NONE;
prop_def_choice_t gnet_property_variable_soap_trace_choices[] = { 
    {N_("none"), SOCK_TRACE_NONE},
    {N_("input only"), SOCK_TRACE_IN},
    {N_("output only"), SOCK_TRACE_OUT},
    {N_("input & output"), SOCK_TRACE_BOTH},
    {NULL, 0}
};
gboolean gnet_property_variable_allow_firewalled_ultra     = FALSE;
static const gboolean gnet_property_variable_allow_firewalled_ultra_default = FALSE;
gboolean gnet_property_variable_enable_upnp     = TRUE;
static const gboolean gnet_property_variable_enable_upnp_default = TRUE;
gboolean gnet_property_variable_upnp_possible     = FALSE;
static const gboolean gnet_property_variable_upnp_possible_default = FALSE;
gboolean gnet_property_variable_port_mapping_required     = TRUE;
static const gboolean gnet_property_variable_port_mapping_required_default = TRUE;
gboolean gnet_property_variable_port_mapping_possible     = FALSE;
static const gboolean gnet_property_variable_port_mapping_possible_default = FALSE;
guint32  gnet_property_variable_natpmp_debug     = 0;
static const guint32  gnet_property_variable_natpmp_debug_default = 0;
gboolean gnet_property_variable_enable_natpmp     = TRUE;
static const gboolean gnet_property_variable_enable_natpmp_default = TRUE;
gboolean gnet_property_variable_natpmp_possible     = FALSE;
static const gboolean gnet_property_variable_natpmp_possible_default = FALSE;
guint32  gnet_property_variable_tx_debug     = 0;
static const guint32  gnet_property_variable_tx_debug_default = 0;
guint32  gnet_property_variable_rx_debug     = 0;
static const guint32  gnet_property_variable_rx_debug_default = 0;
guint32  gnet_property_variable_inputevt_debug     = 0;
static const guint32  gnet_property_variable_inputevt_debug_default = 0;
guint32  gnet_property_variable_bg_debug     = 0;
static const guint32  gnet_property_variable_bg_debug_default = 0;
gboolean gnet_property_variable_port_mapping_successful     = FALSE;
static const gboolean gnet_property_variable_port_mapping_successful_default = FALSE;
gboolean gnet_property_variable_uploads_bw_no_stealing     = FALSE;
static const gboolean gnet_property_variable_uploads_bw_no_stealing_default = FALSE;
gboolean gnet_property_variable_uploads_bw_ignore_stolen     = FALSE;
static const gboolean gnet_property_variable_uploads_bw_ignore_stolen_default = FALSE;
gboolean gnet_property_variable_uploads_bw_uniform     = FALSE;
static const gboolean gnet_property_variable_uploads_bw_uniform_default = FALSE;
gboolean gnet_property_variable_enable_http_pipelining     = TRUE;
static const gboolean gnet_property_variable_enable_http_pipelining_default = TRUE;
guint32  gnet_property_variable_dl_pipeline_maxchunksize     = 1*1024*1024;
static const guint32  gnet_property_variable_dl_pipeline_maxchunksize_default = 1*1024*1024;
gboolean gnet_property_variable_enable_guess     = TRUE;
static const gboolean gnet_property_variable_enable_guess_default = TRUE;
guint32  gnet_property_variable_guess_server_debug     = 0;
static const guint32  gnet_property_variable_guess_server_debug_default = 0;
guint32  gnet_property_variable_guess_client_debug     = 0;
static const guint32  gnet_property_variable_guess_client_debug_default = 0;
guint32  gnet_property_variable_max_guess_hosts_cached     = 1000;
static const guint32  gnet_property_variable_max_guess_hosts_cached_default = 1000;
guint32  gnet_property_variable_hosts_in_guess_catcher     = 0;
static const guint32  gnet_property_variable_hosts_in_guess_catcher_default = 0;
guint32  gnet_property_variable_max_guess_intro_hosts_cached     = 5000;
static const guint32  gnet_property_variable_max_guess_intro_hosts_cached_default = 5000;
guint32  gnet_property_variable_hosts_in_guess_intro_catcher     = 0;
static const guint32  gnet_property_variable_hosts_in_guess_intro_catcher_default = 0;
guint32  gnet_property_variable_dbstore_debug     = 0;
static const guint32  gnet_property_variable_dbstore_debug_default = 0;
char   gnet_property_variable_session_id[GUID_RAW_SIZE];
static const char   gnet_property_variable_session_id_default[GUID_RAW_SIZE];

gboolean gnet_property_variable_pfsp_rare_server     = TRUE;
static const gboolean gnet_property_variable_pfsp_rare_server_default = TRUE;
gboolean gnet_property_variable_enable_guess_client     = TRUE;
static const gboolean gnet_property_variable_enable_guess_client_default = TRUE;
guint32  gnet_property_variable_bw_guess_out     = 1536;
static const guint32  gnet_property_variable_bw_guess_out_default = 1536;
guint32  gnet_property_variable_matching_debug     = 0;
static const guint32  gnet_property_variable_matching_debug_default = 0;
guint32  gnet_property_variable_tsync_debug     = 0;
static const guint32  gnet_property_variable_tsync_debug_default = 0;
gboolean gnet_property_variable_query_request_partials     = TRUE;
static const gboolean gnet_property_variable_query_request_partials_default = TRUE;
gboolean gnet_property_variable_query_answer_partials     = TRUE;
static const gboolean gnet_property_variable_query_answer_partials_default = TRUE;
gboolean gnet_property_variable_query_answer_whats_new     = TRUE;
static const gboolean gnet_property_variable_query_answer_whats_new_default = TRUE;
gboolean gnet_property_variable_search_smart_stop     = TRUE;
static const gboolean gnet_property_variable_search_smart_stop_default = TRUE;
guint32  gnet_property_variable_whats_new_search_max_results     = 10000;
static const guint32  gnet_property_variable_whats_new_search_max_results_default = 10000;
guint32  gnet_property_variable_passive_search_max_results     = 5000;
static const guint32  gnet_property_variable_passive_search_max_results_default = 5000;
gboolean gnet_property_variable_log_dup_gnutella_same_node     = FALSE;
static const gboolean gnet_property_variable_log_dup_gnutella_same_node_default = FALSE;
gboolean gnet_property_variable_log_dup_gnutella_higher_ttl     = FALSE;
static const gboolean gnet_property_variable_log_dup_gnutella_higher_ttl_default = FALSE;
gboolean gnet_property_variable_log_dup_gnutella_other_node     = FALSE;
static const gboolean gnet_property_variable_log_dup_gnutella_other_node_default = FALSE;
gboolean gnet_property_variable_log_new_gnutella     = FALSE;
static const gboolean gnet_property_variable_log_new_gnutella_default = FALSE;
gboolean gnet_property_variable_log_gnutella_routing     = FALSE;
static const gboolean gnet_property_variable_log_gnutella_routing_default = FALSE;
gboolean gnet_property_variable_log_bad_gnutella     = FALSE;
static const gboolean gnet_property_variable_log_bad_gnutella_default = FALSE;
gboolean gnet_property_variable_log_spam_query_hit     = FALSE;
static const gboolean gnet_property_variable_log_spam_query_hit_default = FALSE;
guint32  gnet_property_variable_max_ultra6_hosts_cached     = 10000;
static const guint32  gnet_property_variable_max_ultra6_hosts_cached_default = 10000;
guint32  gnet_property_variable_hosts_in_ultra6_catcher     = 0;
static const guint32  gnet_property_variable_hosts_in_ultra6_catcher_default = 0;
guint32  gnet_property_variable_hosts_in_guess6_catcher     = 0;
static const guint32  gnet_property_variable_hosts_in_guess6_catcher_default = 0;
guint32  gnet_property_variable_hosts_in_guess6_intro_catcher     = 0;
static const guint32  gnet_property_variable_hosts_in_guess6_intro_catcher_default = 0;
guint32  gnet_property_variable_max_guess6_hosts_cached     = 1000;
static const guint32  gnet_property_variable_max_guess6_hosts_cached_default = 1000;
guint32  gnet_property_variable_max_guess6_intro_hosts_cached     = 5000;
static const guint32  gnet_property_variable_max_guess6_intro_hosts_cached_default = 5000;
guint32  gnet_property_variable_xmalloc_debug     = 0;
static const guint32  gnet_property_variable_xmalloc_debug_default = 0;
guint32  gnet_property_variable_qhit_bad_debug     = 0;
static const guint32  gnet_property_variable_qhit_bad_debug_default = 0;
guint32  gnet_property_variable_guid_debug     = 0;
static const guint32  gnet_property_variable_guid_debug_default = 0;
guint32  gnet_property_variable_tx_deflate_debug     = 0;
static const guint32  gnet_property_variable_tx_deflate_debug_default = 0;
char   *gnet_property_variable_tx_debug_addrs     = "";
static const char   *gnet_property_variable_tx_debug_addrs_default = "";
char   *gnet_property_variable_dump_rx_addrs     = "";
static const char   *gnet_property_variable_dump_rx_addrs_default = "";
char   *gnet_property_variable_dump_tx_from_addrs     = "";
static const char   *gnet_property_variable_dump_tx_from_addrs_default = "";
char   *gnet_property_variable_dump_tx_to_addrs     = "";
static const char   *gnet_property_variable_dump_tx_to_addrs_default = "";
gboolean gnet_property_variable_guess_maximize_bw     = TRUE;
static const gboolean gnet_property_variable_guess_maximize_bw_default = TRUE;
guint32  gnet_property_variable_udp_sched_debug     = 0;
static const guint32  gnet_property_variable_udp_sched_debug_default = 0;
guint32  gnet_property_variable_tx_ut_debug_flags     = 0;
static const guint32  gnet_property_variable_tx_ut_debug_flags_default = 0;
char   *gnet_property_variable_rx_debug_addrs     = "";
static const char   *gnet_property_variable_rx_debug_addrs_default = "";
guint32  gnet_property_variable_rx_ut_debug_flags     = 0;
static const guint32  gnet_property_variable_rx_ut_debug_flags_default = 0;
gboolean gnet_property_variable_log_sr_udp_tx     = FALSE;
static const gboolean gnet_property_variable_log_sr_udp_tx_default = FALSE;
gboolean gnet_property_variable_log_sr_udp_rx     = FALSE;
static const gboolean gnet_property_variable_log_sr_udp_rx_default = FALSE;
guint32  gnet_property_variable_secure_oob_debug     = 0;
static const guint32  gnet_property_variable_secure_oob_debug_default = 0;
gboolean gnet_property_variable_log_vmsg_tx     = FALSE;
static const gboolean gnet_property_variable_log_vmsg_tx_default = FALSE;
gboolean gnet_property_variable_log_vmsg_rx     = FALSE;
static const gboolean gnet_property_variable_log_vmsg_rx_default = FALSE;
guint32  gnet_property_variable_dht_tcache_debug_flags     = 0;
static const guint32  gnet_property_variable_dht_tcache_debug_flags_default = 0;
gboolean gnet_property_variable_log_weird_dht_headers     = FALSE;
static const gboolean gnet_property_variable_log_weird_dht_headers_default = FALSE;
guint32  gnet_property_variable_dht_rpc_debug     = 0;
static const guint32  gnet_property_variable_dht_rpc_debug_default = 0;
gboolean gnet_property_variable_log_uhc_pings_rx     = FALSE;
static const gboolean gnet_property_variable_log_uhc_pings_rx_default = FALSE;
gboolean gnet_property_variable_log_uhc_pings_tx     = FALSE;
static const gboolean gnet_property_variable_log_uhc_pings_tx_default = FALSE;
gboolean gnet_property_variable_clean_shutdown     = TRUE;
static const gboolean gnet_property_variable_clean_shutdown_default = TRUE;
gboolean gnet_property_variable_clean_restart     = TRUE;
static const gboolean gnet_property_variable_clean_restart_default = TRUE;
guint32  gnet_property_variable_dht_keys_debug     = 0;
static const guint32  gnet_property_variable_dht_keys_debug_default = 0;
guint32  gnet_property_variable_dht_values_debug     = 0;
static const guint32  gnet_property_variable_dht_values_debug_default = 0;
guint32  gnet_property_variable_pid     = 0;
static const guint32  gnet_property_variable_pid_default = 0;
guint32  gnet_property_variable_http_range_debug     = 0;
static const guint32  gnet_property_variable_http_range_debug_default = 0;
guint32  gnet_property_variable_upnp_mapping_lease_time     = UPNP_MAPPING_LIFE;
static const guint32  gnet_property_variable_upnp_mapping_lease_time_default = UPNP_MAPPING_LIFE;
gboolean gnet_property_variable_user_auto_restart     = FALSE;
static const gboolean gnet_property_variable_user_auto_restart_default = FALSE;
guint32  gnet_property_variable_tm_debug     = 0;
static const guint32  gnet_property_variable_tm_debug_default = 0;

static prop_set_t *gnet_property;

G_GNUC_COLD prop_set_t *
gnet_prop_init(void) {
    guint32 n;

    gnet_property = omalloc(sizeof(prop_set_t));
    gnet_property->name   = "gnet_property";
    gnet_property->desc   = "";
    gnet_property->size   = GNET_PROPERTY_NUM;
    gnet_property->offset = (NO_PROP+1);
    gnet_property->mtime  = 0;
    OMALLOC_ARRAY(gnet_property->props, GNET_PROPERTY_NUM);
    gnet_property->get_stub = gnet_prop_get_stub;
    gnet_property->dirty = FALSE;
    gnet_property->by_name = NULL;
	spinlock_init(&gnet_property->lock);


    /*
     * PROP_READING_HOSTFILE:
     *
     * General data:
     */
    gnet_property->props[0].name = "reading_hostfile";
    gnet_property->props[0].desc = _("Indicates whether the hostcache file is being read.");
    gnet_property->props[0].ev_changed = event_new("reading_hostfile_changed");
    gnet_property->props[0].save = FALSE;
    gnet_property->props[0].vector_size = 1;
	mutex_init(&gnet_property->props[0].lock);

    /* Type specific data: */
    gnet_property->props[0].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[0].data.boolean.def   = (void *) &gnet_property_variable_reading_hostfile_default;
    gnet_property->props[0].data.boolean.value = (void *) &gnet_property_variable_reading_hostfile;


    /*
     * PROP_READING_ULTRAFILE:
     *
     * General data:
     */
    gnet_property->props[1].name = "reading_ultrafile";
    gnet_property->props[1].desc = _("Indicates whether the ultracache file is being read.");
    gnet_property->props[1].ev_changed = event_new("reading_ultrafile_changed");
    gnet_property->props[1].save = FALSE;
    gnet_property->props[1].vector_size = 1;
	mutex_init(&gnet_property->props[1].lock);

    /* Type specific data: */
    gnet_property->props[1].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[1].data.boolean.def   = (void *) &gnet_property_variable_reading_ultrafile_default;
    gnet_property->props[1].data.boolean.value = (void *) &gnet_property_variable_reading_ultrafile;


    /*
     * PROP_ANCIENT_VERSION:
     *
     * General data:
     */
    gnet_property->props[2].name = "ancient_version";
    gnet_property->props[2].desc = _("Indicates that gtk-gnutella finds the version you run very VERY old.  You should upgrade as soon as possible to avoid suffering from non-optimal Gnutella support that may not only damage your abilities to search and download but also harm the network since you're not supporting the newest features.");
    gnet_property->props[2].ev_changed = event_new("ancient_version_changed");
    gnet_property->props[2].save = FALSE;
    gnet_property->props[2].vector_size = 1;
	mutex_init(&gnet_property->props[2].lock);

    /* Type specific data: */
    gnet_property->props[2].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[2].data.boolean.def   = (void *) &gnet_property_variable_ancient_version_default;
    gnet_property->props[2].data.boolean.value = (void *) &gnet_property_variable_ancient_version;


    /*
     * PROP_NEW_VERSION_STR:
     *
     * General data:
     */
    gnet_property->props[3].name = "new_version_str";
    gnet_property->props[3].desc = _("gtk-gnutella found a newer version on the Gnet and gives information about it here.");
    gnet_property->props[3].ev_changed = event_new("new_version_str_changed");
    gnet_property->props[3].save = FALSE;
    gnet_property->props[3].vector_size = 1;
	mutex_init(&gnet_property->props[3].lock);

    /* Type specific data: */
    gnet_property->props[3].type               = PROP_TYPE_STRING;
    gnet_property->props[3].data.string.def    = (void *) &gnet_property_variable_new_version_str_default;
    gnet_property->props[3].data.string.value  = (void *) &gnet_property_variable_new_version_str;
    if (gnet_property->props[3].data.string.def) {
        *gnet_property->props[3].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[3].data.string.def));
    }


    /*
     * PROP_UP_CONNECTIONS:
     *
     * General data:
     */
    gnet_property->props[4].name = "up_connections";
    gnet_property->props[4].desc = _("Try to keep at least this number of connections to other servents of the same kind as we are (normal or ultra nodes). This should be smaller than the maximum amount of connections to allow incoming connections.  Keep in mind that the default TTL on Gnutella is 4, so this needs to be more than 30 to provide decent range for searches.");
    gnet_property->props[4].ev_changed = event_new("up_connections_changed");
    gnet_property->props[4].save = TRUE;
    gnet_property->props[4].vector_size = 1;
	mutex_init(&gnet_property->props[4].lock);

    /* Type specific data: */
    gnet_property->props[4].type               = PROP_TYPE_GUINT32;
    gnet_property->props[4].data.guint32.def   = (void *) &gnet_property_variable_up_connections_default;
    gnet_property->props[4].data.guint32.value = (void *) &gnet_property_variable_up_connections;
    gnet_property->props[4].data.guint32.choices = NULL;
    gnet_property->props[4].data.guint32.max   = 100;
    gnet_property->props[4].data.guint32.min   = 0;


    /*
     * PROP_NORMAL_CONNECTIONS:
     *
     * General data:
     */
    gnet_property->props[5].name = "normal_connections";
    gnet_property->props[5].desc = _("When in ultrapeer mode, try to keep at least this number of connections to normal servents.  This should be smaller than the maximum amount of connections to allow incoming connections.");
    gnet_property->props[5].ev_changed = event_new("normal_connections_changed");
    gnet_property->props[5].save = TRUE;
    gnet_property->props[5].vector_size = 1;
	mutex_init(&gnet_property->props[5].lock);

    /* Type specific data: */
    gnet_property->props[5].type               = PROP_TYPE_GUINT32;
    gnet_property->props[5].data.guint32.def   = (void *) &gnet_property_variable_normal_connections_default;
    gnet_property->props[5].data.guint32.value = (void *) &gnet_property_variable_normal_connections;
    gnet_property->props[5].data.guint32.choices = NULL;
    gnet_property->props[5].data.guint32.max   = 1;
    gnet_property->props[5].data.guint32.min   = 0;


    /*
     * PROP_MAX_CONNECTIONS:
     *
     * General data:
     */
    gnet_property->props[6].name = "max_connections";
    gnet_property->props[6].desc = _("Don't allow more than this number of connections to other servents.  As a rule of thumb you should reserve 256 b/s bandwidth per connection. Never use up all your bandwidth, leave a little space for TCP/IP overhead. It's not advisable that you set this to a value smaller than 40.");
    gnet_property->props[6].ev_changed = event_new("max_connections_changed");
    gnet_property->props[6].save = TRUE;
    gnet_property->props[6].vector_size = 1;
	mutex_init(&gnet_property->props[6].lock);

    /* Type specific data: */
    gnet_property->props[6].type               = PROP_TYPE_GUINT32;
    gnet_property->props[6].data.guint32.def   = (void *) &gnet_property_variable_max_connections_default;
    gnet_property->props[6].data.guint32.value = (void *) &gnet_property_variable_max_connections;
    gnet_property->props[6].data.guint32.choices = NULL;
    gnet_property->props[6].data.guint32.max   = 100;
    gnet_property->props[6].data.guint32.min   = 30;


    /*
     * PROP_NODE_LEAF_COUNT:
     *
     * General data:
     */
    gnet_property->props[7].name = "node_leaf_count";
    gnet_property->props[7].desc = _("Number of leaf nodes currently connected.");
    gnet_property->props[7].ev_changed = event_new("node_leaf_count_changed");
    gnet_property->props[7].save = FALSE;
    gnet_property->props[7].vector_size = 1;
	mutex_init(&gnet_property->props[7].lock);

    /* Type specific data: */
    gnet_property->props[7].type               = PROP_TYPE_GUINT32;
    gnet_property->props[7].data.guint32.def   = (void *) &gnet_property_variable_node_leaf_count_default;
    gnet_property->props[7].data.guint32.value = (void *) &gnet_property_variable_node_leaf_count;
    gnet_property->props[7].data.guint32.choices = NULL;
    gnet_property->props[7].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[7].data.guint32.min   = 0x00000000;


    /*
     * PROP_NODE_NORMAL_COUNT:
     *
     * General data:
     */
    gnet_property->props[8].name = "node_normal_count";
    gnet_property->props[8].desc = _("Number of normal nodes currently connected.");
    gnet_property->props[8].ev_changed = event_new("node_normal_count_changed");
    gnet_property->props[8].save = FALSE;
    gnet_property->props[8].vector_size = 1;
	mutex_init(&gnet_property->props[8].lock);

    /* Type specific data: */
    gnet_property->props[8].type               = PROP_TYPE_GUINT32;
    gnet_property->props[8].data.guint32.def   = (void *) &gnet_property_variable_node_normal_count_default;
    gnet_property->props[8].data.guint32.value = (void *) &gnet_property_variable_node_normal_count;
    gnet_property->props[8].data.guint32.choices = NULL;
    gnet_property->props[8].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[8].data.guint32.min   = 0x00000000;


    /*
     * PROP_NODE_ULTRA_COUNT:
     *
     * General data:
     */
    gnet_property->props[9].name = "node_ultra_count";
    gnet_property->props[9].desc = _("Number of ultra nodes currently connected.");
    gnet_property->props[9].ev_changed = event_new("node_ultra_count_changed");
    gnet_property->props[9].save = FALSE;
    gnet_property->props[9].vector_size = 1;
	mutex_init(&gnet_property->props[9].lock);

    /* Type specific data: */
    gnet_property->props[9].type               = PROP_TYPE_GUINT32;
    gnet_property->props[9].data.guint32.def   = (void *) &gnet_property_variable_node_ultra_count_default;
    gnet_property->props[9].data.guint32.value = (void *) &gnet_property_variable_node_ultra_count;
    gnet_property->props[9].data.guint32.choices = NULL;
    gnet_property->props[9].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[9].data.guint32.min   = 0x00000000;


    /*
     * PROP_MAX_DOWNLOADS:
     *
     * General data:
     */
    gnet_property->props[10].name = "max_simultaneous_downloads";
    gnet_property->props[10].desc = _("Don't start more than this number of parallel downloads.  Others will remain in the queue waiting for a download slot.");
    gnet_property->props[10].ev_changed = event_new("max_downloads_changed");
    gnet_property->props[10].save = TRUE;
    gnet_property->props[10].vector_size = 1;
	mutex_init(&gnet_property->props[10].lock);

    /* Type specific data: */
    gnet_property->props[10].type               = PROP_TYPE_GUINT32;
    gnet_property->props[10].data.guint32.def   = (void *) &gnet_property_variable_max_downloads_default;
    gnet_property->props[10].data.guint32.value = (void *) &gnet_property_variable_max_downloads;
    gnet_property->props[10].data.guint32.choices = NULL;
    gnet_property->props[10].data.guint32.max   = 5000;
    gnet_property->props[10].data.guint32.min   = 0;


    /*
     * PROP_MAX_HOST_DOWNLOADS:
     *
     * General data:
     */
    gnet_property->props[11].name = "max_simultaneous_host_downloads";
    gnet_property->props[11].desc = _("Don't make more connections than given here to a single host to download a file.  Be nice to others, and leave it at the default value (1).");
    gnet_property->props[11].ev_changed = event_new("max_host_downloads_changed");
    gnet_property->props[11].save = TRUE;
    gnet_property->props[11].vector_size = 1;
	mutex_init(&gnet_property->props[11].lock);

    /* Type specific data: */
    gnet_property->props[11].type               = PROP_TYPE_GUINT32;
    gnet_property->props[11].data.guint32.def   = (void *) &gnet_property_variable_max_host_downloads_default;
    gnet_property->props[11].data.guint32.value = (void *) &gnet_property_variable_max_host_downloads;
    gnet_property->props[11].data.guint32.choices = NULL;
    gnet_property->props[11].data.guint32.max   = 10;
    gnet_property->props[11].data.guint32.min   = 1;


    /*
     * PROP_MAX_UPLOADS:
     *
     * General data:
     */
    gnet_property->props[12].name = "max_simultaneous_uploads";
    gnet_property->props[12].desc = _("Don't allow more than this number of uploads in total. This also defines the amount of PARQ queues that will be used. You should at least set it to 2.");
    gnet_property->props[12].ev_changed = event_new("max_uploads_changed");
    gnet_property->props[12].save = TRUE;
    gnet_property->props[12].vector_size = 1;
	mutex_init(&gnet_property->props[12].lock);

    /* Type specific data: */
    gnet_property->props[12].type               = PROP_TYPE_GUINT32;
    gnet_property->props[12].data.guint32.def   = (void *) &gnet_property_variable_max_uploads_default;
    gnet_property->props[12].data.guint32.value = (void *) &gnet_property_variable_max_uploads;
    gnet_property->props[12].data.guint32.choices = NULL;
    gnet_property->props[12].data.guint32.max   = 100;
    gnet_property->props[12].data.guint32.min   = 0;


    /*
     * PROP_MAX_UPLOADS_IP:
     *
     * General data:
     */
    gnet_property->props[13].name = "max_uploads_ip";
    gnet_property->props[13].desc = _("Don't upload more than this number of files in parallel to a single host.");
    gnet_property->props[13].ev_changed = event_new("max_uploads_ip_changed");
    gnet_property->props[13].save = TRUE;
    gnet_property->props[13].vector_size = 1;
	mutex_init(&gnet_property->props[13].lock);

    /* Type specific data: */
    gnet_property->props[13].type               = PROP_TYPE_GUINT32;
    gnet_property->props[13].data.guint32.def   = (void *) &gnet_property_variable_max_uploads_ip_default;
    gnet_property->props[13].data.guint32.value = (void *) &gnet_property_variable_max_uploads_ip;
    gnet_property->props[13].data.guint32.choices = NULL;
    gnet_property->props[13].data.guint32.max   = 100;
    gnet_property->props[13].data.guint32.min   = 1;


    /*
     * PROP_LOCAL_IP:
     *
     * General data:
     */
    gnet_property->props[14].name = "local_ip";
    gnet_property->props[14].desc = _("Local IPv4 address last determined.");
    gnet_property->props[14].ev_changed = event_new("local_ip_changed");
    gnet_property->props[14].save = TRUE;
    gnet_property->props[14].vector_size = 1;
	mutex_init(&gnet_property->props[14].lock);

    /* Type specific data: */
    gnet_property->props[14].type               = PROP_TYPE_IP;
    gnet_property->props[14].data.ip.value = (void *) &gnet_property_variable_local_ip;


    /*
     * PROP_LOCAL_IP6:
     *
     * General data:
     */
    gnet_property->props[15].name = "local_ip6";
    gnet_property->props[15].desc = _("Local IPv6 address last determined.");
    gnet_property->props[15].ev_changed = event_new("local_ip6_changed");
    gnet_property->props[15].save = TRUE;
    gnet_property->props[15].vector_size = 1;
	mutex_init(&gnet_property->props[15].lock);

    /* Type specific data: */
    gnet_property->props[15].type               = PROP_TYPE_IP;
    gnet_property->props[15].data.ip.value = (void *) &gnet_property_variable_local_ip6;


    /*
     * PROP_CURRENT_IP_STAMP:
     *
     * General data:
     */
    gnet_property->props[16].name = "current_ip_stamp";
    gnet_property->props[16].desc = _("When the current IPv4 address was determined.");
    gnet_property->props[16].ev_changed = event_new("current_ip_stamp_changed");
    gnet_property->props[16].save = TRUE;
    gnet_property->props[16].vector_size = 1;
	mutex_init(&gnet_property->props[16].lock);

    /* Type specific data: */
    gnet_property->props[16].type               = PROP_TYPE_TIMESTAMP;
    gnet_property->props[16].data.timestamp.def   = (void *) &gnet_property_variable_current_ip_stamp_default;
    gnet_property->props[16].data.timestamp.value = (void *) &gnet_property_variable_current_ip_stamp;
    gnet_property->props[16].data.timestamp.choices = NULL;
    gnet_property->props[16].data.timestamp.max   = (time_t) ((1U << 31) - 1);
    gnet_property->props[16].data.timestamp.min   = 0x0000000000000000;


    /*
     * PROP_CURRENT_IP6_STAMP:
     *
     * General data:
     */
    gnet_property->props[17].name = "current_ip6_stamp";
    gnet_property->props[17].desc = _("When the current IPv6 address was determined.");
    gnet_property->props[17].ev_changed = event_new("current_ip6_stamp_changed");
    gnet_property->props[17].save = TRUE;
    gnet_property->props[17].vector_size = 1;
	mutex_init(&gnet_property->props[17].lock);

    /* Type specific data: */
    gnet_property->props[17].type               = PROP_TYPE_TIMESTAMP;
    gnet_property->props[17].data.timestamp.def   = (void *) &gnet_property_variable_current_ip6_stamp_default;
    gnet_property->props[17].data.timestamp.value = (void *) &gnet_property_variable_current_ip6_stamp;
    gnet_property->props[17].data.timestamp.choices = NULL;
    gnet_property->props[17].data.timestamp.max   = (time_t) ((1U << 31) - 1);
    gnet_property->props[17].data.timestamp.min   = 0x0000000000000000;


    /*
     * PROP_AVERAGE_IP_UPTIME:
     *
     * General data:
     */
    gnet_property->props[18].name = "average_ip_uptime";
    gnet_property->props[18].desc = _("Average uptime with the same IPv4 address.");
    gnet_property->props[18].ev_changed = event_new("average_ip_uptime_changed");
    gnet_property->props[18].save = TRUE;
    gnet_property->props[18].vector_size = 1;
	mutex_init(&gnet_property->props[18].lock);

    /* Type specific data: */
    gnet_property->props[18].type               = PROP_TYPE_GUINT32;
    gnet_property->props[18].data.guint32.def   = (void *) &gnet_property_variable_average_ip_uptime_default;
    gnet_property->props[18].data.guint32.value = (void *) &gnet_property_variable_average_ip_uptime;
    gnet_property->props[18].data.guint32.choices = NULL;
    gnet_property->props[18].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[18].data.guint32.min   = 0x00000000;


    /*
     * PROP_AVERAGE_IP6_UPTIME:
     *
     * General data:
     */
    gnet_property->props[19].name = "average_ip6_uptime";
    gnet_property->props[19].desc = _("Average uptime with the same IPv6 address.");
    gnet_property->props[19].ev_changed = event_new("average_ip6_uptime_changed");
    gnet_property->props[19].save = TRUE;
    gnet_property->props[19].vector_size = 1;
	mutex_init(&gnet_property->props[19].lock);

    /* Type specific data: */
    gnet_property->props[19].type               = PROP_TYPE_GUINT32;
    gnet_property->props[19].data.guint32.def   = (void *) &gnet_property_variable_average_ip6_uptime_default;
    gnet_property->props[19].data.guint32.value = (void *) &gnet_property_variable_average_ip6_uptime;
    gnet_property->props[19].data.guint32.choices = NULL;
    gnet_property->props[19].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[19].data.guint32.min   = 0x00000000;


    /*
     * PROP_START_STAMP:
     *
     * General data:
     */
    gnet_property->props[20].name = "start_stamp";
    gnet_property->props[20].desc = _("Timestamp at which servent was started.");
    gnet_property->props[20].ev_changed = event_new("start_stamp_changed");
    gnet_property->props[20].save = FALSE;
    gnet_property->props[20].vector_size = 1;
	mutex_init(&gnet_property->props[20].lock);

    /* Type specific data: */
    gnet_property->props[20].type               = PROP_TYPE_TIMESTAMP;
    gnet_property->props[20].data.timestamp.def   = (void *) &gnet_property_variable_start_stamp_default;
    gnet_property->props[20].data.timestamp.value = (void *) &gnet_property_variable_start_stamp;
    gnet_property->props[20].data.timestamp.choices = NULL;
    gnet_property->props[20].data.timestamp.max   = (time_t) ((1U << 31) - 1);
    gnet_property->props[20].data.timestamp.min   = 0x0000000000000000;


    /*
     * PROP_AVERAGE_SERVENT_UPTIME:
     *
     * General data:
     */
    gnet_property->props[21].name = "average_servent_uptime";
    gnet_property->props[21].desc = _("Average servent uptime.");
    gnet_property->props[21].ev_changed = event_new("average_servent_uptime_changed");
    gnet_property->props[21].save = TRUE;
    gnet_property->props[21].vector_size = 1;
	mutex_init(&gnet_property->props[21].lock);

    /* Type specific data: */
    gnet_property->props[21].type               = PROP_TYPE_GUINT32;
    gnet_property->props[21].data.guint32.def   = (void *) &gnet_property_variable_average_servent_uptime_default;
    gnet_property->props[21].data.guint32.value = (void *) &gnet_property_variable_average_servent_uptime;
    gnet_property->props[21].data.guint32.choices = NULL;
    gnet_property->props[21].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[21].data.guint32.min   = 0x00000000;


    /*
     * PROP_LISTEN_PORT:
     *
     * General data:
     */
    gnet_property->props[22].name = "listen_port";
    gnet_property->props[22].desc = _("Local TCP port gtk-gnutella is listening on. ISPs often block or throttle traffic on TCP port 6346 so it is a good idea to change it to something in the range of 1024-65535.  Don't forget to update your firewall port forwarding / opening, as necessary.  Note that by default, the TCP port 6346 is not used to guard against undue censorship.");
    gnet_property->props[22].ev_changed = event_new("listen_port_changed");
    gnet_property->props[22].save = TRUE;
    gnet_property->props[22].vector_size = 1;
	mutex_init(&gnet_property->props[22].lock);

    /* Type specific data: */
    gnet_property->props[22].type               = PROP_TYPE_GUINT32;
    gnet_property->props[22].data.guint32.def   = (void *) &gnet_property_variable_listen_port_default;
    gnet_property->props[22].data.guint32.value = (void *) &gnet_property_variable_listen_port;
    gnet_property->props[22].data.guint32.choices = NULL;
    gnet_property->props[22].data.guint32.max   = 0xFFFF;
    gnet_property->props[22].data.guint32.min   = 0x0000;


    /*
     * PROP_FORCED_LOCAL_IP:
     *
     * General data:
     */
    gnet_property->props[23].name = "forced_local_ip";
    gnet_property->props[23].desc = _("Use this IP address as source address if 'force local ip' is activated.");
    gnet_property->props[23].ev_changed = event_new("forced_local_ip_changed");
    gnet_property->props[23].save = TRUE;
    gnet_property->props[23].vector_size = 1;
	mutex_init(&gnet_property->props[23].lock);

    /* Type specific data: */
    gnet_property->props[23].type               = PROP_TYPE_IP;
    gnet_property->props[23].data.ip.value = (void *) &gnet_property_variable_forced_local_ip;


    /*
     * PROP_FORCED_LOCAL_IP6:
     *
     * General data:
     */
    gnet_property->props[24].name = "forced_local_ip6";
    gnet_property->props[24].desc = _("Use this IPv6 address as source address if 'force local ip' is activated.");
    gnet_property->props[24].ev_changed = event_new("forced_local_ip6_changed");
    gnet_property->props[24].save = TRUE;
    gnet_property->props[24].vector_size = 1;
	mutex_init(&gnet_property->props[24].lock);

    /* Type specific data: */
    gnet_property->props[24].type               = PROP_TYPE_IP;
    gnet_property->props[24].data.ip.value = (void *) &gnet_property_variable_forced_local_ip6;


    /*
     * PROP_CONNECTION_SPEED:
     *
     * General data:
     */
    gnet_property->props[25].name = "connection_speed";
    gnet_property->props[25].desc = _("The connection bandwidth reported to other hosts. This is the speed at which you can upload things to others.");
    gnet_property->props[25].ev_changed = event_new("connection_speed_changed");
    gnet_property->props[25].save = TRUE;
    gnet_property->props[25].vector_size = 1;
	mutex_init(&gnet_property->props[25].lock);

    /* Type specific data: */
    gnet_property->props[25].type               = PROP_TYPE_GUINT32;
    gnet_property->props[25].data.guint32.def   = (void *) &gnet_property_variable_connection_speed_default;
    gnet_property->props[25].data.guint32.value = (void *) &gnet_property_variable_connection_speed;
    gnet_property->props[25].data.guint32.choices = NULL;
    gnet_property->props[25].data.guint32.max   = 2000;
    gnet_property->props[25].data.guint32.min   = 0;


    /*
     * PROP_COMPUTE_CONNECTION_SPEED:
     *
     * General data:
     */
    gnet_property->props[26].name = "compute_connection_speed";
    gnet_property->props[26].desc = _("Whether the connection bandwidth reported to other hosts should be computed based on the current average upload speed. The reported speed is the available speed for a new upload, not the theoretical maximum configured: it is the average bandwidth (or the max configured bandwidth if no traffic yet) divided by the number of upload slots. When it is ON (recommended setting), the hardwired connection speed is not used.");
    gnet_property->props[26].ev_changed = event_new("compute_connection_speed_changed");
    gnet_property->props[26].save = TRUE;
    gnet_property->props[26].vector_size = 1;
	mutex_init(&gnet_property->props[26].lock);

    /* Type specific data: */
    gnet_property->props[26].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[26].data.boolean.def   = (void *) &gnet_property_variable_compute_connection_speed_default;
    gnet_property->props[26].data.boolean.value = (void *) &gnet_property_variable_compute_connection_speed;


    /*
     * PROP_QUERY_RESPONSE_MAX_ITEMS:
     *
     * General data:
     */
    gnet_property->props[27].name = "limit_search_results";
    gnet_property->props[27].desc = _("Return at most this number of results to a query, using as many query hit packets as necessary.  To avoid network flooding, keep this to a reasonable value.");
    gnet_property->props[27].ev_changed = event_new("query_response_max_items_changed");
    gnet_property->props[27].save = TRUE;
    gnet_property->props[27].vector_size = 1;
	mutex_init(&gnet_property->props[27].lock);

    /* Type specific data: */
    gnet_property->props[27].type               = PROP_TYPE_GUINT32;
    gnet_property->props[27].data.guint32.def   = (void *) &gnet_property_variable_search_max_items_default;
    gnet_property->props[27].data.guint32.value = (void *) &gnet_property_variable_search_max_items;
    gnet_property->props[27].data.guint32.choices = NULL;
    gnet_property->props[27].data.guint32.max   = 500;
    gnet_property->props[27].data.guint32.min   = 1;


    /*
     * PROP_UL_USAGE_MIN_PERCENTAGE:
     *
     * General data:
     */
    gnet_property->props[28].name = "ul_usage_min_percentage";
    gnet_property->props[28].desc = _("Unless this percentage or more of the upload bandwidth is used, allow additional upload slots.");
    gnet_property->props[28].ev_changed = event_new("ul_usage_min_percentage_changed");
    gnet_property->props[28].save = TRUE;
    gnet_property->props[28].vector_size = 1;
	mutex_init(&gnet_property->props[28].lock);

    /* Type specific data: */
    gnet_property->props[28].type               = PROP_TYPE_GUINT32;
    gnet_property->props[28].data.guint32.def   = (void *) &gnet_property_variable_ul_usage_min_percentage_default;
    gnet_property->props[28].data.guint32.value = (void *) &gnet_property_variable_ul_usage_min_percentage;
    gnet_property->props[28].data.guint32.choices = NULL;
    gnet_property->props[28].data.guint32.max   = 100;
    gnet_property->props[28].data.guint32.min   = 0;


    /*
     * PROP_DOWNLOAD_CONNECTING_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[29].name = "download_connecting_timeout";
    gnet_property->props[29].desc = _("Number of seconds before a download connect attempt times out.");
    gnet_property->props[29].ev_changed = event_new("download_connecting_timeout_changed");
    gnet_property->props[29].save = TRUE;
    gnet_property->props[29].vector_size = 1;
	mutex_init(&gnet_property->props[29].lock);

    /* Type specific data: */
    gnet_property->props[29].type               = PROP_TYPE_GUINT32;
    gnet_property->props[29].data.guint32.def   = (void *) &gnet_property_variable_download_connecting_timeout_default;
    gnet_property->props[29].data.guint32.value = (void *) &gnet_property_variable_download_connecting_timeout;
    gnet_property->props[29].data.guint32.choices = NULL;
    gnet_property->props[29].data.guint32.max   = 100000;
    gnet_property->props[29].data.guint32.min   = 60;


    /*
     * PROP_DOWNLOAD_PUSH_SENT_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[30].name = "download_push_sent_timeout";
    gnet_property->props[30].desc = _("Number of seconds before a push request times out.");
    gnet_property->props[30].ev_changed = event_new("download_push_sent_timeout_changed");
    gnet_property->props[30].save = TRUE;
    gnet_property->props[30].vector_size = 1;
	mutex_init(&gnet_property->props[30].lock);

    /* Type specific data: */
    gnet_property->props[30].type               = PROP_TYPE_GUINT32;
    gnet_property->props[30].data.guint32.def   = (void *) &gnet_property_variable_download_push_sent_timeout_default;
    gnet_property->props[30].data.guint32.value = (void *) &gnet_property_variable_download_push_sent_timeout;
    gnet_property->props[30].data.guint32.choices = NULL;
    gnet_property->props[30].data.guint32.max   = 100000;
    gnet_property->props[30].data.guint32.min   = 60;


    /*
     * PROP_DOWNLOAD_CONNECTED_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[31].name = "download_connected_timeout";
    gnet_property->props[31].desc = _("Number of seconds before a download times out if no data is received.");
    gnet_property->props[31].ev_changed = event_new("download_connected_timeout_changed");
    gnet_property->props[31].save = TRUE;
    gnet_property->props[31].vector_size = 1;
	mutex_init(&gnet_property->props[31].lock);

    /* Type specific data: */
    gnet_property->props[31].type               = PROP_TYPE_GUINT32;
    gnet_property->props[31].data.guint32.def   = (void *) &gnet_property_variable_download_connected_timeout_default;
    gnet_property->props[31].data.guint32.value = (void *) &gnet_property_variable_download_connected_timeout;
    gnet_property->props[31].data.guint32.choices = NULL;
    gnet_property->props[31].data.guint32.max   = 100000;
    gnet_property->props[31].data.guint32.min   = 120;


    /*
     * PROP_DOWNLOAD_RETRY_TIMEOUT_MIN:
     *
     * General data:
     */
    gnet_property->props[32].name = "download_retry_timeout_min";
    gnet_property->props[32].desc = _("Minimum number of seconds to wait on auto-retry timeouts.");
    gnet_property->props[32].ev_changed = event_new("download_retry_timeout_min_changed");
    gnet_property->props[32].save = TRUE;
    gnet_property->props[32].vector_size = 1;
	mutex_init(&gnet_property->props[32].lock);

    /* Type specific data: */
    gnet_property->props[32].type               = PROP_TYPE_GUINT32;
    gnet_property->props[32].data.guint32.def   = (void *) &gnet_property_variable_download_retry_timeout_min_default;
    gnet_property->props[32].data.guint32.value = (void *) &gnet_property_variable_download_retry_timeout_min;
    gnet_property->props[32].data.guint32.choices = NULL;
    gnet_property->props[32].data.guint32.max   = 100000;
    gnet_property->props[32].data.guint32.min   = 5;


    /*
     * PROP_DOWNLOAD_RETRY_TIMEOUT_MAX:
     *
     * General data:
     */
    gnet_property->props[33].name = "download_retry_timeout_max";
    gnet_property->props[33].desc = _("Maximum number of seconds to wait on auto-retry timeouts.");
    gnet_property->props[33].ev_changed = event_new("download_retry_timeout_max_changed");
    gnet_property->props[33].save = TRUE;
    gnet_property->props[33].vector_size = 1;
	mutex_init(&gnet_property->props[33].lock);

    /* Type specific data: */
    gnet_property->props[33].type               = PROP_TYPE_GUINT32;
    gnet_property->props[33].data.guint32.def   = (void *) &gnet_property_variable_download_retry_timeout_max_default;
    gnet_property->props[33].data.guint32.value = (void *) &gnet_property_variable_download_retry_timeout_max;
    gnet_property->props[33].data.guint32.choices = NULL;
    gnet_property->props[33].data.guint32.max   = 100000;
    gnet_property->props[33].data.guint32.min   = 5;


    /*
     * PROP_DOWNLOAD_MAX_RETRIES:
     *
     * General data:
     */
    gnet_property->props[34].name = "download_max_retries";
    gnet_property->props[34].desc = _("Maximum number of attempts to download a file not counting HTTP busy indications.");
    gnet_property->props[34].ev_changed = event_new("download_max_retries_changed");
    gnet_property->props[34].save = TRUE;
    gnet_property->props[34].vector_size = 1;
	mutex_init(&gnet_property->props[34].lock);

    /* Type specific data: */
    gnet_property->props[34].type               = PROP_TYPE_GUINT32;
    gnet_property->props[34].data.guint32.def   = (void *) &gnet_property_variable_download_max_retries_default;
    gnet_property->props[34].data.guint32.value = (void *) &gnet_property_variable_download_max_retries;
    gnet_property->props[34].data.guint32.choices = NULL;
    gnet_property->props[34].data.guint32.max   = 100;
    gnet_property->props[34].data.guint32.min   = 1;


    /*
     * PROP_DOWNLOAD_RETRY_TIMEOUT_DELAY:
     *
     * General data:
     */
    gnet_property->props[35].name = "download_retry_timeout_delay";
    gnet_property->props[35].desc = _("Delay in seconds before retrying after a connection timed out.");
    gnet_property->props[35].ev_changed = event_new("download_retry_timeout_delay_changed");
    gnet_property->props[35].save = TRUE;
    gnet_property->props[35].vector_size = 1;
	mutex_init(&gnet_property->props[35].lock);

    /* Type specific data: */
    gnet_property->props[35].type               = PROP_TYPE_GUINT32;
    gnet_property->props[35].data.guint32.def   = (void *) &gnet_property_variable_download_retry_timeout_delay_default;
    gnet_property->props[35].data.guint32.value = (void *) &gnet_property_variable_download_retry_timeout_delay;
    gnet_property->props[35].data.guint32.choices = NULL;
    gnet_property->props[35].data.guint32.max   = 100000;
    gnet_property->props[35].data.guint32.min   = 15;


    /*
     * PROP_DOWNLOAD_RETRY_BUSY_DELAY:
     *
     * General data:
     */
    gnet_property->props[36].name = "download_retry_busy_delay";
    gnet_property->props[36].desc = _("Delay in seconds before retrying after getting a 'busy' response from a host.");
    gnet_property->props[36].ev_changed = event_new("download_retry_busy_delay_changed");
    gnet_property->props[36].save = TRUE;
    gnet_property->props[36].vector_size = 1;
	mutex_init(&gnet_property->props[36].lock);

    /* Type specific data: */
    gnet_property->props[36].type               = PROP_TYPE_GUINT32;
    gnet_property->props[36].data.guint32.def   = (void *) &gnet_property_variable_download_retry_busy_delay_default;
    gnet_property->props[36].data.guint32.value = (void *) &gnet_property_variable_download_retry_busy_delay;
    gnet_property->props[36].data.guint32.choices = NULL;
    gnet_property->props[36].data.guint32.max   = 100000;
    gnet_property->props[36].data.guint32.min   = 15;


    /*
     * PROP_DOWNLOAD_RETRY_REFUSED_DELAY:
     *
     * General data:
     */
    gnet_property->props[37].name = "download_retry_refused_delay";
    gnet_property->props[37].desc = _("Delay in seconds before retrying after getting a 'connection refused' response from a host.");
    gnet_property->props[37].ev_changed = event_new("download_retry_refused_delay_changed");
    gnet_property->props[37].save = TRUE;
    gnet_property->props[37].vector_size = 1;
	mutex_init(&gnet_property->props[37].lock);

    /* Type specific data: */
    gnet_property->props[37].type               = PROP_TYPE_GUINT32;
    gnet_property->props[37].data.guint32.def   = (void *) &gnet_property_variable_download_retry_refused_delay_default;
    gnet_property->props[37].data.guint32.value = (void *) &gnet_property_variable_download_retry_refused_delay;
    gnet_property->props[37].data.guint32.choices = NULL;
    gnet_property->props[37].data.guint32.max   = 100000;
    gnet_property->props[37].data.guint32.min   = 15;


    /*
     * PROP_DOWNLOAD_RETRY_STOPPED_DELAY:
     *
     * General data:
     */
    gnet_property->props[38].name = "download_retry_stopped";
    gnet_property->props[38].desc = _("Delay in seconds before retrying after a retry stopped (timed out, connection reset by peer, etc...).");
    gnet_property->props[38].ev_changed = event_new("download_retry_stopped_delay_changed");
    gnet_property->props[38].save = TRUE;
    gnet_property->props[38].vector_size = 1;
	mutex_init(&gnet_property->props[38].lock);

    /* Type specific data: */
    gnet_property->props[38].type               = PROP_TYPE_GUINT32;
    gnet_property->props[38].data.guint32.def   = (void *) &gnet_property_variable_download_retry_stopped_delay_default;
    gnet_property->props[38].data.guint32.value = (void *) &gnet_property_variable_download_retry_stopped_delay;
    gnet_property->props[38].data.guint32.choices = NULL;
    gnet_property->props[38].data.guint32.max   = 100000;
    gnet_property->props[38].data.guint32.min   = 15;


    /*
     * PROP_DOWNLOAD_OVERLAP_RANGE:
     *
     * General data:
     */
    gnet_property->props[39].name = "download_overlap_range";
    gnet_property->props[39].desc = _("Amount of bytes to overlap when resuming a download. It should be at least 64 bytes for safe resuming, otherwise gtk-gnutella will not accept to resume a file for which we had no SHA1 known, after a server gives one back.");
    gnet_property->props[39].ev_changed = event_new("download_overlap_range_changed");
    gnet_property->props[39].save = TRUE;
    gnet_property->props[39].vector_size = 1;
	mutex_init(&gnet_property->props[39].lock);

    /* Type specific data: */
    gnet_property->props[39].type               = PROP_TYPE_GUINT32;
    gnet_property->props[39].data.guint32.def   = (void *) &gnet_property_variable_download_overlap_range_default;
    gnet_property->props[39].data.guint32.value = (void *) &gnet_property_variable_download_overlap_range;
    gnet_property->props[39].data.guint32.choices = NULL;
    gnet_property->props[39].data.guint32.max   = SOCK_BUFSZ;
    gnet_property->props[39].data.guint32.min   = 0;


    /*
     * PROP_UPLOAD_CONNECTING_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[40].name = "upload_connecting_timeout";
    gnet_property->props[40].desc = _("Number of seconds before an upload times out if no connection can be established during a push.  It is also the maximum amount of time we wait to get the whole HTTP request.");
    gnet_property->props[40].ev_changed = event_new("upload_connecting_timeout_changed");
    gnet_property->props[40].save = TRUE;
    gnet_property->props[40].vector_size = 1;
	mutex_init(&gnet_property->props[40].lock);

    /* Type specific data: */
    gnet_property->props[40].type               = PROP_TYPE_GUINT32;
    gnet_property->props[40].data.guint32.def   = (void *) &gnet_property_variable_upload_connecting_timeout_default;
    gnet_property->props[40].data.guint32.value = (void *) &gnet_property_variable_upload_connecting_timeout;
    gnet_property->props[40].data.guint32.choices = NULL;
    gnet_property->props[40].data.guint32.max   = 100000;
    gnet_property->props[40].data.guint32.min   = 60;


    /*
     * PROP_UPLOAD_CONNECTED_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[41].name = "upload_connected_timeout";
    gnet_property->props[41].desc = _("Number of seconds after which an upload times out if no data is transmitted.");
    gnet_property->props[41].ev_changed = event_new("upload_connected_timeout_changed");
    gnet_property->props[41].save = TRUE;
    gnet_property->props[41].vector_size = 1;
	mutex_init(&gnet_property->props[41].lock);

    /* Type specific data: */
    gnet_property->props[41].type               = PROP_TYPE_GUINT32;
    gnet_property->props[41].data.guint32.def   = (void *) &gnet_property_variable_upload_connected_timeout_default;
    gnet_property->props[41].data.guint32.value = (void *) &gnet_property_variable_upload_connected_timeout;
    gnet_property->props[41].data.guint32.choices = NULL;
    gnet_property->props[41].data.guint32.max   = 100000;
    gnet_property->props[41].data.guint32.min   = 120;


    /*
     * PROP_SEARCH_REISSUE_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[42].name = "search_reissue_timeout";
    gnet_property->props[42].desc = _("Amount of seconds to wait before a search is issued again to see if new results are available.  Be very careful with this parameter, and do not set it too low or you will damage the Gnutella network.  A delay of half an hour is fine.");
    gnet_property->props[42].ev_changed = event_new("search_reissue_timeout_changed");
    gnet_property->props[42].save = TRUE;
    gnet_property->props[42].vector_size = 1;
	mutex_init(&gnet_property->props[42].lock);

    /* Type specific data: */
    gnet_property->props[42].type               = PROP_TYPE_GUINT32;
    gnet_property->props[42].data.guint32.def   = (void *) &gnet_property_variable_search_reissue_timeout_default;
    gnet_property->props[42].data.guint32.value = (void *) &gnet_property_variable_search_reissue_timeout;
    gnet_property->props[42].data.guint32.choices = NULL;
    gnet_property->props[42].data.guint32.max   = 9999;
    gnet_property->props[42].data.guint32.min   = 0;


    /*
     * PROP_BAN_RATIO_FDS:
     *
     * General data:
     */
    gnet_property->props[43].name = "ban_ratio_fds";
    gnet_property->props[43].desc = _("Maximum ratio of file descriptors reserved for banning. For instance, if your OS gives you 350 file descriptors, a ratio of 10 will reserve at most 35 file descriptors.  You should ensure you have around 100 file descriptors for efficient banning.");
    gnet_property->props[43].ev_changed = event_new("ban_ratio_fds_changed");
    gnet_property->props[43].save = TRUE;
    gnet_property->props[43].vector_size = 1;
	mutex_init(&gnet_property->props[43].lock);

    /* Type specific data: */
    gnet_property->props[43].type               = PROP_TYPE_GUINT32;
    gnet_property->props[43].data.guint32.def   = (void *) &gnet_property_variable_ban_ratio_fds_default;
    gnet_property->props[43].data.guint32.value = (void *) &gnet_property_variable_ban_ratio_fds;
    gnet_property->props[43].data.guint32.choices = NULL;
    gnet_property->props[43].data.guint32.max   = 100;
    gnet_property->props[43].data.guint32.min   = 0;


    /*
     * PROP_BAN_MAX_FDS:
     *
     * General data:
     */
    gnet_property->props[44].name = "ban_max_fds";
    gnet_property->props[44].desc = _("Maximum number of file descriptors reserved for banning.");
    gnet_property->props[44].ev_changed = event_new("ban_max_fds_changed");
    gnet_property->props[44].save = TRUE;
    gnet_property->props[44].vector_size = 1;
	mutex_init(&gnet_property->props[44].lock);

    /* Type specific data: */
    gnet_property->props[44].type               = PROP_TYPE_GUINT32;
    gnet_property->props[44].data.guint32.def   = (void *) &gnet_property_variable_ban_max_fds_default;
    gnet_property->props[44].data.guint32.value = (void *) &gnet_property_variable_ban_max_fds;
    gnet_property->props[44].data.guint32.choices = NULL;
    gnet_property->props[44].data.guint32.max   = 10000;
    gnet_property->props[44].data.guint32.min   = 0;


    /*
     * PROP_BANNED_COUNT:
     *
     * General data:
     */
    gnet_property->props[45].name = "banned_count";
    gnet_property->props[45].desc = _("Amount of file descriptors currently used for banning, i.e. which are currently kept open for delayed close.");
    gnet_property->props[45].ev_changed = event_new("banned_count_changed");
    gnet_property->props[45].save = FALSE;
    gnet_property->props[45].vector_size = 1;
	mutex_init(&gnet_property->props[45].lock);

    /* Type specific data: */
    gnet_property->props[45].type               = PROP_TYPE_GUINT32;
    gnet_property->props[45].data.guint32.def   = (void *) &gnet_property_variable_banned_count_default;
    gnet_property->props[45].data.guint32.value = (void *) &gnet_property_variable_banned_count;
    gnet_property->props[45].data.guint32.choices = NULL;
    gnet_property->props[45].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[45].data.guint32.min   = 0x00000000;


    /*
     * PROP_MAX_BANNED_FD:
     *
     * General data:
     */
    gnet_property->props[46].name = "max_banned_fd";
    gnet_property->props[46].desc = _("Number of file descriptors we'll actually be using for banning.");
    gnet_property->props[46].ev_changed = event_new("max_banned_fd_changed");
    gnet_property->props[46].save = FALSE;
    gnet_property->props[46].vector_size = 1;
	mutex_init(&gnet_property->props[46].lock);

    /* Type specific data: */
    gnet_property->props[46].type               = PROP_TYPE_GUINT32;
    gnet_property->props[46].data.guint32.def   = (void *) &gnet_property_variable_max_banned_fd_default;
    gnet_property->props[46].data.guint32.value = (void *) &gnet_property_variable_max_banned_fd;
    gnet_property->props[46].data.guint32.choices = NULL;
    gnet_property->props[46].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[46].data.guint32.min   = 0x00000000;


    /*
     * PROP_INCOMING_CONNECTING_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[47].name = "incoming_connecting_timeout";
    gnet_property->props[47].desc = _("Number of seconds an incoming connection has to start sending out its request.");
    gnet_property->props[47].ev_changed = event_new("incoming_connecting_timeout_changed");
    gnet_property->props[47].save = TRUE;
    gnet_property->props[47].vector_size = 1;
	mutex_init(&gnet_property->props[47].lock);

    /* Type specific data: */
    gnet_property->props[47].type               = PROP_TYPE_GUINT32;
    gnet_property->props[47].data.guint32.def   = (void *) &gnet_property_variable_incoming_connecting_timeout_default;
    gnet_property->props[47].data.guint32.value = (void *) &gnet_property_variable_incoming_connecting_timeout;
    gnet_property->props[47].data.guint32.choices = NULL;
    gnet_property->props[47].data.guint32.max   = 300;
    gnet_property->props[47].data.guint32.min   = 30;


    /*
     * PROP_NODE_CONNECTING_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[48].name = "node_connecting_timeout";
    gnet_property->props[48].desc = _("Number of seconds before a Gnet connect attempt times out if no connection can be established.");
    gnet_property->props[48].ev_changed = event_new("node_connecting_timeout_changed");
    gnet_property->props[48].save = TRUE;
    gnet_property->props[48].vector_size = 1;
	mutex_init(&gnet_property->props[48].lock);

    /* Type specific data: */
    gnet_property->props[48].type               = PROP_TYPE_GUINT32;
    gnet_property->props[48].data.guint32.def   = (void *) &gnet_property_variable_node_connecting_timeout_default;
    gnet_property->props[48].data.guint32.value = (void *) &gnet_property_variable_node_connecting_timeout;
    gnet_property->props[48].data.guint32.choices = NULL;
    gnet_property->props[48].data.guint32.max   = 100000;
    gnet_property->props[48].data.guint32.min   = 15;


    /*
     * PROP_NODE_CONNECTED_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[49].name = "node_connected_timeout";
    gnet_property->props[49].desc = _("Number of seconds before a Gnet connection times out if no data is transmitted.");
    gnet_property->props[49].ev_changed = event_new("node_connected_timeout_changed");
    gnet_property->props[49].save = TRUE;
    gnet_property->props[49].vector_size = 1;
	mutex_init(&gnet_property->props[49].lock);

    /* Type specific data: */
    gnet_property->props[49].type               = PROP_TYPE_GUINT32;
    gnet_property->props[49].data.guint32.def   = (void *) &gnet_property_variable_node_connected_timeout_default;
    gnet_property->props[49].data.guint32.value = (void *) &gnet_property_variable_node_connected_timeout;
    gnet_property->props[49].data.guint32.choices = NULL;
    gnet_property->props[49].data.guint32.max   = 100000;
    gnet_property->props[49].data.guint32.min   = 120;


    /*
     * PROP_NODE_SENDQUEUE_SIZE:
     *
     * General data:
     */
    gnet_property->props[50].name = "node_sendqueue_size";
    gnet_property->props[50].desc = _("Maximum size of the sendqueue for the nodes (in bytes). Must be at least 150 percent of the maximum message size.");
    gnet_property->props[50].ev_changed = event_new("node_sendqueue_size_changed");
    gnet_property->props[50].save = TRUE;
    gnet_property->props[50].vector_size = 1;
	mutex_init(&gnet_property->props[50].lock);

    /* Type specific data: */
    gnet_property->props[50].type               = PROP_TYPE_GUINT32;
    gnet_property->props[50].data.guint32.def   = (void *) &gnet_property_variable_node_sendqueue_size_default;
    gnet_property->props[50].data.guint32.value = (void *) &gnet_property_variable_node_sendqueue_size;
    gnet_property->props[50].data.guint32.choices = NULL;
    gnet_property->props[50].data.guint32.max   = 256000;
    gnet_property->props[50].data.guint32.min   = 98304;


    /*
     * PROP_NODE_TX_FLOWC_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[51].name = "node_tx_flowc_timeout";
    gnet_property->props[51].desc = _("Maximum number of seconds a node can remain in transmit flow control before being kicked out.");
    gnet_property->props[51].ev_changed = event_new("node_tx_flowc_timeout_changed");
    gnet_property->props[51].save = TRUE;
    gnet_property->props[51].vector_size = 1;
	mutex_init(&gnet_property->props[51].lock);

    /* Type specific data: */
    gnet_property->props[51].type               = PROP_TYPE_GUINT32;
    gnet_property->props[51].data.guint32.def   = (void *) &gnet_property_variable_node_tx_flowc_timeout_default;
    gnet_property->props[51].data.guint32.value = (void *) &gnet_property_variable_node_tx_flowc_timeout;
    gnet_property->props[51].data.guint32.choices = NULL;
    gnet_property->props[51].data.guint32.max   = 7200;
    gnet_property->props[51].data.guint32.min   = 90;


    /*
     * PROP_NODE_RX_FLOWC_RATIO:
     *
     * General data:
     */
    gnet_property->props[52].name = "node_rx_flowc_ratio";
    gnet_property->props[52].desc = _("Maximum percentage of time over 5 minutes that our node can remain in flow control remotely before dropping the connection.  This only works with nodes that will send us an hops-flow message when they are flow-controlling us.");
    gnet_property->props[52].ev_changed = event_new("node_rx_flowc_ratio_changed");
    gnet_property->props[52].save = TRUE;
    gnet_property->props[52].vector_size = 1;
	mutex_init(&gnet_property->props[52].lock);

    /* Type specific data: */
    gnet_property->props[52].type               = PROP_TYPE_GUINT32;
    gnet_property->props[52].data.guint32.def   = (void *) &gnet_property_variable_node_rx_flowc_ratio_default;
    gnet_property->props[52].data.guint32.value = (void *) &gnet_property_variable_node_rx_flowc_ratio;
    gnet_property->props[52].data.guint32.choices = NULL;
    gnet_property->props[52].data.guint32.max   = 100;
    gnet_property->props[52].data.guint32.min   = 30;


    /*
     * PROP_MAX_TTL:
     *
     * General data:
     */
    gnet_property->props[53].name = "max_ttl";
    gnet_property->props[53].desc = _("Maximum TTL we allow in messages we broadcast.  If a query comes in with a TTL greater than that, it will be trimmed down to that value.  On Gnutella, the standard is TTL=4, so you cannot set a value lower than that.");
    gnet_property->props[53].ev_changed = event_new("max_ttl_changed");
    gnet_property->props[53].save = TRUE;
    gnet_property->props[53].vector_size = 1;
	mutex_init(&gnet_property->props[53].lock);

    /* Type specific data: */
    gnet_property->props[53].type               = PROP_TYPE_GUINT32;
    gnet_property->props[53].data.guint32.def   = (void *) &gnet_property_variable_max_ttl_default;
    gnet_property->props[53].data.guint32.value = (void *) &gnet_property_variable_max_ttl;
    gnet_property->props[53].data.guint32.choices = NULL;
    gnet_property->props[53].data.guint32.max   = 5;
    gnet_property->props[53].data.guint32.min   = 4;


    /*
     * PROP_MY_TTL:
     *
     * General data:
     */
    gnet_property->props[54].name = "my_ttl";
    gnet_property->props[54].desc = _("The TTL we use in messages we generate.  The default on Gnutella is TTL=4.  If you set it to too large a value, you run the risk of being trimmed down by fellow gtk-gnutella nodes, or kicked out by some other servent.");
    gnet_property->props[54].ev_changed = event_new("my_ttl_changed");
    gnet_property->props[54].save = TRUE;
    gnet_property->props[54].vector_size = 1;
	mutex_init(&gnet_property->props[54].lock);

    /* Type specific data: */
    gnet_property->props[54].type               = PROP_TYPE_GUINT32;
    gnet_property->props[54].data.guint32.def   = (void *) &gnet_property_variable_my_ttl_default;
    gnet_property->props[54].data.guint32.value = (void *) &gnet_property_variable_my_ttl;
    gnet_property->props[54].data.guint32.choices = NULL;
    gnet_property->props[54].data.guint32.max   = 4;
    gnet_property->props[54].data.guint32.min   = 1;


    /*
     * PROP_HARD_TTL_LIMIT:
     *
     * General data:
     */
    gnet_property->props[55].name = "hard_ttl_limit";
    gnet_property->props[55].desc = _("Maximum hard TTL limit (hops + TTL) on messages we relay.  This should be greater than the standard TTL=4, because it is also applied to routed-back messages (query hits) that could be re-routed in case a connection is lost.  Standard broadcasted messages have their TTL limited by the maximum TTL you configure, and that limit should be much lower than the value of this parameter.");
    gnet_property->props[55].ev_changed = event_new("hard_ttl_limit_changed");
    gnet_property->props[55].save = TRUE;
    gnet_property->props[55].vector_size = 1;
	mutex_init(&gnet_property->props[55].lock);

    /* Type specific data: */
    gnet_property->props[55].type               = PROP_TYPE_GUINT32;
    gnet_property->props[55].data.guint32.def   = (void *) &gnet_property_variable_hard_ttl_limit_default;
    gnet_property->props[55].data.guint32.value = (void *) &gnet_property_variable_hard_ttl_limit;
    gnet_property->props[55].data.guint32.choices = NULL;
    gnet_property->props[55].data.guint32.max   = 25;
    gnet_property->props[55].data.guint32.min   = 9;


    /*
     * PROP_DBG:
     *
     * General data:
     */
    gnet_property->props[56].name = "dbg";
    gnet_property->props[56].desc = _("For development use: debug level.");
    gnet_property->props[56].ev_changed = event_new("dbg_changed");
    gnet_property->props[56].save = TRUE;
    gnet_property->props[56].vector_size = 1;
	mutex_init(&gnet_property->props[56].lock);

    /* Type specific data: */
    gnet_property->props[56].type               = PROP_TYPE_GUINT32;
    gnet_property->props[56].data.guint32.def   = (void *) &gnet_property_variable_dbg_default;
    gnet_property->props[56].data.guint32.value = (void *) &gnet_property_variable_dbg;
    gnet_property->props[56].data.guint32.choices = NULL;
    gnet_property->props[56].data.guint32.max   = 20;
    gnet_property->props[56].data.guint32.min   = 0;


    /*
     * PROP_BAN_DEBUG:
     *
     * General data:
     */
    gnet_property->props[57].name = "ban_debug";
    gnet_property->props[57].desc = _("Debug level for banning code.");
    gnet_property->props[57].ev_changed = event_new("ban_debug_changed");
    gnet_property->props[57].save = TRUE;
    gnet_property->props[57].vector_size = 1;
	mutex_init(&gnet_property->props[57].lock);

    /* Type specific data: */
    gnet_property->props[57].type               = PROP_TYPE_GUINT32;
    gnet_property->props[57].data.guint32.def   = (void *) &gnet_property_variable_ban_debug_default;
    gnet_property->props[57].data.guint32.value = (void *) &gnet_property_variable_ban_debug;
    gnet_property->props[57].data.guint32.choices = NULL;
    gnet_property->props[57].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[57].data.guint32.min   = 0x00000000;


    /*
     * PROP_CPU_DEBUG:
     *
     * General data:
     */
    gnet_property->props[58].name = "cpu_debug";
    gnet_property->props[58].desc = _("If not zero, periodic messages show the used CPU time.");
    gnet_property->props[58].ev_changed = event_new("cpu_debug_changed");
    gnet_property->props[58].save = TRUE;
    gnet_property->props[58].vector_size = 1;
	mutex_init(&gnet_property->props[58].lock);

    /* Type specific data: */
    gnet_property->props[58].type               = PROP_TYPE_GUINT32;
    gnet_property->props[58].data.guint32.def   = (void *) &gnet_property_variable_cpu_debug_default;
    gnet_property->props[58].data.guint32.value = (void *) &gnet_property_variable_cpu_debug;
    gnet_property->props[58].data.guint32.choices = NULL;
    gnet_property->props[58].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[58].data.guint32.min   = 0x00000000;


    /*
     * PROP_DMESH_DEBUG:
     *
     * General data:
     */
    gnet_property->props[59].name = "dmesh_debug";
    gnet_property->props[59].desc = _("Debug level for download mesh management.");
    gnet_property->props[59].ev_changed = event_new("dmesh_debug_changed");
    gnet_property->props[59].save = TRUE;
    gnet_property->props[59].vector_size = 1;
	mutex_init(&gnet_property->props[59].lock);

    /* Type specific data: */
    gnet_property->props[59].type               = PROP_TYPE_GUINT32;
    gnet_property->props[59].data.guint32.def   = (void *) &gnet_property_variable_dmesh_debug_default;
    gnet_property->props[59].data.guint32.value = (void *) &gnet_property_variable_dmesh_debug;
    gnet_property->props[59].data.guint32.choices = NULL;
    gnet_property->props[59].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[59].data.guint32.min   = 0x00000000;


    /*
     * PROP_GMSG_DEBUG:
     *
     * General data:
     */
    gnet_property->props[60].name = "gmsg_debug";
    gnet_property->props[60].desc = _("Debug level for Gnutella messages.");
    gnet_property->props[60].ev_changed = event_new("gmsg_debug_changed");
    gnet_property->props[60].save = TRUE;
    gnet_property->props[60].vector_size = 1;
	mutex_init(&gnet_property->props[60].lock);

    /* Type specific data: */
    gnet_property->props[60].type               = PROP_TYPE_GUINT32;
    gnet_property->props[60].data.guint32.def   = (void *) &gnet_property_variable_gmsg_debug_default;
    gnet_property->props[60].data.guint32.value = (void *) &gnet_property_variable_gmsg_debug;
    gnet_property->props[60].data.guint32.choices = NULL;
    gnet_property->props[60].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[60].data.guint32.min   = 0x00000000;


    /*
     * PROP_SHARE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[61].name = "share_debug";
    gnet_property->props[61].desc = _("Debug level for file sharing code.");
    gnet_property->props[61].ev_changed = event_new("share_debug_changed");
    gnet_property->props[61].save = TRUE;
    gnet_property->props[61].vector_size = 1;
	mutex_init(&gnet_property->props[61].lock);

    /* Type specific data: */
    gnet_property->props[61].type               = PROP_TYPE_GUINT32;
    gnet_property->props[61].data.guint32.def   = (void *) &gnet_property_variable_share_debug_default;
    gnet_property->props[61].data.guint32.value = (void *) &gnet_property_variable_share_debug;
    gnet_property->props[61].data.guint32.choices = NULL;
    gnet_property->props[61].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[61].data.guint32.min   = 0x00000000;


    /*
     * PROP_NODE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[62].name = "node_debug";
    gnet_property->props[62].desc = _("Debug level for Gnutella nodes.");
    gnet_property->props[62].ev_changed = event_new("node_debug_changed");
    gnet_property->props[62].save = TRUE;
    gnet_property->props[62].vector_size = 1;
	mutex_init(&gnet_property->props[62].lock);

    /* Type specific data: */
    gnet_property->props[62].type               = PROP_TYPE_GUINT32;
    gnet_property->props[62].data.guint32.def   = (void *) &gnet_property_variable_node_debug_default;
    gnet_property->props[62].data.guint32.value = (void *) &gnet_property_variable_node_debug;
    gnet_property->props[62].data.guint32.choices = NULL;
    gnet_property->props[62].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[62].data.guint32.min   = 0x00000000;


    /*
     * PROP_SOCKET_DEBUG:
     *
     * General data:
     */
    gnet_property->props[63].name = "socket_debug";
    gnet_property->props[63].desc = _("Debug level for sockets.");
    gnet_property->props[63].ev_changed = event_new("socket_debug_changed");
    gnet_property->props[63].save = TRUE;
    gnet_property->props[63].vector_size = 1;
	mutex_init(&gnet_property->props[63].lock);

    /* Type specific data: */
    gnet_property->props[63].type               = PROP_TYPE_GUINT32;
    gnet_property->props[63].data.guint32.def   = (void *) &gnet_property_variable_socket_debug_default;
    gnet_property->props[63].data.guint32.value = (void *) &gnet_property_variable_socket_debug;
    gnet_property->props[63].data.guint32.choices = NULL;
    gnet_property->props[63].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[63].data.guint32.min   = 0x00000000;


    /*
     * PROP_BOOTSTRAP_DEBUG:
     *
     * General data:
     */
    gnet_property->props[64].name = "bootstrap_debug";
    gnet_property->props[64].desc = _("Debug level for bootstrapping into the network.");
    gnet_property->props[64].ev_changed = event_new("bootstrap_debug_changed");
    gnet_property->props[64].save = TRUE;
    gnet_property->props[64].vector_size = 1;
	mutex_init(&gnet_property->props[64].lock);

    /* Type specific data: */
    gnet_property->props[64].type               = PROP_TYPE_GUINT32;
    gnet_property->props[64].data.guint32.def   = (void *) &gnet_property_variable_bootstrap_debug_default;
    gnet_property->props[64].data.guint32.value = (void *) &gnet_property_variable_bootstrap_debug;
    gnet_property->props[64].data.guint32.choices = NULL;
    gnet_property->props[64].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[64].data.guint32.min   = 0x00000000;


    /*
     * PROP_HTTP_DEBUG:
     *
     * General data:
     */
    gnet_property->props[65].name = "http_debug";
    gnet_property->props[65].desc = _("Debug level for HTTP code.");
    gnet_property->props[65].ev_changed = event_new("http_debug_changed");
    gnet_property->props[65].save = TRUE;
    gnet_property->props[65].vector_size = 1;
	mutex_init(&gnet_property->props[65].lock);

    /* Type specific data: */
    gnet_property->props[65].type               = PROP_TYPE_GUINT32;
    gnet_property->props[65].data.guint32.def   = (void *) &gnet_property_variable_http_debug_default;
    gnet_property->props[65].data.guint32.value = (void *) &gnet_property_variable_http_debug;
    gnet_property->props[65].data.guint32.choices = NULL;
    gnet_property->props[65].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[65].data.guint32.min   = 0x00000000;


    /*
     * PROP_DOWNLOAD_DEBUG:
     *
     * General data:
     */
    gnet_property->props[66].name = "download_debug";
    gnet_property->props[66].desc = _("Debug level for downloads.");
    gnet_property->props[66].ev_changed = event_new("download_debug_changed");
    gnet_property->props[66].save = TRUE;
    gnet_property->props[66].vector_size = 1;
	mutex_init(&gnet_property->props[66].lock);

    /* Type specific data: */
    gnet_property->props[66].type               = PROP_TYPE_GUINT32;
    gnet_property->props[66].data.guint32.def   = (void *) &gnet_property_variable_download_debug_default;
    gnet_property->props[66].data.guint32.value = (void *) &gnet_property_variable_download_debug;
    gnet_property->props[66].data.guint32.choices = NULL;
    gnet_property->props[66].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[66].data.guint32.min   = 0x00000000;


    /*
     * PROP_FILEINFO_DEBUG:
     *
     * General data:
     */
    gnet_property->props[67].name = "fileinfo_debug";
    gnet_property->props[67].desc = _("Debug level for fileinfo.");
    gnet_property->props[67].ev_changed = event_new("fileinfo_debug_changed");
    gnet_property->props[67].save = TRUE;
    gnet_property->props[67].vector_size = 1;
	mutex_init(&gnet_property->props[67].lock);

    /* Type specific data: */
    gnet_property->props[67].type               = PROP_TYPE_GUINT32;
    gnet_property->props[67].data.guint32.def   = (void *) &gnet_property_variable_fileinfo_debug_default;
    gnet_property->props[67].data.guint32.value = (void *) &gnet_property_variable_fileinfo_debug;
    gnet_property->props[67].data.guint32.choices = NULL;
    gnet_property->props[67].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[67].data.guint32.min   = 0x00000000;


    /*
     * PROP_UPLOAD_DEBUG:
     *
     * General data:
     */
    gnet_property->props[68].name = "upload_debug";
    gnet_property->props[68].desc = _("Debug level for uploads.");
    gnet_property->props[68].ev_changed = event_new("upload_debug_changed");
    gnet_property->props[68].save = TRUE;
    gnet_property->props[68].vector_size = 1;
	mutex_init(&gnet_property->props[68].lock);

    /* Type specific data: */
    gnet_property->props[68].type               = PROP_TYPE_GUINT32;
    gnet_property->props[68].data.guint32.def   = (void *) &gnet_property_variable_upload_debug_default;
    gnet_property->props[68].data.guint32.value = (void *) &gnet_property_variable_upload_debug;
    gnet_property->props[68].data.guint32.choices = NULL;
    gnet_property->props[68].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[68].data.guint32.min   = 0x00000000;


    /*
     * PROP_LIB_DEBUG:
     *
     * General data:
     */
    gnet_property->props[69].name = "lib_debug";
    gnet_property->props[69].desc = _("Debug level for code shared between gui and core.");
    gnet_property->props[69].ev_changed = event_new("lib_debug_changed");
    gnet_property->props[69].save = TRUE;
    gnet_property->props[69].vector_size = 1;
	mutex_init(&gnet_property->props[69].lock);

    /* Type specific data: */
    gnet_property->props[69].type               = PROP_TYPE_GUINT32;
    gnet_property->props[69].data.guint32.def   = (void *) &gnet_property_variable_lib_debug_default;
    gnet_property->props[69].data.guint32.value = (void *) &gnet_property_variable_lib_debug;
    gnet_property->props[69].data.guint32.choices = NULL;
    gnet_property->props[69].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[69].data.guint32.min   = 0x00000000;


    /*
     * PROP_BITZI_DEBUG:
     *
     * General data:
     */
    gnet_property->props[70].name = "bitzi_debug";
    gnet_property->props[70].desc = _("Verbosity of Bitzi related debug messages.");
    gnet_property->props[70].ev_changed = event_new("bitzi_debug_changed");
    gnet_property->props[70].save = TRUE;
    gnet_property->props[70].vector_size = 1;
	mutex_init(&gnet_property->props[70].lock);

    /* Type specific data: */
    gnet_property->props[70].type               = PROP_TYPE_GUINT32;
    gnet_property->props[70].data.guint32.def   = (void *) &gnet_property_variable_bitzi_debug_default;
    gnet_property->props[70].data.guint32.value = (void *) &gnet_property_variable_bitzi_debug;
    gnet_property->props[70].data.guint32.choices = NULL;
    gnet_property->props[70].data.guint32.max   = 20;
    gnet_property->props[70].data.guint32.min   = 0;


    /*
     * PROP_URL_DEBUG:
     *
     * General data:
     */
    gnet_property->props[71].name = "url_debug";
    gnet_property->props[71].desc = _("Verbosity of URL handling related debug messages.");
    gnet_property->props[71].ev_changed = event_new("url_debug_changed");
    gnet_property->props[71].save = TRUE;
    gnet_property->props[71].vector_size = 1;
	mutex_init(&gnet_property->props[71].lock);

    /* Type specific data: */
    gnet_property->props[71].type               = PROP_TYPE_GUINT32;
    gnet_property->props[71].data.guint32.def   = (void *) &gnet_property_variable_url_debug_default;
    gnet_property->props[71].data.guint32.value = (void *) &gnet_property_variable_url_debug;
    gnet_property->props[71].data.guint32.choices = NULL;
    gnet_property->props[71].data.guint32.max   = 20;
    gnet_property->props[71].data.guint32.min   = 0;


    /*
     * PROP_DH_DEBUG:
     *
     * General data:
     */
    gnet_property->props[72].name = "dh_debug";
    gnet_property->props[72].desc = _("Debug level for dynamic query hit routing.");
    gnet_property->props[72].ev_changed = event_new("dh_debug_changed");
    gnet_property->props[72].save = TRUE;
    gnet_property->props[72].vector_size = 1;
	mutex_init(&gnet_property->props[72].lock);

    /* Type specific data: */
    gnet_property->props[72].type               = PROP_TYPE_GUINT32;
    gnet_property->props[72].data.guint32.def   = (void *) &gnet_property_variable_dh_debug_default;
    gnet_property->props[72].data.guint32.value = (void *) &gnet_property_variable_dh_debug;
    gnet_property->props[72].data.guint32.choices = NULL;
    gnet_property->props[72].data.guint32.max   = 20;
    gnet_property->props[72].data.guint32.min   = 0;


    /*
     * PROP_DQ_DEBUG:
     *
     * General data:
     */
    gnet_property->props[73].name = "dq_debug";
    gnet_property->props[73].desc = _("Debug level for dynamic queries.");
    gnet_property->props[73].ev_changed = event_new("dq_debug_changed");
    gnet_property->props[73].save = TRUE;
    gnet_property->props[73].vector_size = 1;
	mutex_init(&gnet_property->props[73].lock);

    /* Type specific data: */
    gnet_property->props[73].type               = PROP_TYPE_GUINT32;
    gnet_property->props[73].data.guint32.def   = (void *) &gnet_property_variable_dq_debug_default;
    gnet_property->props[73].data.guint32.value = (void *) &gnet_property_variable_dq_debug;
    gnet_property->props[73].data.guint32.choices = NULL;
    gnet_property->props[73].data.guint32.max   = 20;
    gnet_property->props[73].data.guint32.min   = 0;


    /*
     * PROP_VMSG_DEBUG:
     *
     * General data:
     */
    gnet_property->props[74].name = "vmsg_debug";
    gnet_property->props[74].desc = _("Debug level for vendor messages.");
    gnet_property->props[74].ev_changed = event_new("vmsg_debug_changed");
    gnet_property->props[74].save = TRUE;
    gnet_property->props[74].vector_size = 1;
	mutex_init(&gnet_property->props[74].lock);

    /* Type specific data: */
    gnet_property->props[74].type               = PROP_TYPE_GUINT32;
    gnet_property->props[74].data.guint32.def   = (void *) &gnet_property_variable_vmsg_debug_default;
    gnet_property->props[74].data.guint32.value = (void *) &gnet_property_variable_vmsg_debug;
    gnet_property->props[74].data.guint32.choices = NULL;
    gnet_property->props[74].data.guint32.max   = 20;
    gnet_property->props[74].data.guint32.min   = 0;


    /*
     * PROP_QUERY_DEBUG:
     *
     * General data:
     */
    gnet_property->props[75].name = "query_debug";
    gnet_property->props[75].desc = _("Debug level for queries.");
    gnet_property->props[75].ev_changed = event_new("query_debug_changed");
    gnet_property->props[75].save = TRUE;
    gnet_property->props[75].vector_size = 1;
	mutex_init(&gnet_property->props[75].lock);

    /* Type specific data: */
    gnet_property->props[75].type               = PROP_TYPE_GUINT32;
    gnet_property->props[75].data.guint32.def   = (void *) &gnet_property_variable_query_debug_default;
    gnet_property->props[75].data.guint32.value = (void *) &gnet_property_variable_query_debug;
    gnet_property->props[75].data.guint32.choices = NULL;
    gnet_property->props[75].data.guint32.max   = 20;
    gnet_property->props[75].data.guint32.min   = 0;


    /*
     * PROP_SEARCH_DEBUG:
     *
     * General data:
     */
    gnet_property->props[76].name = "search_debug";
    gnet_property->props[76].desc = _("Debug level for searches and search results management.");
    gnet_property->props[76].ev_changed = event_new("search_debug_changed");
    gnet_property->props[76].save = TRUE;
    gnet_property->props[76].vector_size = 1;
	mutex_init(&gnet_property->props[76].lock);

    /* Type specific data: */
    gnet_property->props[76].type               = PROP_TYPE_GUINT32;
    gnet_property->props[76].data.guint32.def   = (void *) &gnet_property_variable_search_debug_default;
    gnet_property->props[76].data.guint32.value = (void *) &gnet_property_variable_search_debug;
    gnet_property->props[76].data.guint32.choices = NULL;
    gnet_property->props[76].data.guint32.max   = 20;
    gnet_property->props[76].data.guint32.min   = 0;


    /*
     * PROP_UDP_DEBUG:
     *
     * General data:
     */
    gnet_property->props[77].name = "udp_debug";
    gnet_property->props[77].desc = _("Debug level for the UDP traffic layer.");
    gnet_property->props[77].ev_changed = event_new("udp_debug_changed");
    gnet_property->props[77].save = TRUE;
    gnet_property->props[77].vector_size = 1;
	mutex_init(&gnet_property->props[77].lock);

    /* Type specific data: */
    gnet_property->props[77].type               = PROP_TYPE_GUINT32;
    gnet_property->props[77].data.guint32.def   = (void *) &gnet_property_variable_udp_debug_default;
    gnet_property->props[77].data.guint32.value = (void *) &gnet_property_variable_udp_debug;
    gnet_property->props[77].data.guint32.choices = NULL;
    gnet_property->props[77].data.guint32.max   = 20;
    gnet_property->props[77].data.guint32.min   = 0;


    /*
     * PROP_QRP_DEBUG:
     *
     * General data:
     */
    gnet_property->props[78].name = "qrp_debug";
    gnet_property->props[78].desc = _("Debug level for the Query Routing Protocol.");
    gnet_property->props[78].ev_changed = event_new("qrp_debug_changed");
    gnet_property->props[78].save = TRUE;
    gnet_property->props[78].vector_size = 1;
	mutex_init(&gnet_property->props[78].lock);

    /* Type specific data: */
    gnet_property->props[78].type               = PROP_TYPE_GUINT32;
    gnet_property->props[78].data.guint32.def   = (void *) &gnet_property_variable_qrp_debug_default;
    gnet_property->props[78].data.guint32.value = (void *) &gnet_property_variable_qrp_debug;
    gnet_property->props[78].data.guint32.choices = NULL;
    gnet_property->props[78].data.guint32.max   = 20;
    gnet_property->props[78].data.guint32.min   = 0;


    /*
     * PROP_ROUTING_DEBUG:
     *
     * General data:
     */
    gnet_property->props[79].name = "routing_debug";
    gnet_property->props[79].desc = _("Debug level for message routing.");
    gnet_property->props[79].ev_changed = event_new("routing_debug_changed");
    gnet_property->props[79].save = TRUE;
    gnet_property->props[79].vector_size = 1;
	mutex_init(&gnet_property->props[79].lock);

    /* Type specific data: */
    gnet_property->props[79].type               = PROP_TYPE_GUINT32;
    gnet_property->props[79].data.guint32.def   = (void *) &gnet_property_variable_routing_debug_default;
    gnet_property->props[79].data.guint32.value = (void *) &gnet_property_variable_routing_debug;
    gnet_property->props[79].data.guint32.choices = NULL;
    gnet_property->props[79].data.guint32.max   = 20;
    gnet_property->props[79].data.guint32.min   = 0;


    /*
     * PROP_GGEP_DEBUG:
     *
     * General data:
     */
    gnet_property->props[80].name = "ggep_debug";
    gnet_property->props[80].desc = _("Debug level for GGEP.");
    gnet_property->props[80].ev_changed = event_new("ggep_debug_changed");
    gnet_property->props[80].save = TRUE;
    gnet_property->props[80].vector_size = 1;
	mutex_init(&gnet_property->props[80].lock);

    /* Type specific data: */
    gnet_property->props[80].type               = PROP_TYPE_GUINT32;
    gnet_property->props[80].data.guint32.def   = (void *) &gnet_property_variable_ggep_debug_default;
    gnet_property->props[80].data.guint32.value = (void *) &gnet_property_variable_ggep_debug;
    gnet_property->props[80].data.guint32.choices = NULL;
    gnet_property->props[80].data.guint32.max   = 20;
    gnet_property->props[80].data.guint32.min   = 0;


    /*
     * PROP_PCACHE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[81].name = "pcache_debug";
    gnet_property->props[81].desc = _("Debug level for pong caching.");
    gnet_property->props[81].ev_changed = event_new("pcache_debug_changed");
    gnet_property->props[81].save = TRUE;
    gnet_property->props[81].vector_size = 1;
	mutex_init(&gnet_property->props[81].lock);

    /* Type specific data: */
    gnet_property->props[81].type               = PROP_TYPE_GUINT32;
    gnet_property->props[81].data.guint32.def   = (void *) &gnet_property_variable_pcache_debug_default;
    gnet_property->props[81].data.guint32.value = (void *) &gnet_property_variable_pcache_debug;
    gnet_property->props[81].data.guint32.choices = NULL;
    gnet_property->props[81].data.guint32.max   = 20;
    gnet_property->props[81].data.guint32.min   = 0;


    /*
     * PROP_HSEP_DEBUG:
     *
     * General data:
     */
    gnet_property->props[82].name = "hsep_debug";
    gnet_property->props[82].desc = _("Debug level for HSEP.");
    gnet_property->props[82].ev_changed = event_new("hsep_debug_changed");
    gnet_property->props[82].save = TRUE;
    gnet_property->props[82].vector_size = 1;
	mutex_init(&gnet_property->props[82].lock);

    /* Type specific data: */
    gnet_property->props[82].type               = PROP_TYPE_GUINT32;
    gnet_property->props[82].data.guint32.def   = (void *) &gnet_property_variable_hsep_debug_default;
    gnet_property->props[82].data.guint32.value = (void *) &gnet_property_variable_hsep_debug;
    gnet_property->props[82].data.guint32.choices = NULL;
    gnet_property->props[82].data.guint32.max   = 20;
    gnet_property->props[82].data.guint32.min   = 0;


    /*
     * PROP_TLS_DEBUG:
     *
     * General data:
     */
    gnet_property->props[83].name = "tls_debug";
    gnet_property->props[83].desc = _("Debug level for TLS.");
    gnet_property->props[83].ev_changed = event_new("tls_debug_changed");
    gnet_property->props[83].save = TRUE;
    gnet_property->props[83].vector_size = 1;
	mutex_init(&gnet_property->props[83].lock);

    /* Type specific data: */
    gnet_property->props[83].type               = PROP_TYPE_GUINT32;
    gnet_property->props[83].data.guint32.def   = (void *) &gnet_property_variable_tls_debug_default;
    gnet_property->props[83].data.guint32.value = (void *) &gnet_property_variable_tls_debug;
    gnet_property->props[83].data.guint32.choices = NULL;
    gnet_property->props[83].data.guint32.max   = 20;
    gnet_property->props[83].data.guint32.min   = 0;


    /*
     * PROP_PARQ_DEBUG:
     *
     * General data:
     */
    gnet_property->props[84].name = "parq_debug";
    gnet_property->props[84].desc = _("Debug level for PARQ.");
    gnet_property->props[84].ev_changed = event_new("parq_debug_changed");
    gnet_property->props[84].save = TRUE;
    gnet_property->props[84].vector_size = 1;
	mutex_init(&gnet_property->props[84].lock);

    /* Type specific data: */
    gnet_property->props[84].type               = PROP_TYPE_GUINT32;
    gnet_property->props[84].data.guint32.def   = (void *) &gnet_property_variable_parq_debug_default;
    gnet_property->props[84].data.guint32.value = (void *) &gnet_property_variable_parq_debug;
    gnet_property->props[84].data.guint32.choices = NULL;
    gnet_property->props[84].data.guint32.max   = 20;
    gnet_property->props[84].data.guint32.min   = 0;


    /*
     * PROP_PARQ_OPTIMISTIC:
     *
     * General data:
     */
    gnet_property->props[85].name = "parq_optimistic";
    gnet_property->props[85].desc = _("If set, PARQ will calculate its ETA and retry times more optimistically. If not set PARQ will calculate using a worst case scenario.  The default is to be optimistic.");
    gnet_property->props[85].ev_changed = event_new("parq_optimistic_changed");
    gnet_property->props[85].save = TRUE;
    gnet_property->props[85].vector_size = 1;
	mutex_init(&gnet_property->props[85].lock);

    /* Type specific data: */
    gnet_property->props[85].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[85].data.boolean.def   = (void *) &gnet_property_variable_parq_optimistic_default;
    gnet_property->props[85].data.boolean.value = (void *) &gnet_property_variable_parq_optimistic;


    /*
     * PROP_PARQ_SIZE_ALWAYS_CONTINUE:
     *
     * General data:
     */
    gnet_property->props[86].name = "parq_size_always_continue";
    gnet_property->props[86].desc = _("Maximum size in bytes of an upload which PARQ shall not queue and is always allowed to continue. However, if a client requests small chunks over and over the chunk sizes previously requested and uploaded are also counted.  If the size requested is greater than the threshold then, and only then, we look at the theoretical time it would take to serve the whole amount to see whether we can still bypass queuing. Set to 0 to disable this size-based bypassing feature and only rely on time-based bypassing.");
    gnet_property->props[86].ev_changed = event_new("parq_size_always_continue_changed");
    gnet_property->props[86].save = TRUE;
    gnet_property->props[86].vector_size = 1;
	mutex_init(&gnet_property->props[86].lock);

    /* Type specific data: */
    gnet_property->props[86].type               = PROP_TYPE_GUINT32;
    gnet_property->props[86].data.guint32.def   = (void *) &gnet_property_variable_parq_size_always_continue_default;
    gnet_property->props[86].data.guint32.value = (void *) &gnet_property_variable_parq_size_always_continue;
    gnet_property->props[86].data.guint32.choices = NULL;
    gnet_property->props[86].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[86].data.guint32.min   = 0x00000000;


    /*
     * PROP_PARQ_TIME_ALWAYS_CONTINUE:
     *
     * General data:
     */
    gnet_property->props[87].name = "parq_time_always_continue";
    gnet_property->props[87].desc = _("When an upload is expected to take less than this setting in seconds, PARQ will be instructed to not queue the upload. This check is done AFTER the file size-based bypassing. Set to 0 to disable this time-based bypassing feature.");
    gnet_property->props[87].ev_changed = event_new("parq_time_always_continue_changed");
    gnet_property->props[87].save = TRUE;
    gnet_property->props[87].vector_size = 1;
	mutex_init(&gnet_property->props[87].lock);

    /* Type specific data: */
    gnet_property->props[87].type               = PROP_TYPE_GUINT32;
    gnet_property->props[87].data.guint32.def   = (void *) &gnet_property_variable_parq_time_always_continue_default;
    gnet_property->props[87].data.guint32.value = (void *) &gnet_property_variable_parq_time_always_continue;
    gnet_property->props[87].data.guint32.choices = NULL;
    gnet_property->props[87].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[87].data.guint32.min   = 0x00000000;


    /*
     * PROP_PARQ_BAN_BAD_MAXCOUNTWAIT:
     *
     * General data:
     */
    gnet_property->props[88].name = "parq_ban_bad_maxcountwait";
    gnet_property->props[88].desc = _("Ban the client if it violates the Retry-After interval too often. Set this to 0 to disable the banning. The upload will be removed from the queue in any case though. Default is 10, so the client is banned after retrying too soon 10 times, which is a good balance between abuse and legacy client support.");
    gnet_property->props[88].ev_changed = event_new("parq_ban_bad_maxcountwait_changed");
    gnet_property->props[88].save = TRUE;
    gnet_property->props[88].vector_size = 1;
	mutex_init(&gnet_property->props[88].lock);

    /* Type specific data: */
    gnet_property->props[88].type               = PROP_TYPE_GUINT32;
    gnet_property->props[88].data.guint32.def   = (void *) &gnet_property_variable_parq_ban_bad_maxcountwait_default;
    gnet_property->props[88].data.guint32.value = (void *) &gnet_property_variable_parq_ban_bad_maxcountwait;
    gnet_property->props[88].data.guint32.choices = NULL;
    gnet_property->props[88].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[88].data.guint32.min   = 0x00000000;


    /*
     * PROP_TRACK_PROPS:
     *
     * General data:
     */
    gnet_property->props[89].name = "track_props";
    gnet_property->props[89].desc = _("For development use: track properties.");
    gnet_property->props[89].ev_changed = event_new("track_props_changed");
    gnet_property->props[89].save = TRUE;
    gnet_property->props[89].vector_size = 1;
	mutex_init(&gnet_property->props[89].lock);

    /* Type specific data: */
    gnet_property->props[89].type               = PROP_TYPE_GUINT32;
    gnet_property->props[89].data.guint32.def   = (void *) &gnet_property_variable_track_props_default;
    gnet_property->props[89].data.guint32.value = (void *) &gnet_property_variable_track_props;
    gnet_property->props[89].data.guint32.choices = NULL;
    gnet_property->props[89].data.guint32.max   = 20;
    gnet_property->props[89].data.guint32.min   = 0;


    /*
     * PROP_STOP_HOST_GET:
     *
     * General data:
     */
    gnet_property->props[90].name = "stop_host_get";
    gnet_property->props[90].desc = _("For development use: don't add new hosts to the host cache.");
    gnet_property->props[90].ev_changed = event_new("stop_host_get_changed");
    gnet_property->props[90].save = TRUE;
    gnet_property->props[90].vector_size = 1;
	mutex_init(&gnet_property->props[90].lock);

    /* Type specific data: */
    gnet_property->props[90].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[90].data.boolean.def   = (void *) &gnet_property_variable_stop_host_get_default;
    gnet_property->props[90].data.boolean.value = (void *) &gnet_property_variable_stop_host_get;


    /*
     * PROP_BW_HTTP_IN_ENABLED:
     *
     * General data:
     */
    gnet_property->props[91].name = "bandwidth_input_limit";
    gnet_property->props[91].desc = _("Enable bandwidth limitation for incoming HTTP traffic.");
    gnet_property->props[91].ev_changed = event_new("bw_http_in_enabled_changed");
    gnet_property->props[91].save = TRUE;
    gnet_property->props[91].vector_size = 1;
	mutex_init(&gnet_property->props[91].lock);

    /* Type specific data: */
    gnet_property->props[91].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[91].data.boolean.def   = (void *) &gnet_property_variable_bws_in_enabled_default;
    gnet_property->props[91].data.boolean.value = (void *) &gnet_property_variable_bws_in_enabled;


    /*
     * PROP_BW_HTTP_OUT_ENABLED:
     *
     * General data:
     */
    gnet_property->props[92].name = "bandwidth_output_limit";
    gnet_property->props[92].desc = _("Enable bandwidth limitation for outgoing HTTP traffic.");
    gnet_property->props[92].ev_changed = event_new("bw_http_out_enabled_changed");
    gnet_property->props[92].save = TRUE;
    gnet_property->props[92].vector_size = 1;
	mutex_init(&gnet_property->props[92].lock);

    /* Type specific data: */
    gnet_property->props[92].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[92].data.boolean.def   = (void *) &gnet_property_variable_bws_out_enabled_default;
    gnet_property->props[92].data.boolean.value = (void *) &gnet_property_variable_bws_out_enabled;


    /*
     * PROP_BW_GNET_IN_ENABLED:
     *
     * General data:
     */
    gnet_property->props[93].name = "bandwidth_ginput_limit";
    gnet_property->props[93].desc = _("Enable bandwidth limitation for incoming Gnet traffic.");
    gnet_property->props[93].ev_changed = event_new("bw_gnet_in_enabled_changed");
    gnet_property->props[93].save = TRUE;
    gnet_property->props[93].vector_size = 1;
	mutex_init(&gnet_property->props[93].lock);

    /* Type specific data: */
    gnet_property->props[93].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[93].data.boolean.def   = (void *) &gnet_property_variable_bws_gin_enabled_default;
    gnet_property->props[93].data.boolean.value = (void *) &gnet_property_variable_bws_gin_enabled;


    /*
     * PROP_BW_GNET_LEAF_IN_ENABLED:
     *
     * General data:
     */
    gnet_property->props[94].name = "bandwidth_glinput_limit";
    gnet_property->props[94].desc = _("Enable bandwidth limitation for incoming Gnet leaf traffic.");
    gnet_property->props[94].ev_changed = event_new("bw_gnet_leaf_in_enabled_changed");
    gnet_property->props[94].save = TRUE;
    gnet_property->props[94].vector_size = 1;
	mutex_init(&gnet_property->props[94].lock);

    /* Type specific data: */
    gnet_property->props[94].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[94].data.boolean.def   = (void *) &gnet_property_variable_bws_glin_enabled_default;
    gnet_property->props[94].data.boolean.value = (void *) &gnet_property_variable_bws_glin_enabled;


    /*
     * PROP_BW_GNET_OUT_ENABLED:
     *
     * General data:
     */
    gnet_property->props[95].name = "bandwidth_goutput_limit";
    gnet_property->props[95].desc = _("Enable bandwidth limitation for outgoing Gnet traffic.");
    gnet_property->props[95].ev_changed = event_new("bw_gnet_out_enabled_changed");
    gnet_property->props[95].save = TRUE;
    gnet_property->props[95].vector_size = 1;
	mutex_init(&gnet_property->props[95].lock);

    /* Type specific data: */
    gnet_property->props[95].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[95].data.boolean.def   = (void *) &gnet_property_variable_bws_gout_enabled_default;
    gnet_property->props[95].data.boolean.value = (void *) &gnet_property_variable_bws_gout_enabled;


    /*
     * PROP_BW_GNET_LEAF_OUT_ENABLED:
     *
     * General data:
     */
    gnet_property->props[96].name = "bandwidth_gloutput_limit";
    gnet_property->props[96].desc = _("Enable bandwidth limitation for outgoing Gnet leaf traffic.");
    gnet_property->props[96].ev_changed = event_new("bw_gnet_leaf_out_enabled_changed");
    gnet_property->props[96].save = TRUE;
    gnet_property->props[96].vector_size = 1;
	mutex_init(&gnet_property->props[96].lock);

    /* Type specific data: */
    gnet_property->props[96].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[96].data.boolean.def   = (void *) &gnet_property_variable_bws_glout_enabled_default;
    gnet_property->props[96].data.boolean.value = (void *) &gnet_property_variable_bws_glout_enabled;


    /*
     * PROP_BW_UL_USAGE_ENABLED:
     *
     * General data:
     */
    gnet_property->props[97].name = "bw_ul_usage_enabled";
    gnet_property->props[97].desc = _("Enable dynamic upload slots allocation.");
    gnet_property->props[97].ev_changed = event_new("bw_ul_usage_enabled_changed");
    gnet_property->props[97].save = TRUE;
    gnet_property->props[97].vector_size = 1;
	mutex_init(&gnet_property->props[97].lock);

    /* Type specific data: */
    gnet_property->props[97].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[97].data.boolean.def   = (void *) &gnet_property_variable_bw_ul_usage_enabled_default;
    gnet_property->props[97].data.boolean.value = (void *) &gnet_property_variable_bw_ul_usage_enabled;


    /*
     * PROP_BW_ALLOW_STEALING:
     *
     * General data:
     */
    gnet_property->props[98].name = "bw_allow_stealing";
    gnet_property->props[98].desc = _("Allow HTTP and Gnutella to grab whatever bandwidth the other is not using.  If FALSE, unused bandwidth is lost.");
    gnet_property->props[98].ev_changed = event_new("bw_allow_stealing_changed");
    gnet_property->props[98].save = TRUE;
    gnet_property->props[98].vector_size = 1;
	mutex_init(&gnet_property->props[98].lock);

    /* Type specific data: */
    gnet_property->props[98].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[98].data.boolean.def   = (void *) &gnet_property_variable_bw_allow_stealing_default;
    gnet_property->props[98].data.boolean.value = (void *) &gnet_property_variable_bw_allow_stealing;


    /*
     * PROP_AUTOCLEAR_COMPLETED_DOWNLOADS:
     *
     * General data:
     */
    gnet_property->props[99].name = "auto_clear_completed_downloads";
    gnet_property->props[99].desc = _("Auto clear completed downloads.");
    gnet_property->props[99].ev_changed = event_new("autoclear_completed_downloads_changed");
    gnet_property->props[99].save = TRUE;
    gnet_property->props[99].vector_size = 1;
	mutex_init(&gnet_property->props[99].lock);

    /* Type specific data: */
    gnet_property->props[99].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[99].data.boolean.def   = (void *) &gnet_property_variable_clear_complete_downloads_default;
    gnet_property->props[99].data.boolean.value = (void *) &gnet_property_variable_clear_complete_downloads;


    /*
     * PROP_AUTOCLEAR_FAILED_DOWNLOADS:
     *
     * General data:
     */
    gnet_property->props[100].name = "auto_clear_failed_downloads";
    gnet_property->props[100].desc = _("Auto clear failed downloads (HTTP error, failure to resume, write error, etc...).");
    gnet_property->props[100].ev_changed = event_new("autoclear_failed_downloads_changed");
    gnet_property->props[100].save = TRUE;
    gnet_property->props[100].vector_size = 1;
	mutex_init(&gnet_property->props[100].lock);

    /* Type specific data: */
    gnet_property->props[100].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[100].data.boolean.def   = (void *) &gnet_property_variable_clear_failed_downloads_default;
    gnet_property->props[100].data.boolean.value = (void *) &gnet_property_variable_clear_failed_downloads;


    /*
     * PROP_AUTOCLEAR_UNAVAILABLE_DOWNLOADS:
     *
     * General data:
     */
    gnet_property->props[101].name = "auto_clear_unavailable_downloads";
    gnet_property->props[101].desc = _("Auto clear unavailable downloads (connection timeout, push route lost, etc...).");
    gnet_property->props[101].ev_changed = event_new("autoclear_unavailable_downloads_changed");
    gnet_property->props[101].save = TRUE;
    gnet_property->props[101].vector_size = 1;
	mutex_init(&gnet_property->props[101].lock);

    /* Type specific data: */
    gnet_property->props[101].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[101].data.boolean.def   = (void *) &gnet_property_variable_clear_unavailable_downloads_default;
    gnet_property->props[101].data.boolean.value = (void *) &gnet_property_variable_clear_unavailable_downloads;


    /*
     * PROP_AUTOCLEAR_FINISHED_DOWNLOADS:
     *
     * General data:
     */
    gnet_property->props[102].name = "auto_clear_finished_downloads";
    gnet_property->props[102].desc = _("Auto clear finished downloads");
    gnet_property->props[102].ev_changed = event_new("autoclear_finished_downloads_changed");
    gnet_property->props[102].save = TRUE;
    gnet_property->props[102].vector_size = 1;
	mutex_init(&gnet_property->props[102].lock);

    /* Type specific data: */
    gnet_property->props[102].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[102].data.boolean.def   = (void *) &gnet_property_variable_clear_finished_downloads_default;
    gnet_property->props[102].data.boolean.value = (void *) &gnet_property_variable_clear_finished_downloads;


    /*
     * PROP_SEARCH_REMOVE_DOWNLOADED:
     *
     * General data:
     */
    gnet_property->props[103].name = "search_remove_downloaded";
    gnet_property->props[103].desc = _("Remove downloaded files from the search result.");
    gnet_property->props[103].ev_changed = event_new("search_remove_downloaded_changed");
    gnet_property->props[103].save = TRUE;
    gnet_property->props[103].vector_size = 1;
	mutex_init(&gnet_property->props[103].lock);

    /* Type specific data: */
    gnet_property->props[103].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[103].data.boolean.def   = (void *) &gnet_property_variable_search_remove_downloaded_default;
    gnet_property->props[103].data.boolean.value = (void *) &gnet_property_variable_search_remove_downloaded;


    /*
     * PROP_FORCE_LOCAL_IP:
     *
     * General data:
     */
    gnet_property->props[104].name = "force_local_ip";
    gnet_property->props[104].desc = _("Enable to use [forced_local_ip] as local ip.");
    gnet_property->props[104].ev_changed = event_new("force_local_ip_changed");
    gnet_property->props[104].save = TRUE;
    gnet_property->props[104].vector_size = 1;
	mutex_init(&gnet_property->props[104].lock);

    /* Type specific data: */
    gnet_property->props[104].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[104].data.boolean.def   = (void *) &gnet_property_variable_force_local_ip_default;
    gnet_property->props[104].data.boolean.value = (void *) &gnet_property_variable_force_local_ip;


    /*
     * PROP_FORCE_LOCAL_IP6:
     *
     * General data:
     */
    gnet_property->props[105].name = "force_local_ip6";
    gnet_property->props[105].desc = _("Enable to use [forced_local_ip6] as local ip.");
    gnet_property->props[105].ev_changed = event_new("force_local_ip6_changed");
    gnet_property->props[105].save = TRUE;
    gnet_property->props[105].vector_size = 1;
	mutex_init(&gnet_property->props[105].lock);

    /* Type specific data: */
    gnet_property->props[105].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[105].data.boolean.def   = (void *) &gnet_property_variable_force_local_ip6_default;
    gnet_property->props[105].data.boolean.value = (void *) &gnet_property_variable_force_local_ip6;


    /*
     * PROP_BIND_TO_FORCED_LOCAL_IP:
     *
     * General data:
     */
    gnet_property->props[106].name = "bind_to_forced_local_ip";
    gnet_property->props[106].desc = _("If 'forced_local_ip' is enabled, bind the socket to the forced IP address.");
    gnet_property->props[106].ev_changed = event_new("bind_to_forced_local_ip_changed");
    gnet_property->props[106].save = TRUE;
    gnet_property->props[106].vector_size = 1;
	mutex_init(&gnet_property->props[106].lock);

    /* Type specific data: */
    gnet_property->props[106].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[106].data.boolean.def   = (void *) &gnet_property_variable_bind_to_forced_local_ip_default;
    gnet_property->props[106].data.boolean.value = (void *) &gnet_property_variable_bind_to_forced_local_ip;


    /*
     * PROP_BIND_TO_FORCED_LOCAL_IP6:
     *
     * General data:
     */
    gnet_property->props[107].name = "bind_to_forced_local_ip6";
    gnet_property->props[107].desc = _("If 'forced_local_ip6' is enabled, bind the socket to the forced IP address.");
    gnet_property->props[107].ev_changed = event_new("bind_to_forced_local_ip6_changed");
    gnet_property->props[107].save = TRUE;
    gnet_property->props[107].vector_size = 1;
	mutex_init(&gnet_property->props[107].lock);

    /* Type specific data: */
    gnet_property->props[107].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[107].data.boolean.def   = (void *) &gnet_property_variable_bind_to_forced_local_ip6_default;
    gnet_property->props[107].data.boolean.value = (void *) &gnet_property_variable_bind_to_forced_local_ip6;


    /*
     * PROP_USE_NETMASKS:
     *
     * General data:
     */
    gnet_property->props[108].name = "use_netmasks";
    gnet_property->props[108].desc = _("Try to connect to local networks first.");
    gnet_property->props[108].ev_changed = event_new("use_netmasks_changed");
    gnet_property->props[108].save = TRUE;
    gnet_property->props[108].vector_size = 1;
	mutex_init(&gnet_property->props[108].lock);

    /* Type specific data: */
    gnet_property->props[108].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[108].data.boolean.def   = (void *) &gnet_property_variable_use_netmasks_default;
    gnet_property->props[108].data.boolean.value = (void *) &gnet_property_variable_use_netmasks;


    /*
     * PROP_ALLOW_PRIVATE_NETWORK_CONNECTION:
     *
     * General data:
     */
    gnet_property->props[109].name = "allow_private_network_connection";
    gnet_property->props[109].desc = _("Check this button if you want to use gtk-gnutella on your Local Area Network. RFC1918 will be ignored.");
    gnet_property->props[109].ev_changed = event_new("allow_private_network_connection_changed");
    gnet_property->props[109].save = TRUE;
    gnet_property->props[109].vector_size = 1;
	mutex_init(&gnet_property->props[109].lock);

    /* Type specific data: */
    gnet_property->props[109].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[109].data.boolean.def   = (void *) &gnet_property_variable_allow_private_network_connection_default;
    gnet_property->props[109].data.boolean.value = (void *) &gnet_property_variable_allow_private_network_connection;


    /*
     * PROP_USE_IP_TOS:
     *
     * General data:
     */
    gnet_property->props[110].name = "use_ip_tos";
    gnet_property->props[110].desc = _("Check this button if you want gtk-gnutella to use IP TOS to differentiate interactive, normal and bulk data. This is probably a good idea in most cases, and can particularly help with badly misconfigured hosts, LANs, and ISPs.");
    gnet_property->props[110].ev_changed = event_new("use_ip_tos_changed");
    gnet_property->props[110].save = TRUE;
    gnet_property->props[110].vector_size = 1;
	mutex_init(&gnet_property->props[110].lock);

    /* Type specific data: */
    gnet_property->props[110].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[110].data.boolean.def   = (void *) &gnet_property_variable_use_ip_tos_default;
    gnet_property->props[110].data.boolean.value = (void *) &gnet_property_variable_use_ip_tos;


    /*
     * PROP_DOWNLOAD_DELETE_ABORTED:
     *
     * General data:
     */
    gnet_property->props[111].name = "download_delete_aborted";
    gnet_property->props[111].desc = _("Remove files of aborted downloads from disk.");
    gnet_property->props[111].ev_changed = event_new("download_delete_aborted_changed");
    gnet_property->props[111].save = TRUE;
    gnet_property->props[111].vector_size = 1;
	mutex_init(&gnet_property->props[111].lock);

    /* Type specific data: */
    gnet_property->props[111].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[111].data.boolean.def   = (void *) &gnet_property_variable_download_delete_aborted_default;
    gnet_property->props[111].data.boolean.value = (void *) &gnet_property_variable_download_delete_aborted;


    /*
     * PROP_PROXY_AUTH:
     *
     * General data:
     */
    gnet_property->props[112].name = "proxy_auth";
    gnet_property->props[112].desc = _("Use username and password to authenticate to proxy.");
    gnet_property->props[112].ev_changed = event_new("proxy_auth_changed");
    gnet_property->props[112].save = TRUE;
    gnet_property->props[112].vector_size = 1;
	mutex_init(&gnet_property->props[112].lock);

    /* Type specific data: */
    gnet_property->props[112].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[112].data.boolean.def   = (void *) &gnet_property_variable_proxy_auth_default;
    gnet_property->props[112].data.boolean.value = (void *) &gnet_property_variable_proxy_auth;


    /*
     * PROP_SOCKS_USER:
     *
     * General data:
     */
    gnet_property->props[113].name = "socks_user";
    gnet_property->props[113].desc = _("Username for proxy.");
    gnet_property->props[113].ev_changed = event_new("socks_user_changed");
    gnet_property->props[113].save = TRUE;
    gnet_property->props[113].vector_size = 1;
	mutex_init(&gnet_property->props[113].lock);

    /* Type specific data: */
    gnet_property->props[113].type               = PROP_TYPE_STRING;
    gnet_property->props[113].data.string.def    = (void *) &gnet_property_variable_socks_user_default;
    gnet_property->props[113].data.string.value  = (void *) &gnet_property_variable_socks_user;
    if (gnet_property->props[113].data.string.def) {
        *gnet_property->props[113].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[113].data.string.def));
    }


    /*
     * PROP_SOCKS_PASS:
     *
     * General data:
     */
    gnet_property->props[114].name = "socks_pass";
    gnet_property->props[114].desc = _("Password for proxy.");
    gnet_property->props[114].ev_changed = event_new("socks_pass_changed");
    gnet_property->props[114].save = TRUE;
    gnet_property->props[114].vector_size = 1;
	mutex_init(&gnet_property->props[114].lock);

    /* Type specific data: */
    gnet_property->props[114].type               = PROP_TYPE_STRING;
    gnet_property->props[114].data.string.def    = (void *) &gnet_property_variable_socks_pass_default;
    gnet_property->props[114].data.string.value  = (void *) &gnet_property_variable_socks_pass;
    if (gnet_property->props[114].data.string.def) {
        *gnet_property->props[114].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[114].data.string.def));
    }


    /*
     * PROP_PROXY_ADDR:
     *
     * General data:
     */
    gnet_property->props[115].name = "proxy_addr";
    gnet_property->props[115].desc = _("Address of the proxy.");
    gnet_property->props[115].ev_changed = event_new("proxy_addr_changed");
    gnet_property->props[115].save = FALSE;
    gnet_property->props[115].vector_size = 1;
	mutex_init(&gnet_property->props[115].lock);

    /* Type specific data: */
    gnet_property->props[115].type               = PROP_TYPE_IP;
    gnet_property->props[115].data.ip.value = (void *) &gnet_property_variable_proxy_addr;


    /*
     * PROP_PROXY_HOSTNAME:
     *
     * General data:
     */
    gnet_property->props[116].name = "proxy_hostname";
    gnet_property->props[116].desc = _("Hostname of the proxy.");
    gnet_property->props[116].ev_changed = event_new("proxy_hostname_changed");
    gnet_property->props[116].save = TRUE;
    gnet_property->props[116].vector_size = 1;
	mutex_init(&gnet_property->props[116].lock);

    /* Type specific data: */
    gnet_property->props[116].type               = PROP_TYPE_STRING;
    gnet_property->props[116].data.string.def    = (void *) &gnet_property_variable_proxy_hostname_default;
    gnet_property->props[116].data.string.value  = (void *) &gnet_property_variable_proxy_hostname;
    if (gnet_property->props[116].data.string.def) {
        *gnet_property->props[116].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[116].data.string.def));
    }


    /*
     * PROP_PROXY_PORT:
     *
     * General data:
     */
    gnet_property->props[117].name = "proxy_port";
    gnet_property->props[117].desc = _("TCP Port the proxy is listening on.");
    gnet_property->props[117].ev_changed = event_new("proxy_port_changed");
    gnet_property->props[117].save = TRUE;
    gnet_property->props[117].vector_size = 1;
	mutex_init(&gnet_property->props[117].lock);

    /* Type specific data: */
    gnet_property->props[117].type               = PROP_TYPE_GUINT32;
    gnet_property->props[117].data.guint32.def   = (void *) &gnet_property_variable_proxy_port_default;
    gnet_property->props[117].data.guint32.value = (void *) &gnet_property_variable_proxy_port;
    gnet_property->props[117].data.guint32.choices = NULL;
    gnet_property->props[117].data.guint32.max   = 0xFFFF;
    gnet_property->props[117].data.guint32.min   = 0x0000;


    /*
     * PROP_PROXY_PROTOCOL:
     *
     * General data:
     */
    gnet_property->props[118].name = "proxy_protocol";
    gnet_property->props[118].desc = _("Protocol the proxy uses.");
    gnet_property->props[118].ev_changed = event_new("proxy_protocol_changed");
    gnet_property->props[118].save = TRUE;
    gnet_property->props[118].vector_size = 1;
	mutex_init(&gnet_property->props[118].lock);

    /* Type specific data: */
    gnet_property->props[118].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[118].data.guint32.def   = (void *) &gnet_property_variable_proxy_protocol_default;
    gnet_property->props[118].data.guint32.value = (void *) &gnet_property_variable_proxy_protocol;
    gnet_property->props[118].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[118].data.guint32.min   = 0x00000000;
    gnet_property->props[118].data.guint32.choices = (void *) &gnet_property_variable_proxy_protocol_choices;


    /*
     * PROP_NETWORK_PROTOCOL:
     *
     * General data:
     */
    gnet_property->props[119].name = "network_protocol";
    gnet_property->props[119].desc = _("Network protocols to use.");
    gnet_property->props[119].ev_changed = event_new("network_protocol_changed");
    gnet_property->props[119].save = TRUE;
    gnet_property->props[119].vector_size = 1;
	mutex_init(&gnet_property->props[119].lock);

    /* Type specific data: */
    gnet_property->props[119].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[119].data.guint32.def   = (void *) &gnet_property_variable_network_protocol_default;
    gnet_property->props[119].data.guint32.value = (void *) &gnet_property_variable_network_protocol;
    gnet_property->props[119].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[119].data.guint32.min   = 0x00000000;
    gnet_property->props[119].data.guint32.choices = (void *) &gnet_property_variable_network_protocol_choices;


    /*
     * PROP_USE_IPV6_TRT:
     *
     * General data:
     */
    gnet_property->props[120].name = "use_ipv6_trt";
    gnet_property->props[120].desc = _("Use an IPv6-to-IPv4 Transport Relay Translator asspecified by RFC 3142.");
    gnet_property->props[120].ev_changed = event_new("use_ipv6_trt_changed");
    gnet_property->props[120].save = TRUE;
    gnet_property->props[120].vector_size = 1;
	mutex_init(&gnet_property->props[120].lock);

    /* Type specific data: */
    gnet_property->props[120].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[120].data.boolean.def   = (void *) &gnet_property_variable_use_ipv6_trt_default;
    gnet_property->props[120].data.boolean.value = (void *) &gnet_property_variable_use_ipv6_trt;


    /*
     * PROP_IPV6_TRT_PREFIX:
     *
     * General data:
     */
    gnet_property->props[121].name = "ipv6_trt_prefix";
    gnet_property->props[121].desc = _("The IPv6 address prefix used by the IPv6-to-IPv4 Transport Relay Translator.");
    gnet_property->props[121].ev_changed = event_new("ipv6_trt_prefix_changed");
    gnet_property->props[121].save = TRUE;
    gnet_property->props[121].vector_size = 1;
	mutex_init(&gnet_property->props[121].lock);

    /* Type specific data: */
    gnet_property->props[121].type               = PROP_TYPE_IP;
    gnet_property->props[121].data.ip.value = (void *) &gnet_property_variable_ipv6_trt_prefix;


    /*
     * PROP_HOSTS_IN_CATCHER:
     *
     * General data:
     */
    gnet_property->props[122].name = "hosts_in_catcher";
    gnet_property->props[122].desc = _("Current number of hosts in regular node caches.");
    gnet_property->props[122].ev_changed = event_new("hosts_in_catcher_changed");
    gnet_property->props[122].save = FALSE;
    gnet_property->props[122].vector_size = 1;
	mutex_init(&gnet_property->props[122].lock);

    /* Type specific data: */
    gnet_property->props[122].type               = PROP_TYPE_GUINT32;
    gnet_property->props[122].data.guint32.def   = (void *) &gnet_property_variable_hosts_in_catcher_default;
    gnet_property->props[122].data.guint32.value = (void *) &gnet_property_variable_hosts_in_catcher;
    gnet_property->props[122].data.guint32.choices = NULL;
    gnet_property->props[122].data.guint32.max   = INT_MAX;
    gnet_property->props[122].data.guint32.min   = 0;


    /*
     * PROP_HOSTS_IN_ULTRA_CATCHER:
     *
     * General data:
     */
    gnet_property->props[123].name = "hosts_in_ultra_catcher";
    gnet_property->props[123].desc = _("Current number of IPv4 hosts in ultra node caches.");
    gnet_property->props[123].ev_changed = event_new("hosts_in_ultra_catcher_changed");
    gnet_property->props[123].save = FALSE;
    gnet_property->props[123].vector_size = 1;
	mutex_init(&gnet_property->props[123].lock);

    /* Type specific data: */
    gnet_property->props[123].type               = PROP_TYPE_GUINT32;
    gnet_property->props[123].data.guint32.def   = (void *) &gnet_property_variable_hosts_in_ultra_catcher_default;
    gnet_property->props[123].data.guint32.value = (void *) &gnet_property_variable_hosts_in_ultra_catcher;
    gnet_property->props[123].data.guint32.choices = NULL;
    gnet_property->props[123].data.guint32.max   = INT_MAX;
    gnet_property->props[123].data.guint32.min   = 0;


    /*
     * PROP_HOSTS_IN_BAD_CATCHER:
     *
     * General data:
     */
    gnet_property->props[124].name = "hosts_in_bad_catcher";
    gnet_property->props[124].desc = _("Current number of hosts in bad node caches.");
    gnet_property->props[124].ev_changed = event_new("hosts_in_bad_catcher_changed");
    gnet_property->props[124].save = FALSE;
    gnet_property->props[124].vector_size = 1;
	mutex_init(&gnet_property->props[124].lock);

    /* Type specific data: */
    gnet_property->props[124].type               = PROP_TYPE_GUINT32;
    gnet_property->props[124].data.guint32.def   = (void *) &gnet_property_variable_hosts_in_bad_catcher_default;
    gnet_property->props[124].data.guint32.value = (void *) &gnet_property_variable_hosts_in_bad_catcher;
    gnet_property->props[124].data.guint32.choices = NULL;
    gnet_property->props[124].data.guint32.max   = INT_MAX;
    gnet_property->props[124].data.guint32.min   = 0;


    /*
     * PROP_MAX_HOSTS_CACHED:
     *
     * General data:
     */
    gnet_property->props[125].name = "max_hosts_cached";
    gnet_property->props[125].desc = _("Maximum number of hosts in the regular node cache.");
    gnet_property->props[125].ev_changed = event_new("max_hosts_cached_changed");
    gnet_property->props[125].save = TRUE;
    gnet_property->props[125].vector_size = 1;
	mutex_init(&gnet_property->props[125].lock);

    /* Type specific data: */
    gnet_property->props[125].type               = PROP_TYPE_GUINT32;
    gnet_property->props[125].data.guint32.def   = (void *) &gnet_property_variable_max_hosts_cached_default;
    gnet_property->props[125].data.guint32.value = (void *) &gnet_property_variable_max_hosts_cached;
    gnet_property->props[125].data.guint32.choices = NULL;
    gnet_property->props[125].data.guint32.max   = 50000;
    gnet_property->props[125].data.guint32.min   = 100;


    /*
     * PROP_MAX_ULTRA_HOSTS_CACHED:
     *
     * General data:
     */
    gnet_property->props[126].name = "max_ultra_hosts_cached";
    gnet_property->props[126].desc = _("Maximum number of IPv4 hosts in the ultra node cache.");
    gnet_property->props[126].ev_changed = event_new("max_ultra_hosts_cached_changed");
    gnet_property->props[126].save = TRUE;
    gnet_property->props[126].vector_size = 1;
	mutex_init(&gnet_property->props[126].lock);

    /* Type specific data: */
    gnet_property->props[126].type               = PROP_TYPE_GUINT32;
    gnet_property->props[126].data.guint32.def   = (void *) &gnet_property_variable_max_ultra_hosts_cached_default;
    gnet_property->props[126].data.guint32.value = (void *) &gnet_property_variable_max_ultra_hosts_cached;
    gnet_property->props[126].data.guint32.choices = NULL;
    gnet_property->props[126].data.guint32.max   = 50000;
    gnet_property->props[126].data.guint32.min   = 100;


    /*
     * PROP_MAX_BAD_HOSTS_CACHED:
     *
     * General data:
     */
    gnet_property->props[127].name = "max_bad_hosts_cached";
    gnet_property->props[127].desc = _("Maximum number of hosts in the BUSY, UNSTABLE and TIMEOUT lists.");
    gnet_property->props[127].ev_changed = event_new("max_bad_hosts_cached_changed");
    gnet_property->props[127].save = TRUE;
    gnet_property->props[127].vector_size = 1;
	mutex_init(&gnet_property->props[127].lock);

    /* Type specific data: */
    gnet_property->props[127].type               = PROP_TYPE_GUINT32;
    gnet_property->props[127].data.guint32.def   = (void *) &gnet_property_variable_max_bad_hosts_cached_default;
    gnet_property->props[127].data.guint32.value = (void *) &gnet_property_variable_max_bad_hosts_cached;
    gnet_property->props[127].data.guint32.choices = NULL;
    gnet_property->props[127].data.guint32.max   = 50000;
    gnet_property->props[127].data.guint32.min   = 100;


    /*
     * PROP_MAX_HIGH_TTL_MSG:
     *
     * General data:
     */
    gnet_property->props[128].name = "max_high_ttl_msg";
    gnet_property->props[128].desc = _("Amount of tolerable messages above hard TTL limit per node. See also MAX_HIGH_TTL_RADIUS");
    gnet_property->props[128].ev_changed = event_new("max_high_ttl_msg_changed");
    gnet_property->props[128].save = TRUE;
    gnet_property->props[128].vector_size = 1;
	mutex_init(&gnet_property->props[128].lock);

    /* Type specific data: */
    gnet_property->props[128].type               = PROP_TYPE_GUINT32;
    gnet_property->props[128].data.guint32.def   = (void *) &gnet_property_variable_max_high_ttl_msg_default;
    gnet_property->props[128].data.guint32.value = (void *) &gnet_property_variable_max_high_ttl_msg;
    gnet_property->props[128].data.guint32.choices = NULL;
    gnet_property->props[128].data.guint32.max   = 10000;
    gnet_property->props[128].data.guint32.min   = 0;


    /*
     * PROP_MAX_HIGH_TTL_RADIUS:
     *
     * General data:
     */
    gnet_property->props[129].name = "max_high_ttl_radius";
    gnet_property->props[129].desc = _("Hop radius for counting high TTL limit messages (# hops lower than...). See also MAX_HIGH_TTL_MSG");
    gnet_property->props[129].ev_changed = event_new("max_high_ttl_radius_changed");
    gnet_property->props[129].save = TRUE;
    gnet_property->props[129].vector_size = 1;
	mutex_init(&gnet_property->props[129].lock);

    /* Type specific data: */
    gnet_property->props[129].type               = PROP_TYPE_GUINT32;
    gnet_property->props[129].data.guint32.def   = (void *) &gnet_property_variable_max_high_ttl_radius_default;
    gnet_property->props[129].data.guint32.value = (void *) &gnet_property_variable_max_high_ttl_radius;
    gnet_property->props[129].data.guint32.choices = NULL;
    gnet_property->props[129].data.guint32.max   = 10;
    gnet_property->props[129].data.guint32.min   = 0;


    /*
     * PROP_BW_HTTP_IN:
     *
     * General data:
     */
    gnet_property->props[130].name = "input_bandwidth";
    gnet_property->props[130].desc = _("Bandwidth limit for incoming HTTP traffic in bytes/sec.");
    gnet_property->props[130].ev_changed = event_new("bw_http_in_changed");
    gnet_property->props[130].save = TRUE;
    gnet_property->props[130].vector_size = 1;
	mutex_init(&gnet_property->props[130].lock);

    /* Type specific data: */
    gnet_property->props[130].type               = PROP_TYPE_GUINT32;
    gnet_property->props[130].data.guint32.def   = (void *) &gnet_property_variable_bw_http_in_default;
    gnet_property->props[130].data.guint32.value = (void *) &gnet_property_variable_bw_http_in;
    gnet_property->props[130].data.guint32.choices = NULL;
    gnet_property->props[130].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[130].data.guint32.min   = 1024;


    /*
     * PROP_BW_HTTP_OUT:
     *
     * General data:
     */
    gnet_property->props[131].name = "output_bandwidth";
    gnet_property->props[131].desc = _("Bandwidth limit for outgoing HTTP traffic in bytes/sec.");
    gnet_property->props[131].ev_changed = event_new("bw_http_out_changed");
    gnet_property->props[131].save = TRUE;
    gnet_property->props[131].vector_size = 1;
	mutex_init(&gnet_property->props[131].lock);

    /* Type specific data: */
    gnet_property->props[131].type               = PROP_TYPE_GUINT32;
    gnet_property->props[131].data.guint32.def   = (void *) &gnet_property_variable_bw_http_out_default;
    gnet_property->props[131].data.guint32.value = (void *) &gnet_property_variable_bw_http_out;
    gnet_property->props[131].data.guint32.choices = NULL;
    gnet_property->props[131].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[131].data.guint32.min   = 1024;


    /*
     * PROP_BW_GNET_IN:
     *
     * General data:
     */
    gnet_property->props[132].name = "input_gnet_bandwidth";
    gnet_property->props[132].desc = _("Bandwidth limit for incoming Gnet traffic in bytes/sec.");
    gnet_property->props[132].ev_changed = event_new("bw_gnet_in_changed");
    gnet_property->props[132].save = TRUE;
    gnet_property->props[132].vector_size = 1;
	mutex_init(&gnet_property->props[132].lock);

    /* Type specific data: */
    gnet_property->props[132].type               = PROP_TYPE_GUINT32;
    gnet_property->props[132].data.guint32.def   = (void *) &gnet_property_variable_bw_gnet_in_default;
    gnet_property->props[132].data.guint32.value = (void *) &gnet_property_variable_bw_gnet_in;
    gnet_property->props[132].data.guint32.choices = NULL;
    gnet_property->props[132].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[132].data.guint32.min   = 1024;


    /*
     * PROP_BW_GNET_OUT:
     *
     * General data:
     */
    gnet_property->props[133].name = "output_gnet_bandwidth";
    gnet_property->props[133].desc = _("Bandwidth limit for outgoing Gnet traffic in bytes/sec.");
    gnet_property->props[133].ev_changed = event_new("bw_gnet_out_changed");
    gnet_property->props[133].save = TRUE;
    gnet_property->props[133].vector_size = 1;
	mutex_init(&gnet_property->props[133].lock);

    /* Type specific data: */
    gnet_property->props[133].type               = PROP_TYPE_GUINT32;
    gnet_property->props[133].data.guint32.def   = (void *) &gnet_property_variable_bw_gnet_out_default;
    gnet_property->props[133].data.guint32.value = (void *) &gnet_property_variable_bw_gnet_out;
    gnet_property->props[133].data.guint32.choices = NULL;
    gnet_property->props[133].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[133].data.guint32.min   = 1024;


    /*
     * PROP_BW_GNET_LIN:
     *
     * General data:
     */
    gnet_property->props[134].name = "input_gnet_leaf_bandwidth";
    gnet_property->props[134].desc = _("Bandwidth limit for incoming Gnet leaf traffic in bytes/sec. When running as an ultra node, this bandwidth is stolen from the regular HTTP traffic if the shaper for leaves is enabled.");
    gnet_property->props[134].ev_changed = event_new("bw_gnet_lin_changed");
    gnet_property->props[134].save = TRUE;
    gnet_property->props[134].vector_size = 1;
	mutex_init(&gnet_property->props[134].lock);

    /* Type specific data: */
    gnet_property->props[134].type               = PROP_TYPE_GUINT32;
    gnet_property->props[134].data.guint32.def   = (void *) &gnet_property_variable_bw_gnet_lin_default;
    gnet_property->props[134].data.guint32.value = (void *) &gnet_property_variable_bw_gnet_lin;
    gnet_property->props[134].data.guint32.choices = NULL;
    gnet_property->props[134].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[134].data.guint32.min   = 1024;


    /*
     * PROP_BW_GNET_LOUT:
     *
     * General data:
     */
    gnet_property->props[135].name = "output_gnet_leaf_bandwidth";
    gnet_property->props[135].desc = _("Bandwidth limit for outgoing Gnet leaf traffic in bytes/sec. When running as an ultra node, this bandwidth is stolen from the regular HTTP traffic, if the shaper for leaves is enabled.");
    gnet_property->props[135].ev_changed = event_new("bw_gnet_lout_changed");
    gnet_property->props[135].save = TRUE;
    gnet_property->props[135].vector_size = 1;
	mutex_init(&gnet_property->props[135].lock);

    /* Type specific data: */
    gnet_property->props[135].type               = PROP_TYPE_GUINT32;
    gnet_property->props[135].data.guint32.def   = (void *) &gnet_property_variable_bw_gnet_lout_default;
    gnet_property->props[135].data.guint32.value = (void *) &gnet_property_variable_bw_gnet_lout;
    gnet_property->props[135].data.guint32.choices = NULL;
    gnet_property->props[135].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[135].data.guint32.min   = 1024;


    /*
     * PROP_SEARCH_QUERIES_FORWARD_SIZE:
     *
     * General data:
     */
    gnet_property->props[136].name = "search_queries_forward_size";
    gnet_property->props[136].desc = _("Maximum size of search queries messages we forward to others  (in bytes).");
    gnet_property->props[136].ev_changed = event_new("search_queries_forward_size_changed");
    gnet_property->props[136].save = TRUE;
    gnet_property->props[136].vector_size = 1;
	mutex_init(&gnet_property->props[136].lock);

    /* Type specific data: */
    gnet_property->props[136].type               = PROP_TYPE_GUINT32;
    gnet_property->props[136].data.guint32.def   = (void *) &gnet_property_variable_search_queries_forward_size_default;
    gnet_property->props[136].data.guint32.value = (void *) &gnet_property_variable_search_queries_forward_size;
    gnet_property->props[136].data.guint32.choices = NULL;
    gnet_property->props[136].data.guint32.max   = 256;
    gnet_property->props[136].data.guint32.min   = 128;


    /*
     * PROP_SEARCH_QUERIES_KICK_SIZE:
     *
     * General data:
     */
    gnet_property->props[137].name = "search_queries_kick_size";
    gnet_property->props[137].desc = _("Maximum size of search queries messages we allow, otherwise close the connection (in bytes).");
    gnet_property->props[137].ev_changed = event_new("search_queries_kick_size_changed");
    gnet_property->props[137].save = TRUE;
    gnet_property->props[137].vector_size = 1;
	mutex_init(&gnet_property->props[137].lock);

    /* Type specific data: */
    gnet_property->props[137].type               = PROP_TYPE_GUINT32;
    gnet_property->props[137].data.guint32.def   = (void *) &gnet_property_variable_search_queries_kick_size_default;
    gnet_property->props[137].data.guint32.value = (void *) &gnet_property_variable_search_queries_kick_size;
    gnet_property->props[137].data.guint32.choices = NULL;
    gnet_property->props[137].data.guint32.max   = 1024;
    gnet_property->props[137].data.guint32.min   = 256;


    /*
     * PROP_SEARCH_ANSWERS_FORWARD_SIZE:
     *
     * General data:
     */
    gnet_property->props[138].name = "search_answers_forward_size";
    gnet_property->props[138].desc = _("Maximum size of search answers messages we forward to others (in bytes).");
    gnet_property->props[138].ev_changed = event_new("search_answers_forward_size_changed");
    gnet_property->props[138].save = TRUE;
    gnet_property->props[138].vector_size = 1;
	mutex_init(&gnet_property->props[138].lock);

    /* Type specific data: */
    gnet_property->props[138].type               = PROP_TYPE_GUINT32;
    gnet_property->props[138].data.guint32.def   = (void *) &gnet_property_variable_search_answers_forward_size_default;
    gnet_property->props[138].data.guint32.value = (void *) &gnet_property_variable_search_answers_forward_size;
    gnet_property->props[138].data.guint32.choices = NULL;
    gnet_property->props[138].data.guint32.max   = 65536;
    gnet_property->props[138].data.guint32.min   = 4096;


    /*
     * PROP_SEARCH_ANSWERS_KICK_SIZE:
     *
     * General data:
     */
    gnet_property->props[139].name = "search_answers_kick_size";
    gnet_property->props[139].desc = _("Maximum size of search answers messages we allow, otherwise close the connection (in bytes).");
    gnet_property->props[139].ev_changed = event_new("search_answers_kick_size_changed");
    gnet_property->props[139].save = TRUE;
    gnet_property->props[139].vector_size = 1;
	mutex_init(&gnet_property->props[139].lock);

    /* Type specific data: */
    gnet_property->props[139].type               = PROP_TYPE_GUINT32;
    gnet_property->props[139].data.guint32.def   = (void *) &gnet_property_variable_search_answers_kick_size_default;
    gnet_property->props[139].data.guint32.value = (void *) &gnet_property_variable_search_answers_kick_size;
    gnet_property->props[139].data.guint32.choices = NULL;
    gnet_property->props[139].data.guint32.max   = 65536;
    gnet_property->props[139].data.guint32.min   = 16384;


    /*
     * PROP_SEARCH_MUID_TRACK_AMOUNT:
     *
     * General data:
     */
    gnet_property->props[140].name = "search_muid_track_amount";
    gnet_property->props[140].desc = _("Maximum number of relayed Query MUIDs to track. This allows mapping MUIDs of Query Hits to the original search term and media type filtering to be able to avoid relaying spam and non-matching results.  In the worst case this causes about 300 bytes per Query of memory overhead, but will be much lower than that in practice (minimum size is about 40 bytes). This is only used when running as an Ultrapeer. When the value specified is greater than the amount of messages that the Gnutella routing table can track, gtk-gnutella will automatically cap the amount of tracked MUIDs to fit the queries it remembers for routing.");
    gnet_property->props[140].ev_changed = event_new("search_muid_track_amount_changed");
    gnet_property->props[140].save = TRUE;
    gnet_property->props[140].vector_size = 1;
	mutex_init(&gnet_property->props[140].lock);

    /* Type specific data: */
    gnet_property->props[140].type               = PROP_TYPE_GUINT32;
    gnet_property->props[140].data.guint32.def   = (void *) &gnet_property_variable_search_muid_track_amount_default;
    gnet_property->props[140].data.guint32.value = (void *) &gnet_property_variable_search_muid_track_amount;
    gnet_property->props[140].data.guint32.choices = NULL;
    gnet_property->props[140].data.guint32.max   = 10000000;
    gnet_property->props[140].data.guint32.min   = 0;


    /*
     * PROP_OTHER_MESSAGES_KICK_SIZE:
     *
     * General data:
     */
    gnet_property->props[141].name = "other_messages_kick_size";
    gnet_property->props[141].desc = _("Maximum size of unknown messages we allow, otherwise close the connection (in bytes).");
    gnet_property->props[141].ev_changed = event_new("other_messages_kick_size_changed");
    gnet_property->props[141].save = TRUE;
    gnet_property->props[141].vector_size = 1;
	mutex_init(&gnet_property->props[141].lock);

    /* Type specific data: */
    gnet_property->props[141].type               = PROP_TYPE_GUINT32;
    gnet_property->props[141].data.guint32.def   = (void *) &gnet_property_variable_other_messages_kick_size_default;
    gnet_property->props[141].data.guint32.value = (void *) &gnet_property_variable_other_messages_kick_size;
    gnet_property->props[141].data.guint32.choices = NULL;
    gnet_property->props[141].data.guint32.max   = 65536;
    gnet_property->props[141].data.guint32.min   = 1024;


    /*
     * PROP_HOPS_RANDOM_FACTOR:
     *
     * General data:
     */
    gnet_property->props[142].name = "hops_random_factor";
    gnet_property->props[142].desc = _("Random factor for the hops field in search packets we send (between 0 and 3 inclusive).");
    gnet_property->props[142].ev_changed = event_new("hops_random_factor_changed");
    gnet_property->props[142].save = TRUE;
    gnet_property->props[142].vector_size = 1;
	mutex_init(&gnet_property->props[142].lock);

    /* Type specific data: */
    gnet_property->props[142].type               = PROP_TYPE_GUINT32;
    gnet_property->props[142].data.guint32.def   = (void *) &gnet_property_variable_hops_random_factor_default;
    gnet_property->props[142].data.guint32.value = (void *) &gnet_property_variable_hops_random_factor;
    gnet_property->props[142].data.guint32.choices = NULL;
    gnet_property->props[142].data.guint32.max   = 3;
    gnet_property->props[142].data.guint32.min   = 0;


    /*
     * PROP_SEND_PUSHES:
     *
     * General data:
     */
    gnet_property->props[143].name = "send_pushes";
    gnet_property->props[143].desc = _("Whether or not to send push requests.  If you are firewalled, gtk-gnutella will never send push requests anyway.  If you don't let gtk-gnutella send pushes, it will not show search results that would require a push.");
    gnet_property->props[143].ev_changed = event_new("send_pushes_changed");
    gnet_property->props[143].save = TRUE;
    gnet_property->props[143].vector_size = 1;
	mutex_init(&gnet_property->props[143].lock);

    /* Type specific data: */
    gnet_property->props[143].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[143].data.boolean.def   = (void *) &gnet_property_variable_send_pushes_default;
    gnet_property->props[143].data.boolean.value = (void *) &gnet_property_variable_send_pushes;


    /*
     * PROP_MIN_DUP_MSG:
     *
     * General data:
     */
    gnet_property->props[144].name = "min_dup_msg";
    gnet_property->props[144].desc = _("Minimum amount of dup messages to enable kicking, per node (also see [min_dup_ratio]).");
    gnet_property->props[144].ev_changed = event_new("min_dup_msg_changed");
    gnet_property->props[144].save = TRUE;
    gnet_property->props[144].vector_size = 1;
	mutex_init(&gnet_property->props[144].lock);

    /* Type specific data: */
    gnet_property->props[144].type               = PROP_TYPE_GUINT32;
    gnet_property->props[144].data.guint32.def   = (void *) &gnet_property_variable_min_dup_msg_default;
    gnet_property->props[144].data.guint32.value = (void *) &gnet_property_variable_min_dup_msg;
    gnet_property->props[144].data.guint32.choices = NULL;
    gnet_property->props[144].data.guint32.max   = 99;
    gnet_property->props[144].data.guint32.min   = 1;


    /*
     * PROP_MIN_DUP_RATIO:
     *
     * General data:
     */
    gnet_property->props[145].name = "min_dup_ratio";
    gnet_property->props[145].desc = _("Minimum ratio of dups on received messages, per node (between 0.00 and 100.00) (also see [min_dup_msg]) Note: the value is stored between 0 (0.0) and 10000 (100.0) in the config file.");
    gnet_property->props[145].ev_changed = event_new("min_dup_ratio_changed");
    gnet_property->props[145].save = TRUE;
    gnet_property->props[145].vector_size = 1;
	mutex_init(&gnet_property->props[145].lock);

    /* Type specific data: */
    gnet_property->props[145].type               = PROP_TYPE_GUINT32;
    gnet_property->props[145].data.guint32.def   = (void *) &gnet_property_variable_min_dup_ratio_default;
    gnet_property->props[145].data.guint32.value = (void *) &gnet_property_variable_min_dup_ratio;
    gnet_property->props[145].data.guint32.choices = NULL;
    gnet_property->props[145].data.guint32.max   = 10000;
    gnet_property->props[145].data.guint32.min   = 0;


    /*
     * PROP_SCAN_EXTENSIONS:
     *
     * General data:
     */
    gnet_property->props[146].name = "shared_files_extensions";
    gnet_property->props[146].desc = _("Only files with the given extensions will be shared. The special --all-- extension matches all files, even if they don't have any extension.  Use with care.");
    gnet_property->props[146].ev_changed = event_new("scan_extensions_changed");
    gnet_property->props[146].save = TRUE;
    gnet_property->props[146].vector_size = 1;
	mutex_init(&gnet_property->props[146].lock);

    /* Type specific data: */
    gnet_property->props[146].type               = PROP_TYPE_STRING;
    gnet_property->props[146].data.string.def    = (void *) &gnet_property_variable_scan_extensions_default;
    gnet_property->props[146].data.string.value  = (void *) &gnet_property_variable_scan_extensions;
    if (gnet_property->props[146].data.string.def) {
        *gnet_property->props[146].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[146].data.string.def));
    }


    /*
     * PROP_SCAN_IGNORE_SYMLINK_DIRS:
     *
     * General data:
     */
    gnet_property->props[147].name = "scan_ignore_symlink_dirs";
    gnet_property->props[147].desc = _("Ignore symbolically linked directories when scanning files to share.");
    gnet_property->props[147].ev_changed = event_new("scan_ignore_symlink_dirs_changed");
    gnet_property->props[147].save = TRUE;
    gnet_property->props[147].vector_size = 1;
	mutex_init(&gnet_property->props[147].lock);

    /* Type specific data: */
    gnet_property->props[147].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[147].data.boolean.def   = (void *) &gnet_property_variable_scan_ignore_symlink_dirs_default;
    gnet_property->props[147].data.boolean.value = (void *) &gnet_property_variable_scan_ignore_symlink_dirs;


    /*
     * PROP_SCAN_IGNORE_SYMLINK_REGFILES:
     *
     * General data:
     */
    gnet_property->props[148].name = "scan_ignore_symlink_regfiles";
    gnet_property->props[148].desc = _("Ignore symbolically linked regular files when scanning files to share.");
    gnet_property->props[148].ev_changed = event_new("scan_ignore_symlink_regfiles_changed");
    gnet_property->props[148].save = TRUE;
    gnet_property->props[148].vector_size = 1;
	mutex_init(&gnet_property->props[148].lock);

    /* Type specific data: */
    gnet_property->props[148].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[148].data.boolean.def   = (void *) &gnet_property_variable_scan_ignore_symlink_regfiles_default;
    gnet_property->props[148].data.boolean.value = (void *) &gnet_property_variable_scan_ignore_symlink_regfiles;


    /*
     * PROP_SAVE_FILE_PATH:
     *
     * General data:
     */
    gnet_property->props[149].name = "store_downloading_files_to";
    gnet_property->props[149].desc = _("Store incomplete files in this directory.");
    gnet_property->props[149].ev_changed = event_new("save_file_path_changed");
    gnet_property->props[149].save = TRUE;
    gnet_property->props[149].vector_size = 1;
	mutex_init(&gnet_property->props[149].lock);

    /* Type specific data: */
    gnet_property->props[149].type               = PROP_TYPE_STRING;
    gnet_property->props[149].data.string.def    = (void *) &gnet_property_variable_save_file_path_default;
    gnet_property->props[149].data.string.value  = (void *) &gnet_property_variable_save_file_path;
    if (gnet_property->props[149].data.string.def) {
        *gnet_property->props[149].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[149].data.string.def));
    }


    /*
     * PROP_MOVE_FILE_PATH:
     *
     * General data:
     */
    gnet_property->props[150].name = "move_downloading_files_to";
    gnet_property->props[150].desc = _("Move complete files to this directory. If this is set to the SAME directory as the incomplete or corrupted files, files will be renamed with a trailing .OK");
    gnet_property->props[150].ev_changed = event_new("move_file_path_changed");
    gnet_property->props[150].save = TRUE;
    gnet_property->props[150].vector_size = 1;
	mutex_init(&gnet_property->props[150].lock);

    /* Type specific data: */
    gnet_property->props[150].type               = PROP_TYPE_STRING;
    gnet_property->props[150].data.string.def    = (void *) &gnet_property_variable_move_file_path_default;
    gnet_property->props[150].data.string.value  = (void *) &gnet_property_variable_move_file_path;
    if (gnet_property->props[150].data.string.def) {
        *gnet_property->props[150].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[150].data.string.def));
    }


    /*
     * PROP_BAD_FILE_PATH:
     *
     * General data:
     */
    gnet_property->props[151].name = "move_corrupted_files_to";
    gnet_property->props[151].desc = _("Move corrupted, downloaded files to this directory. If this is set to the SAME directory as the incomplete or completed files, files will be renamed with a trailing .BAD");
    gnet_property->props[151].ev_changed = event_new("bad_file_path_changed");
    gnet_property->props[151].save = TRUE;
    gnet_property->props[151].vector_size = 1;
	mutex_init(&gnet_property->props[151].lock);

    /* Type specific data: */
    gnet_property->props[151].type               = PROP_TYPE_STRING;
    gnet_property->props[151].data.string.def    = (void *) &gnet_property_variable_bad_file_path_default;
    gnet_property->props[151].data.string.value  = (void *) &gnet_property_variable_bad_file_path;
    if (gnet_property->props[151].data.string.def) {
        *gnet_property->props[151].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[151].data.string.def));
    }


    /*
     * PROP_SHARED_DIRS_PATHS:
     *
     * General data:
     */
    gnet_property->props[152].name = "shared_dirs";
    gnet_property->props[152].desc = _("Directories which contain shared files.");
    gnet_property->props[152].ev_changed = event_new("shared_dirs_paths_changed");
    gnet_property->props[152].save = TRUE;
    gnet_property->props[152].vector_size = 1;
	mutex_init(&gnet_property->props[152].lock);

    /* Type specific data: */
    gnet_property->props[152].type               = PROP_TYPE_STRING;
    gnet_property->props[152].data.string.def    = (void *) &gnet_property_variable_shared_dirs_paths_default;
    gnet_property->props[152].data.string.value  = (void *) &gnet_property_variable_shared_dirs_paths;
    if (gnet_property->props[152].data.string.def) {
        *gnet_property->props[152].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[152].data.string.def));
    }


    /*
     * PROP_LOCAL_NETMASKS_STRING:
     *
     * General data:
     */
    gnet_property->props[153].name = "local_netmasks";
    gnet_property->props[153].desc = _("List of networks considered local.  This is a list of IP addresses, separated by ';'.  The IP address can be given out fully, as in 192.168.0.1, or be optionally followed by '/' and a network mask prefix length. For instance, 192.168.0.1/24 would represent the whole 192.168.0.* network.");
    gnet_property->props[153].ev_changed = event_new("local_netmasks_string_changed");
    gnet_property->props[153].save = TRUE;
    gnet_property->props[153].vector_size = 1;
	mutex_init(&gnet_property->props[153].lock);

    /* Type specific data: */
    gnet_property->props[153].type               = PROP_TYPE_STRING;
    gnet_property->props[153].data.string.def    = (void *) &gnet_property_variable_local_netmasks_string_default;
    gnet_property->props[153].data.string.value  = (void *) &gnet_property_variable_local_netmasks_string;
    if (gnet_property->props[153].data.string.def) {
        *gnet_property->props[153].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[153].data.string.def));
    }


    /*
     * PROP_TOTAL_DOWNLOADS:
     *
     * General data:
     */
    gnet_property->props[154].name = "total_downloads";
    gnet_property->props[154].desc = _("Total number of completed downloads in this session.");
    gnet_property->props[154].ev_changed = event_new("total_downloads_changed");
    gnet_property->props[154].save = FALSE;
    gnet_property->props[154].vector_size = 1;
	mutex_init(&gnet_property->props[154].lock);

    /* Type specific data: */
    gnet_property->props[154].type               = PROP_TYPE_GUINT32;
    gnet_property->props[154].data.guint32.def   = (void *) &gnet_property_variable_total_downloads_default;
    gnet_property->props[154].data.guint32.value = (void *) &gnet_property_variable_total_downloads;
    gnet_property->props[154].data.guint32.choices = NULL;
    gnet_property->props[154].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[154].data.guint32.min   = 0x00000000;


    /*
     * PROP_UL_RUNNING:
     *
     * General data:
     */
    gnet_property->props[155].name = "ul_running";
    gnet_property->props[155].desc = _("Number of running uploads.");
    gnet_property->props[155].ev_changed = event_new("ul_running_changed");
    gnet_property->props[155].save = FALSE;
    gnet_property->props[155].vector_size = 1;
	mutex_init(&gnet_property->props[155].lock);

    /* Type specific data: */
    gnet_property->props[155].type               = PROP_TYPE_GUINT32;
    gnet_property->props[155].data.guint32.def   = (void *) &gnet_property_variable_ul_running_default;
    gnet_property->props[155].data.guint32.value = (void *) &gnet_property_variable_ul_running;
    gnet_property->props[155].data.guint32.choices = NULL;
    gnet_property->props[155].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[155].data.guint32.min   = 0x00000000;


    /*
     * PROP_UL_QUICK_RUNNING:
     *
     * General data:
     */
    gnet_property->props[156].name = "ul_quick_running";
    gnet_property->props[156].desc = _("Number of quick uploads currently running.");
    gnet_property->props[156].ev_changed = event_new("ul_quick_running_changed");
    gnet_property->props[156].save = FALSE;
    gnet_property->props[156].vector_size = 1;
	mutex_init(&gnet_property->props[156].lock);

    /* Type specific data: */
    gnet_property->props[156].type               = PROP_TYPE_GUINT32;
    gnet_property->props[156].data.guint32.def   = (void *) &gnet_property_variable_ul_quick_running_default;
    gnet_property->props[156].data.guint32.value = (void *) &gnet_property_variable_ul_quick_running;
    gnet_property->props[156].data.guint32.choices = NULL;
    gnet_property->props[156].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[156].data.guint32.min   = 0x00000000;


    /*
     * PROP_UL_REGISTERED:
     *
     * General data:
     */
    gnet_property->props[157].name = "ul_registered";
    gnet_property->props[157].desc = _("Number of registered (pending) uploads.");
    gnet_property->props[157].ev_changed = event_new("ul_registered_changed");
    gnet_property->props[157].save = FALSE;
    gnet_property->props[157].vector_size = 1;
	mutex_init(&gnet_property->props[157].lock);

    /* Type specific data: */
    gnet_property->props[157].type               = PROP_TYPE_GUINT32;
    gnet_property->props[157].data.guint32.def   = (void *) &gnet_property_variable_ul_registered_default;
    gnet_property->props[157].data.guint32.value = (void *) &gnet_property_variable_ul_registered;
    gnet_property->props[157].data.guint32.choices = NULL;
    gnet_property->props[157].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[157].data.guint32.min   = 0x00000000;


    /*
     * PROP_TOTAL_UPLOADS:
     *
     * General data:
     */
    gnet_property->props[158].name = "total_uploads";
    gnet_property->props[158].desc = _("Total number of completed uploads in this session.");
    gnet_property->props[158].ev_changed = event_new("total_uploads_changed");
    gnet_property->props[158].save = FALSE;
    gnet_property->props[158].vector_size = 1;
	mutex_init(&gnet_property->props[158].lock);

    /* Type specific data: */
    gnet_property->props[158].type               = PROP_TYPE_GUINT32;
    gnet_property->props[158].data.guint32.def   = (void *) &gnet_property_variable_total_uploads_default;
    gnet_property->props[158].data.guint32.value = (void *) &gnet_property_variable_total_uploads;
    gnet_property->props[158].data.guint32.choices = NULL;
    gnet_property->props[158].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[158].data.guint32.min   = 0x00000000;


    /*
     * PROP_SERVENT_GUID:
     *
     * General data:
     */
    gnet_property->props[159].name = "guid";
    gnet_property->props[159].desc = _("Global Unique IDentifier of this node.");
    gnet_property->props[159].ev_changed = event_new("servent_guid_changed");
    gnet_property->props[159].save = TRUE;
    gnet_property->props[159].vector_size = GUID_RAW_SIZE;
	mutex_init(&gnet_property->props[159].lock);

    /* Type specific data: */
    gnet_property->props[159].type               = PROP_TYPE_STORAGE;
    gnet_property->props[159].data.storage.value = gnet_property_variable_servent_guid;


    /*
     * PROP_KUID:
     *
     * General data:
     */
    gnet_property->props[160].name = "kuid";
    gnet_property->props[160].desc = _("Kademlia Unique IDentifier of this node in the DHT.");
    gnet_property->props[160].ev_changed = event_new("kuid_changed");
    gnet_property->props[160].save = TRUE;
    gnet_property->props[160].vector_size = KUID_RAW_SIZE;
	mutex_init(&gnet_property->props[160].lock);

    /* Type specific data: */
    gnet_property->props[160].type               = PROP_TYPE_STORAGE;
    gnet_property->props[160].data.storage.value = gnet_property_variable_kuid;


    /*
     * PROP_USE_SWARMING:
     *
     * General data:
     */
    gnet_property->props[161].name = "use_swarming";
    gnet_property->props[161].desc = _("Whether or not to use swarming (recommended = YES).");
    gnet_property->props[161].ev_changed = event_new("use_swarming_changed");
    gnet_property->props[161].save = TRUE;
    gnet_property->props[161].vector_size = 1;
	mutex_init(&gnet_property->props[161].lock);

    /* Type specific data: */
    gnet_property->props[161].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[161].data.boolean.def   = (void *) &gnet_property_variable_use_swarming_default;
    gnet_property->props[161].data.boolean.value = (void *) &gnet_property_variable_use_swarming;


    /*
     * PROP_USE_AGGRESSIVE_SWARMING:
     *
     * General data:
     */
    gnet_property->props[162].name = "use_aggressive_swarming";
    gnet_property->props[162].desc = _("Whether or not to launch competing downloads when swarming and there are many sources available with a few chunks left.");
    gnet_property->props[162].ev_changed = event_new("use_aggressive_swarming_changed");
    gnet_property->props[162].save = TRUE;
    gnet_property->props[162].vector_size = 1;
	mutex_init(&gnet_property->props[162].lock);

    /* Type specific data: */
    gnet_property->props[162].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[162].data.boolean.def   = (void *) &gnet_property_variable_use_aggressive_swarming_default;
    gnet_property->props[162].data.boolean.value = (void *) &gnet_property_variable_use_aggressive_swarming;


    /*
     * PROP_DL_MINCHUNKSIZE:
     *
     * General data:
     */
    gnet_property->props[163].name = "dl_minchunksize";
    gnet_property->props[163].desc = _("Minimum chunk size when swarming.  This is only a hint as gtk-gnutella will download less if you only have a few bytes to get for a file...");
    gnet_property->props[163].ev_changed = event_new("dl_minchunksize_changed");
    gnet_property->props[163].save = TRUE;
    gnet_property->props[163].vector_size = 1;
	mutex_init(&gnet_property->props[163].lock);

    /* Type specific data: */
    gnet_property->props[163].type               = PROP_TYPE_GUINT32;
    gnet_property->props[163].data.guint32.def   = (void *) &gnet_property_variable_dl_minchunksize_default;
    gnet_property->props[163].data.guint32.value = (void *) &gnet_property_variable_dl_minchunksize;
    gnet_property->props[163].data.guint32.choices = NULL;
    gnet_property->props[163].data.guint32.max   = 100*1024*1024;
    gnet_property->props[163].data.guint32.min   = 64*1024;


    /*
     * PROP_DL_MAXCHUNKSIZE:
     *
     * General data:
     */
    gnet_property->props[164].name = "dl_maxchunksize";
    gnet_property->props[164].desc = _("Maximum chunk size when swarming.");
    gnet_property->props[164].ev_changed = event_new("dl_maxchunksize_changed");
    gnet_property->props[164].save = TRUE;
    gnet_property->props[164].vector_size = 1;
	mutex_init(&gnet_property->props[164].lock);

    /* Type specific data: */
    gnet_property->props[164].type               = PROP_TYPE_GUINT32;
    gnet_property->props[164].data.guint32.def   = (void *) &gnet_property_variable_dl_maxchunksize_default;
    gnet_property->props[164].data.guint32.value = (void *) &gnet_property_variable_dl_maxchunksize;
    gnet_property->props[164].data.guint32.choices = NULL;
    gnet_property->props[164].data.guint32.max   = 1000*1024*1024;
    gnet_property->props[164].data.guint32.min   = 64*1024;


    /*
     * PROP_AUTO_DOWNLOAD_IDENTICAL:
     *
     * General data:
     */
    gnet_property->props[165].name = "auto_download_identical";
    gnet_property->props[165].desc = _("Whether or not to automatically queue search results that match a file in the download queue.");
    gnet_property->props[165].ev_changed = event_new("auto_download_identical_changed");
    gnet_property->props[165].save = TRUE;
    gnet_property->props[165].vector_size = 1;
	mutex_init(&gnet_property->props[165].lock);

    /* Type specific data: */
    gnet_property->props[165].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[165].data.boolean.def   = (void *) &gnet_property_variable_auto_download_identical_default;
    gnet_property->props[165].data.boolean.value = (void *) &gnet_property_variable_auto_download_identical;


    /*
     * PROP_AUTO_FEED_DOWNLOAD_MESH:
     *
     * General data:
     */
    gnet_property->props[166].name = "auto_feed_download_mesh";
    gnet_property->props[166].desc = _("Whether or not to automatically feed the download mesh with data gathered from the query hits that flow through our node. This looks for new entries for files we are sharing or already have in our mesh.");
    gnet_property->props[166].ev_changed = event_new("auto_feed_download_mesh_changed");
    gnet_property->props[166].save = TRUE;
    gnet_property->props[166].vector_size = 1;
	mutex_init(&gnet_property->props[166].lock);

    /* Type specific data: */
    gnet_property->props[166].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[166].data.boolean.def   = (void *) &gnet_property_variable_auto_feed_download_mesh_default;
    gnet_property->props[166].data.boolean.value = (void *) &gnet_property_variable_auto_feed_download_mesh;


    /*
     * PROP_STRICT_SHA1_MATCHING:
     *
     * General data:
     */
    gnet_property->props[167].name = "strict_sha1_matching";
    gnet_property->props[167].desc = _("When enabled, SHA1s must match. Otherwise, name and size will be sufficient.");
    gnet_property->props[167].ev_changed = event_new("strict_sha1_matching_changed");
    gnet_property->props[167].save = TRUE;
    gnet_property->props[167].vector_size = 1;
	mutex_init(&gnet_property->props[167].lock);

    /* Type specific data: */
    gnet_property->props[167].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[167].data.boolean.def   = (void *) &gnet_property_variable_strict_sha1_matching_default;
    gnet_property->props[167].data.boolean.value = (void *) &gnet_property_variable_strict_sha1_matching;


    /*
     * PROP_IS_FIREWALLED:
     *
     * General data:
     */
    gnet_property->props[168].name = "is_firewalled";
    gnet_property->props[168].desc = _("Whether gtk-gnutella thinks you're currently firewalled, TCP-wise.");
    gnet_property->props[168].ev_changed = event_new("is_firewalled_changed");
    gnet_property->props[168].save = TRUE;
    gnet_property->props[168].vector_size = 1;
	mutex_init(&gnet_property->props[168].lock);

    /* Type specific data: */
    gnet_property->props[168].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[168].data.boolean.def   = (void *) &gnet_property_variable_is_firewalled_default;
    gnet_property->props[168].data.boolean.value = (void *) &gnet_property_variable_is_firewalled;


    /*
     * PROP_IS_INET_CONNECTED:
     *
     * General data:
     */
    gnet_property->props[169].name = "is_inet_connected";
    gnet_property->props[169].desc = _("Whether gtk-gnutella thinks it's connected to the Internet.");
    gnet_property->props[169].ev_changed = event_new("is_inet_connected_changed");
    gnet_property->props[169].save = FALSE;
    gnet_property->props[169].vector_size = 1;
	mutex_init(&gnet_property->props[169].lock);

    /* Type specific data: */
    gnet_property->props[169].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[169].data.boolean.def   = (void *) &gnet_property_variable_is_inet_connected_default;
    gnet_property->props[169].data.boolean.value = (void *) &gnet_property_variable_is_inet_connected;


    /*
     * PROP_IS_UDP_FIREWALLED:
     *
     * General data:
     */
    gnet_property->props[170].name = "is_udp_firewalled";
    gnet_property->props[170].desc = _("Whether gtk-gnutella thinks you're currently firewalled, UDP-wise.");
    gnet_property->props[170].ev_changed = event_new("is_udp_firewalled_changed");
    gnet_property->props[170].save = TRUE;
    gnet_property->props[170].vector_size = 1;
	mutex_init(&gnet_property->props[170].lock);

    /* Type specific data: */
    gnet_property->props[170].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[170].data.boolean.def   = (void *) &gnet_property_variable_is_udp_firewalled_default;
    gnet_property->props[170].data.boolean.value = (void *) &gnet_property_variable_is_udp_firewalled;


    /*
     * PROP_RECV_SOLICITED_UDP:
     *
     * General data:
     */
    gnet_property->props[171].name = "recv_solicited_udp";
    gnet_property->props[171].desc = _("Whether gtk-gnutella determined it could receive solicited UDP.");
    gnet_property->props[171].ev_changed = event_new("recv_solicited_udp_changed");
    gnet_property->props[171].save = TRUE;
    gnet_property->props[171].vector_size = 1;
	mutex_init(&gnet_property->props[171].lock);

    /* Type specific data: */
    gnet_property->props[171].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[171].data.boolean.def   = (void *) &gnet_property_variable_recv_solicited_udp_default;
    gnet_property->props[171].data.boolean.value = (void *) &gnet_property_variable_recv_solicited_udp;


    /*
     * PROP_GNET_COMPACT_QUERY:
     *
     * General data:
     */
    gnet_property->props[172].name = "gnet_compact_query";
    gnet_property->props[172].desc = _("Remove unnecessary ballast from query string before processing or forwarding them. Reduces traffic at the cost of little CPU time.");
    gnet_property->props[172].ev_changed = event_new("gnet_compact_query_changed");
    gnet_property->props[172].save = TRUE;
    gnet_property->props[172].vector_size = 1;
	mutex_init(&gnet_property->props[172].lock);

    /* Type specific data: */
    gnet_property->props[172].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[172].data.boolean.def   = (void *) &gnet_property_variable_gnet_compact_query_default;
    gnet_property->props[172].data.boolean.value = (void *) &gnet_property_variable_gnet_compact_query;


    /*
     * PROP_DOWNLOAD_OPTIMISTIC_START:
     *
     * General data:
     */
    gnet_property->props[173].name = "download_optimistic_start";
    gnet_property->props[173].desc = _("Also use sources that don't provide a SHA1 value for the first chunk of a file. This dramatically reduces the 'No URN on server' messages, but may result in overlap problems later if the first chunk was actually from a different file. Use with caution.");
    gnet_property->props[173].ev_changed = event_new("download_optimistic_start_changed");
    gnet_property->props[173].save = TRUE;
    gnet_property->props[173].vector_size = 1;
	mutex_init(&gnet_property->props[173].lock);

    /* Type specific data: */
    gnet_property->props[173].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[173].data.boolean.def   = (void *) &gnet_property_variable_download_optimistic_start_default;
    gnet_property->props[173].data.boolean.value = (void *) &gnet_property_variable_download_optimistic_start;


    /*
     * PROP_LIBRARY_REBUILDING:
     *
     * General data:
     */
    gnet_property->props[174].name = "library_rebuilding";
    gnet_property->props[174].desc = _("Whether gtk-gnutella is currently rebuilding its library in the background.");
    gnet_property->props[174].ev_changed = event_new("library_rebuilding_changed");
    gnet_property->props[174].save = FALSE;
    gnet_property->props[174].vector_size = 1;
	mutex_init(&gnet_property->props[174].lock);

    /* Type specific data: */
    gnet_property->props[174].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[174].data.boolean.def   = (void *) &gnet_property_variable_library_rebuilding_default;
    gnet_property->props[174].data.boolean.value = (void *) &gnet_property_variable_library_rebuilding;


    /*
     * PROP_SHA1_REBUILDING:
     *
     * General data:
     */
    gnet_property->props[175].name = "sha1_rebuilding";
    gnet_property->props[175].desc = _("Whether gtk-gnutella is currently computing SHA1 of shared files in the background.");
    gnet_property->props[175].ev_changed = event_new("sha1_rebuilding_changed");
    gnet_property->props[175].save = FALSE;
    gnet_property->props[175].vector_size = 1;
	mutex_init(&gnet_property->props[175].lock);

    /* Type specific data: */
    gnet_property->props[175].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[175].data.boolean.def   = (void *) &gnet_property_variable_sha1_rebuilding_default;
    gnet_property->props[175].data.boolean.value = (void *) &gnet_property_variable_sha1_rebuilding;


    /*
     * PROP_SHA1_VERIFYING:
     *
     * General data:
     */
    gnet_property->props[176].name = "sha1_verifying";
    gnet_property->props[176].desc = _("Whether gtk-gnutella is currently verifying SHA1 of downloaded files in the background.");
    gnet_property->props[176].ev_changed = event_new("sha1_verifying_changed");
    gnet_property->props[176].save = FALSE;
    gnet_property->props[176].vector_size = 1;
	mutex_init(&gnet_property->props[176].lock);

    /* Type specific data: */
    gnet_property->props[176].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[176].data.boolean.def   = (void *) &gnet_property_variable_sha1_verifying_default;
    gnet_property->props[176].data.boolean.value = (void *) &gnet_property_variable_sha1_verifying;


    /*
     * PROP_FILE_MOVING:
     *
     * General data:
     */
    gnet_property->props[177].name = "file_moving";
    gnet_property->props[177].desc = _("Whether gtk-gnutella is currently moving files across filesystems or simply copying in the background.");
    gnet_property->props[177].ev_changed = event_new("file_moving_changed");
    gnet_property->props[177].save = FALSE;
    gnet_property->props[177].vector_size = 1;
	mutex_init(&gnet_property->props[177].lock);

    /* Type specific data: */
    gnet_property->props[177].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[177].data.boolean.def   = (void *) &gnet_property_variable_file_moving_default;
    gnet_property->props[177].data.boolean.value = (void *) &gnet_property_variable_file_moving;


    /*
     * PROP_PREFER_COMPRESSED_GNET:
     *
     * General data:
     */
    gnet_property->props[178].name = "prefer_compressed_gnet";
    gnet_property->props[178].desc = _("If active, only compressed incoming connections are allowed after the minimum number of connections has been established. Always allows for one non-compressed connection.");
    gnet_property->props[178].ev_changed = event_new("prefer_compressed_gnet_changed");
    gnet_property->props[178].save = TRUE;
    gnet_property->props[178].vector_size = 1;
	mutex_init(&gnet_property->props[178].lock);

    /* Type specific data: */
    gnet_property->props[178].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[178].data.boolean.def   = (void *) &gnet_property_variable_prefer_compressed_gnet_default;
    gnet_property->props[178].data.boolean.value = (void *) &gnet_property_variable_prefer_compressed_gnet;


    /*
     * PROP_ONLINE_MODE:
     *
     * General data:
     */
    gnet_property->props[179].name = "online_mode";
    gnet_property->props[179].desc = _("If deactivated, only uploads and downloads will continue. All Gnet connections are disabled/terminated.");
    gnet_property->props[179].ev_changed = event_new("online_mode_changed");
    gnet_property->props[179].save = TRUE;
    gnet_property->props[179].vector_size = 1;
	mutex_init(&gnet_property->props[179].lock);

    /* Type specific data: */
    gnet_property->props[179].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[179].data.boolean.def   = (void *) &gnet_property_variable_online_mode_default;
    gnet_property->props[179].data.boolean.value = (void *) &gnet_property_variable_online_mode;


    /*
     * PROP_DOWNLOAD_REQUIRE_URN:
     *
     * General data:
     */
    gnet_property->props[180].name = "download_require_urn";
    gnet_property->props[180].desc = _("Whether gtk-gnutella should make sure the server confirms the URN of the file we're requesting when it is known locally and a traditional request by name is used (i.e. gtk-gnutella is not issuing a /uri-res/N2R? request).  When set, it supersedes the optimistic first chunk setting.");
    gnet_property->props[180].ev_changed = event_new("download_require_urn_changed");
    gnet_property->props[180].save = TRUE;
    gnet_property->props[180].vector_size = 1;
	mutex_init(&gnet_property->props[180].lock);

    /* Type specific data: */
    gnet_property->props[180].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[180].data.boolean.def   = (void *) &gnet_property_variable_download_require_urn_default;
    gnet_property->props[180].data.boolean.value = (void *) &gnet_property_variable_download_require_urn;


    /*
     * PROP_DOWNLOAD_REQUIRE_SERVER_NAME:
     *
     * General data:
     */
    gnet_property->props[181].name = "download_require_server_name";
    gnet_property->props[181].desc = _("Whether gtk-gnutella should make sure the server gives us back a non-empty identifying token.");
    gnet_property->props[181].ev_changed = event_new("download_require_server_name_changed");
    gnet_property->props[181].save = TRUE;
    gnet_property->props[181].vector_size = 1;
	mutex_init(&gnet_property->props[181].lock);

    /* Type specific data: */
    gnet_property->props[181].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[181].data.boolean.def   = (void *) &gnet_property_variable_download_require_server_name_default;
    gnet_property->props[181].data.boolean.value = (void *) &gnet_property_variable_download_require_server_name;


    /*
     * PROP_MAX_ULTRAPEERS:
     *
     * General data:
     */
    gnet_property->props[182].name = "max_ultrapeers";
    gnet_property->props[182].desc = _("Maximum amount of Ultrapeers we should connect to as a leaf.");
    gnet_property->props[182].ev_changed = event_new("max_ultrapeers_changed");
    gnet_property->props[182].save = TRUE;
    gnet_property->props[182].vector_size = 1;
	mutex_init(&gnet_property->props[182].lock);

    /* Type specific data: */
    gnet_property->props[182].type               = PROP_TYPE_GUINT32;
    gnet_property->props[182].data.guint32.def   = (void *) &gnet_property_variable_max_ultrapeers_default;
    gnet_property->props[182].data.guint32.value = (void *) &gnet_property_variable_max_ultrapeers;
    gnet_property->props[182].data.guint32.choices = NULL;
    gnet_property->props[182].data.guint32.max   = 5;
    gnet_property->props[182].data.guint32.min   = 0;


    /*
     * PROP_QUICK_CONNECT_POOL_SIZE:
     *
     * General data:
     */
    gnet_property->props[183].name = "quick_connect_pool_size";
    gnet_property->props[183].desc = _("To connect more quickly, gtk-gnutella will allow up to this many connections to be active while trying to fill up the connection slots.");
    gnet_property->props[183].ev_changed = event_new("quick_connect_pool_size_changed");
    gnet_property->props[183].save = TRUE;
    gnet_property->props[183].vector_size = 1;
	mutex_init(&gnet_property->props[183].lock);

    /* Type specific data: */
    gnet_property->props[183].type               = PROP_TYPE_GUINT32;
    gnet_property->props[183].data.guint32.def   = (void *) &gnet_property_variable_quick_connect_pool_size_default;
    gnet_property->props[183].data.guint32.value = (void *) &gnet_property_variable_quick_connect_pool_size;
    gnet_property->props[183].data.guint32.choices = NULL;
    gnet_property->props[183].data.guint32.max   = 80;
    gnet_property->props[183].data.guint32.min   = 4;


    /*
     * PROP_MAX_LEAVES:
     *
     * General data:
     */
    gnet_property->props[184].name = "max_leaves";
    gnet_property->props[184].desc = _("Maximum amount of leaves we can accept.  To be promoted Ultra, you should reserve 32 bytes of bandwidth per leaf.");
    gnet_property->props[184].ev_changed = event_new("max_leaves_changed");
    gnet_property->props[184].save = TRUE;
    gnet_property->props[184].vector_size = 1;
	mutex_init(&gnet_property->props[184].lock);

    /* Type specific data: */
    gnet_property->props[184].type               = PROP_TYPE_GUINT32;
    gnet_property->props[184].data.guint32.def   = (void *) &gnet_property_variable_max_leaves_default;
    gnet_property->props[184].data.guint32.value = (void *) &gnet_property_variable_max_leaves;
    gnet_property->props[184].data.guint32.choices = NULL;
    gnet_property->props[184].data.guint32.max   = 1000;
    gnet_property->props[184].data.guint32.min   = 25;


    /*
     * PROP_SEARCH_HANDLE_IGNORED_FILES:
     *
     * General data:
     */
    gnet_property->props[185].name = "search_handle_ignored_files";
    gnet_property->props[185].desc = _("What to do with files that will be ignored for downloading.");
    gnet_property->props[185].ev_changed = event_new("search_handle_ignored_files_changed");
    gnet_property->props[185].save = TRUE;
    gnet_property->props[185].vector_size = 1;
	mutex_init(&gnet_property->props[185].lock);

    /* Type specific data: */
    gnet_property->props[185].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[185].data.guint32.def   = (void *) &gnet_property_variable_search_handle_ignored_files_default;
    gnet_property->props[185].data.guint32.value = (void *) &gnet_property_variable_search_handle_ignored_files;
    gnet_property->props[185].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[185].data.guint32.min   = 0x00000000;
    gnet_property->props[185].data.guint32.choices = (void *) &gnet_property_variable_search_handle_ignored_files_choices;


    /*
     * PROP_CONFIGURED_PEERMODE:
     *
     * General data:
     */
    gnet_property->props[186].name = "configured_peermode";
    gnet_property->props[186].desc = _("The peer mode you want to operate as for gtk-gnutella.  When auto is selected, gtk-gnutella will start as a leaf node and may be promoted to an ultra node if bandwidth and uptime permits, provided that you are not firewalled.");
    gnet_property->props[186].ev_changed = event_new("configured_peermode_changed");
    gnet_property->props[186].save = TRUE;
    gnet_property->props[186].vector_size = 1;
	mutex_init(&gnet_property->props[186].lock);

    /* Type specific data: */
    gnet_property->props[186].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[186].data.guint32.def   = (void *) &gnet_property_variable_configured_peermode_default;
    gnet_property->props[186].data.guint32.value = (void *) &gnet_property_variable_configured_peermode;
    gnet_property->props[186].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[186].data.guint32.min   = 0x00000000;
    gnet_property->props[186].data.guint32.choices = (void *) &gnet_property_variable_configured_peermode_choices;


    /*
     * PROP_CURRENT_PEERMODE:
     *
     * General data:
     */
    gnet_property->props[187].name = "current_peermode";
    gnet_property->props[187].desc = _("Current peer mode for gtk-gnutella.");
    gnet_property->props[187].ev_changed = event_new("current_peermode_changed");
    gnet_property->props[187].save = FALSE;
    gnet_property->props[187].vector_size = 1;
	mutex_init(&gnet_property->props[187].lock);

    /* Type specific data: */
    gnet_property->props[187].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[187].data.guint32.def   = (void *) &gnet_property_variable_current_peermode_default;
    gnet_property->props[187].data.guint32.value = (void *) &gnet_property_variable_current_peermode;
    gnet_property->props[187].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[187].data.guint32.min   = 0x00000000;
    gnet_property->props[187].data.guint32.choices = (void *) &gnet_property_variable_current_peermode_choices;


    /*
     * PROP_SYS_NOFILE:
     *
     * General data:
     */
    gnet_property->props[188].name = "sys_nofile";
    gnet_property->props[188].desc = _("How many file descriptors this process can open.");
    gnet_property->props[188].ev_changed = event_new("sys_nofile_changed");
    gnet_property->props[188].save = FALSE;
    gnet_property->props[188].vector_size = 1;
	mutex_init(&gnet_property->props[188].lock);

    /* Type specific data: */
    gnet_property->props[188].type               = PROP_TYPE_GUINT32;
    gnet_property->props[188].data.guint32.def   = (void *) &gnet_property_variable_sys_nofile_default;
    gnet_property->props[188].data.guint32.value = (void *) &gnet_property_variable_sys_nofile;
    gnet_property->props[188].data.guint32.choices = NULL;
    gnet_property->props[188].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[188].data.guint32.min   = 0x00000000;


    /*
     * PROP_SYS_PHYSMEM:
     *
     * General data:
     */
    gnet_property->props[189].name = "sys_physmem";
    gnet_property->props[189].desc = _("How much physical memory is available.");
    gnet_property->props[189].ev_changed = event_new("sys_physmem_changed");
    gnet_property->props[189].save = FALSE;
    gnet_property->props[189].vector_size = 1;
	mutex_init(&gnet_property->props[189].lock);

    /* Type specific data: */
    gnet_property->props[189].type               = PROP_TYPE_GUINT64;
    gnet_property->props[189].data.guint64.def   = (void *) &gnet_property_variable_sys_physmem_default;
    gnet_property->props[189].data.guint64.value = (void *) &gnet_property_variable_sys_physmem;
    gnet_property->props[189].data.guint64.choices = NULL;
    gnet_property->props[189].data.guint64.max   = (guint64) -1;
    gnet_property->props[189].data.guint64.min   = 0x0000000000000000;


    /*
     * PROP_DL_QUEUE_COUNT:
     *
     * General data:
     */
    gnet_property->props[190].name = "dl_queue_count";
    gnet_property->props[190].desc = _("How many downloads are currently held in the queue.");
    gnet_property->props[190].ev_changed = event_new("dl_queue_count_changed");
    gnet_property->props[190].save = FALSE;
    gnet_property->props[190].vector_size = 1;
	mutex_init(&gnet_property->props[190].lock);

    /* Type specific data: */
    gnet_property->props[190].type               = PROP_TYPE_GUINT32;
    gnet_property->props[190].data.guint32.def   = (void *) &gnet_property_variable_dl_queue_count_default;
    gnet_property->props[190].data.guint32.value = (void *) &gnet_property_variable_dl_queue_count;
    gnet_property->props[190].data.guint32.choices = NULL;
    gnet_property->props[190].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[190].data.guint32.min   = 0x00000000;


    /*
     * PROP_DL_RUNNING_COUNT:
     *
     * General data:
     */
    gnet_property->props[191].name = "dl_running_count";
    gnet_property->props[191].desc = _("How many downloads are currently running (downloading / connecting).");
    gnet_property->props[191].ev_changed = event_new("dl_running_count_changed");
    gnet_property->props[191].save = FALSE;
    gnet_property->props[191].vector_size = 1;
	mutex_init(&gnet_property->props[191].lock);

    /* Type specific data: */
    gnet_property->props[191].type               = PROP_TYPE_GUINT32;
    gnet_property->props[191].data.guint32.def   = (void *) &gnet_property_variable_dl_running_count_default;
    gnet_property->props[191].data.guint32.value = (void *) &gnet_property_variable_dl_running_count;
    gnet_property->props[191].data.guint32.choices = NULL;
    gnet_property->props[191].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[191].data.guint32.min   = 0x00000000;


    /*
     * PROP_DL_ACTIVE_COUNT:
     *
     * General data:
     */
    gnet_property->props[192].name = "dl_active_count";
    gnet_property->props[192].desc = _("How many downloads are currently active.");
    gnet_property->props[192].ev_changed = event_new("dl_active_count_changed");
    gnet_property->props[192].save = FALSE;
    gnet_property->props[192].vector_size = 1;
	mutex_init(&gnet_property->props[192].lock);

    /* Type specific data: */
    gnet_property->props[192].type               = PROP_TYPE_GUINT32;
    gnet_property->props[192].data.guint32.def   = (void *) &gnet_property_variable_dl_active_count_default;
    gnet_property->props[192].data.guint32.value = (void *) &gnet_property_variable_dl_active_count;
    gnet_property->props[192].data.guint32.choices = NULL;
    gnet_property->props[192].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[192].data.guint32.min   = 0x00000000;


    /*
     * PROP_DL_AQUEUED_COUNT:
     *
     * General data:
     */
    gnet_property->props[193].name = "dl_aqueued_count";
    gnet_property->props[193].desc = _("How many downloads are currently actively queued.");
    gnet_property->props[193].ev_changed = event_new("dl_aqueued_count_changed");
    gnet_property->props[193].save = FALSE;
    gnet_property->props[193].vector_size = 1;
	mutex_init(&gnet_property->props[193].lock);

    /* Type specific data: */
    gnet_property->props[193].type               = PROP_TYPE_GUINT32;
    gnet_property->props[193].data.guint32.def   = (void *) &gnet_property_variable_dl_aqueued_count_default;
    gnet_property->props[193].data.guint32.value = (void *) &gnet_property_variable_dl_aqueued_count;
    gnet_property->props[193].data.guint32.choices = NULL;
    gnet_property->props[193].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[193].data.guint32.min   = 0x00000000;


    /*
     * PROP_DL_PQUEUED_COUNT:
     *
     * General data:
     */
    gnet_property->props[194].name = "dl_pqueued_count";
    gnet_property->props[194].desc = _("How many downloads are currently passively queued.");
    gnet_property->props[194].ev_changed = event_new("dl_pqueued_count_changed");
    gnet_property->props[194].save = FALSE;
    gnet_property->props[194].vector_size = 1;
	mutex_init(&gnet_property->props[194].lock);

    /* Type specific data: */
    gnet_property->props[194].type               = PROP_TYPE_GUINT32;
    gnet_property->props[194].data.guint32.def   = (void *) &gnet_property_variable_dl_pqueued_count_default;
    gnet_property->props[194].data.guint32.value = (void *) &gnet_property_variable_dl_pqueued_count;
    gnet_property->props[194].data.guint32.choices = NULL;
    gnet_property->props[194].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[194].data.guint32.min   = 0x00000000;


    /*
     * PROP_FI_ALL_COUNT:
     *
     * General data:
     */
    gnet_property->props[195].name = "fi_all_count";
    gnet_property->props[195].desc = _("How many fileinfo do we have.");
    gnet_property->props[195].ev_changed = event_new("fi_all_count_changed");
    gnet_property->props[195].save = FALSE;
    gnet_property->props[195].vector_size = 1;
	mutex_init(&gnet_property->props[195].lock);

    /* Type specific data: */
    gnet_property->props[195].type               = PROP_TYPE_GUINT32;
    gnet_property->props[195].data.guint32.def   = (void *) &gnet_property_variable_fi_all_count_default;
    gnet_property->props[195].data.guint32.value = (void *) &gnet_property_variable_fi_all_count;
    gnet_property->props[195].data.guint32.choices = NULL;
    gnet_property->props[195].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[195].data.guint32.min   = 0x00000000;


    /*
     * PROP_FI_WITH_SOURCE_COUNT:
     *
     * General data:
     */
    gnet_property->props[196].name = "fi_with_source_count";
    gnet_property->props[196].desc = _("How many fileinfo with sources do we have.");
    gnet_property->props[196].ev_changed = event_new("fi_with_source_count_changed");
    gnet_property->props[196].save = FALSE;
    gnet_property->props[196].vector_size = 1;
	mutex_init(&gnet_property->props[196].lock);

    /* Type specific data: */
    gnet_property->props[196].type               = PROP_TYPE_GUINT32;
    gnet_property->props[196].data.guint32.def   = (void *) &gnet_property_variable_fi_with_source_count_default;
    gnet_property->props[196].data.guint32.value = (void *) &gnet_property_variable_fi_with_source_count;
    gnet_property->props[196].data.guint32.choices = NULL;
    gnet_property->props[196].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[196].data.guint32.min   = 0x00000000;


    /*
     * PROP_DL_QALIVE_COUNT:
     *
     * General data:
     */
    gnet_property->props[197].name = "dl_qalive_count";
    gnet_property->props[197].desc = _("How many queued downloads are currently responsive (remote servent answering requests).");
    gnet_property->props[197].ev_changed = event_new("dl_qalive_count_changed");
    gnet_property->props[197].save = FALSE;
    gnet_property->props[197].vector_size = 1;
	mutex_init(&gnet_property->props[197].lock);

    /* Type specific data: */
    gnet_property->props[197].type               = PROP_TYPE_GUINT32;
    gnet_property->props[197].data.guint32.def   = (void *) &gnet_property_variable_dl_qalive_count_default;
    gnet_property->props[197].data.guint32.value = (void *) &gnet_property_variable_dl_qalive_count;
    gnet_property->props[197].data.guint32.choices = NULL;
    gnet_property->props[197].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[197].data.guint32.min   = 0x00000000;


    /*
     * PROP_DL_BYTE_COUNT:
     *
     * General data:
     */
    gnet_property->props[198].name = "dl_byte_count";
    gnet_property->props[198].desc = _("Amount of bytes downloaded so far, HTTP headers notwithstanding.");
    gnet_property->props[198].ev_changed = event_new("dl_byte_count_changed");
    gnet_property->props[198].save = FALSE;
    gnet_property->props[198].vector_size = 1;
	mutex_init(&gnet_property->props[198].lock);

    /* Type specific data: */
    gnet_property->props[198].type               = PROP_TYPE_GUINT64;
    gnet_property->props[198].data.guint64.def   = (void *) &gnet_property_variable_dl_byte_count_default;
    gnet_property->props[198].data.guint64.value = (void *) &gnet_property_variable_dl_byte_count;
    gnet_property->props[198].data.guint64.choices = NULL;
    gnet_property->props[198].data.guint64.max   = (guint64) -1;
    gnet_property->props[198].data.guint64.min   = 0x0000000000000000;


    /*
     * PROP_UL_BYTE_COUNT:
     *
     * General data:
     */
    gnet_property->props[199].name = "ul_byte_count";
    gnet_property->props[199].desc = _("Amount of bytes uploaded so far, HTTP headers notwithstanding.");
    gnet_property->props[199].ev_changed = event_new("ul_byte_count_changed");
    gnet_property->props[199].save = FALSE;
    gnet_property->props[199].vector_size = 1;
	mutex_init(&gnet_property->props[199].lock);

    /* Type specific data: */
    gnet_property->props[199].type               = PROP_TYPE_GUINT64;
    gnet_property->props[199].data.guint64.def   = (void *) &gnet_property_variable_ul_byte_count_default;
    gnet_property->props[199].data.guint64.value = (void *) &gnet_property_variable_ul_byte_count;
    gnet_property->props[199].data.guint64.choices = NULL;
    gnet_property->props[199].data.guint64.max   = (guint64) -1;
    gnet_property->props[199].data.guint64.min   = 0x0000000000000000;


    /*
     * PROP_PFSP_SERVER:
     *
     * General data:
     */
    gnet_property->props[200].name = "pfsp_server";
    gnet_property->props[200].desc = _("Whether gtk-gnutella should serve partial files whilst they are still incompletely downloaded.  Recommended for network's health unless you already share many files, in which case it does no harm to leave it in, but will not matter as much.");
    gnet_property->props[200].ev_changed = event_new("pfsp_server_changed");
    gnet_property->props[200].save = TRUE;
    gnet_property->props[200].vector_size = 1;
	mutex_init(&gnet_property->props[200].lock);

    /* Type specific data: */
    gnet_property->props[200].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[200].data.boolean.def   = (void *) &gnet_property_variable_pfsp_server_default;
    gnet_property->props[200].data.boolean.value = (void *) &gnet_property_variable_pfsp_server;


    /*
     * PROP_PFSP_FIRST_CHUNK:
     *
     * General data:
     */
    gnet_property->props[201].name = "pfsp_first_chunk";
    gnet_property->props[201].desc = _("When partial file sharing (PFSP) is enabled, gtk-gnutella will strive to download chunks in a random order, to maximize the spreading of the file in the network.  However, this makes auditing (file type, pre-viewing, etc...) of the file impossible. This field sets the size in bytes of the first chunk of data that should be continuously downloaded at the beginning of the file.  Don't set it too large.");
    gnet_property->props[201].ev_changed = event_new("pfsp_first_chunk_changed");
    gnet_property->props[201].save = TRUE;
    gnet_property->props[201].vector_size = 1;
	mutex_init(&gnet_property->props[201].lock);

    /* Type specific data: */
    gnet_property->props[201].type               = PROP_TYPE_GUINT32;
    gnet_property->props[201].data.guint32.def   = (void *) &gnet_property_variable_pfsp_first_chunk_default;
    gnet_property->props[201].data.guint32.value = (void *) &gnet_property_variable_pfsp_first_chunk;
    gnet_property->props[201].data.guint32.choices = NULL;
    gnet_property->props[201].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[201].data.guint32.min   = 0x00000000;


    /*
     * PROP_PFSP_MINIMUM_FILESIZE:
     *
     * General data:
     */
    gnet_property->props[202].name = "pfsp_minimum_filesize";
    gnet_property->props[202].desc = _("When partial file sharing (PFSP) is enabled, gtk-gnutella will not share partial files below this filesize. Don't set it too large.");
    gnet_property->props[202].ev_changed = event_new("pfsp_minimum_filesize_changed");
    gnet_property->props[202].save = TRUE;
    gnet_property->props[202].vector_size = 1;
	mutex_init(&gnet_property->props[202].lock);

    /* Type specific data: */
    gnet_property->props[202].type               = PROP_TYPE_GUINT32;
    gnet_property->props[202].data.guint32.def   = (void *) &gnet_property_variable_pfsp_minimum_filesize_default;
    gnet_property->props[202].data.guint32.value = (void *) &gnet_property_variable_pfsp_minimum_filesize;
    gnet_property->props[202].data.guint32.choices = NULL;
    gnet_property->props[202].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[202].data.guint32.min   = 0x00000000;


    /*
     * PROP_CRAWLER_VISIT_COUNT:
     *
     * General data:
     */
    gnet_property->props[203].name = "crawler_visit_count";
    gnet_property->props[203].desc = _("Number of crawler visits during this session.");
    gnet_property->props[203].ev_changed = event_new("crawler_visit_count_changed");
    gnet_property->props[203].save = FALSE;
    gnet_property->props[203].vector_size = 1;
	mutex_init(&gnet_property->props[203].lock);

    /* Type specific data: */
    gnet_property->props[203].type               = PROP_TYPE_GUINT32;
    gnet_property->props[203].data.guint32.def   = (void *) &gnet_property_variable_crawler_visit_count_default;
    gnet_property->props[203].data.guint32.value = (void *) &gnet_property_variable_crawler_visit_count;
    gnet_property->props[203].data.guint32.choices = NULL;
    gnet_property->props[203].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[203].data.guint32.min   = 0x00000000;


    /*
     * PROP_UDP_CRAWLER_VISIT_COUNT:
     *
     * General data:
     */
    gnet_property->props[204].name = "udp_crawler_visit_count";
    gnet_property->props[204].desc = _("Number of UDP crawler visits during this session.");
    gnet_property->props[204].ev_changed = event_new("udp_crawler_visit_count_changed");
    gnet_property->props[204].save = FALSE;
    gnet_property->props[204].vector_size = 1;
	mutex_init(&gnet_property->props[204].lock);

    /* Type specific data: */
    gnet_property->props[204].type               = PROP_TYPE_GUINT32;
    gnet_property->props[204].data.guint32.def   = (void *) &gnet_property_variable_udp_crawler_visit_count_default;
    gnet_property->props[204].data.guint32.value = (void *) &gnet_property_variable_udp_crawler_visit_count;
    gnet_property->props[204].data.guint32.choices = NULL;
    gnet_property->props[204].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[204].data.guint32.min   = 0x00000000;


    /*
     * PROP_HOST_RUNS_NTP:
     *
     * General data:
     */
    gnet_property->props[205].name = "host_runs_ntp";
    gnet_property->props[205].desc = _("Whether the clock of this host is kept accurate via NTP. When set, the computed clock skew is ignored. Normally, gtk-gnutella automatically determines whether you are running NTP locally, but it won't be able to determine whether your host is kept synchronized by regular calls to ntpdate, for instance.");
    gnet_property->props[205].ev_changed = event_new("host_runs_ntp_changed");
    gnet_property->props[205].save = TRUE;
    gnet_property->props[205].vector_size = 1;
	mutex_init(&gnet_property->props[205].lock);

    /* Type specific data: */
    gnet_property->props[205].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[205].data.boolean.def   = (void *) &gnet_property_variable_host_runs_ntp_default;
    gnet_property->props[205].data.boolean.value = (void *) &gnet_property_variable_host_runs_ntp;


    /*
     * PROP_NTP_DETECTED:
     *
     * General data:
     */
    gnet_property->props[206].name = "ntp_detected";
    gnet_property->props[206].desc = _("Whether a running NTP daemon was detected locally.");
    gnet_property->props[206].ev_changed = event_new("ntp_detected_changed");
    gnet_property->props[206].save = FALSE;
    gnet_property->props[206].vector_size = 1;
	mutex_init(&gnet_property->props[206].lock);

    /* Type specific data: */
    gnet_property->props[206].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[206].data.boolean.def   = (void *) &gnet_property_variable_ntp_detected_default;
    gnet_property->props[206].data.boolean.value = (void *) &gnet_property_variable_ntp_detected;


    /*
     * PROP_CLOCK_SKEW:
     *
     * General data:
     */
    gnet_property->props[207].name = "clock_skew";
    gnet_property->props[207].desc = _("The signed clock skew of this host compared to absolute time. Adding this skew to the host clock should give the true time.");
    gnet_property->props[207].ev_changed = event_new("clock_skew_changed");
    gnet_property->props[207].save = TRUE;
    gnet_property->props[207].vector_size = 1;
	mutex_init(&gnet_property->props[207].lock);

    /* Type specific data: */
    gnet_property->props[207].type               = PROP_TYPE_GUINT32;
    gnet_property->props[207].data.guint32.def   = (void *) &gnet_property_variable_clock_skew_default;
    gnet_property->props[207].data.guint32.value = (void *) &gnet_property_variable_clock_skew;
    gnet_property->props[207].data.guint32.choices = NULL;
    gnet_property->props[207].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[207].data.guint32.min   = 0x00000000;


    /*
     * PROP_NODE_MONITOR_UNSTABLE_IP:
     *
     * General data:
     */
    gnet_property->props[208].name = "node_monitor_unstable_ip";
    gnet_property->props[208].desc = _("Whether gtk-gnutella should keep track of the IP of unstable servents it encounters, preventing further connections attempts to/from them.");
    gnet_property->props[208].ev_changed = event_new("node_monitor_unstable_ip_changed");
    gnet_property->props[208].save = TRUE;
    gnet_property->props[208].vector_size = 1;
	mutex_init(&gnet_property->props[208].lock);

    /* Type specific data: */
    gnet_property->props[208].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[208].data.boolean.def   = (void *) &gnet_property_variable_node_monitor_unstable_ip_default;
    gnet_property->props[208].data.boolean.value = (void *) &gnet_property_variable_node_monitor_unstable_ip;


    /*
     * PROP_NODE_MONITOR_UNSTABLE_SERVENTS:
     *
     * General data:
     */
    gnet_property->props[209].name = "node_monitor_unstable_servents";
    gnet_property->props[209].desc = _("Whether gtk-gnutella should determine the servent types (as identified by their vendor string) that are unstable, preventing further connections to/from them.  This only works when gtk-gnutella already keeps track of unstable IP addresses.");
    gnet_property->props[209].ev_changed = event_new("node_monitor_unstable_servents_changed");
    gnet_property->props[209].save = TRUE;
    gnet_property->props[209].vector_size = 1;
	mutex_init(&gnet_property->props[209].lock);

    /* Type specific data: */
    gnet_property->props[209].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[209].data.boolean.def   = (void *) &gnet_property_variable_node_monitor_unstable_servents_default;
    gnet_property->props[209].data.boolean.value = (void *) &gnet_property_variable_node_monitor_unstable_servents;


    /*
     * PROP_DL_REMOVE_FILE_ON_MISMATCH:
     *
     * General data:
     */
    gnet_property->props[210].name = "dl_remove_file_on_mismatch";
    gnet_property->props[210].desc = _("Whether gtk-gnutella should automatically remove the file whenever it gets a resuming mismatch and retry from scratch. Until Tiger Tree Hashes are widespread, this is the easiest option.");
    gnet_property->props[210].ev_changed = event_new("dl_remove_file_on_mismatch_changed");
    gnet_property->props[210].save = TRUE;
    gnet_property->props[210].vector_size = 1;
	mutex_init(&gnet_property->props[210].lock);

    /* Type specific data: */
    gnet_property->props[210].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[210].data.boolean.def   = (void *) &gnet_property_variable_dl_remove_file_on_mismatch_default;
    gnet_property->props[210].data.boolean.value = (void *) &gnet_property_variable_dl_remove_file_on_mismatch;


    /*
     * PROP_DL_MISMATCH_BACKOUT:
     *
     * General data:
     */
    gnet_property->props[211].name = "dl_mismatch_backout";
    gnet_property->props[211].desc = _("The amount of bytes which gtk-gnutella will strip off the already downloaded bytes after a resuming mismatch, in the hope that only this amount was corrupted, preventing proper resuming. Most of the time, a resuming mismatch indicates bad data on the server, but if the already downloaded data is bad then backing out some of it may allow us to recover from the problem.");
    gnet_property->props[211].ev_changed = event_new("dl_mismatch_backout_changed");
    gnet_property->props[211].save = TRUE;
    gnet_property->props[211].vector_size = 1;
	mutex_init(&gnet_property->props[211].lock);

    /* Type specific data: */
    gnet_property->props[211].type               = PROP_TYPE_GUINT32;
    gnet_property->props[211].data.guint32.def   = (void *) &gnet_property_variable_dl_mismatch_backout_default;
    gnet_property->props[211].data.guint32.value = (void *) &gnet_property_variable_dl_mismatch_backout;
    gnet_property->props[211].data.guint32.choices = NULL;
    gnet_property->props[211].data.guint32.max   = 250000;
    gnet_property->props[211].data.guint32.min   = 0;


    /*
     * PROP_SERVER_HOSTNAME:
     *
     * General data:
     */
    gnet_property->props[212].name = "server_hostname";
    gnet_property->props[212].desc = _("The hostname of the server that can be used by downloaders to find the IP address via a DNS resolution.  If you have a dynamic IP address coupled with a dynamic DNS service, then this is valuable to downloaders: they may find your node even after a few rotations of your IP address.");
    gnet_property->props[212].ev_changed = event_new("server_hostname_changed");
    gnet_property->props[212].save = TRUE;
    gnet_property->props[212].vector_size = 1;
	mutex_init(&gnet_property->props[212].lock);

    /* Type specific data: */
    gnet_property->props[212].type               = PROP_TYPE_STRING;
    gnet_property->props[212].data.string.def    = (void *) &gnet_property_variable_server_hostname_default;
    gnet_property->props[212].data.string.value  = (void *) &gnet_property_variable_server_hostname;
    if (gnet_property->props[212].data.string.def) {
        *gnet_property->props[212].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[212].data.string.def));
    }


    /*
     * PROP_GIVE_SERVER_HOSTNAME:
     *
     * General data:
     */
    gnet_property->props[213].name = "give_server_hostname";
    gnet_property->props[213].desc = _("Whether gtk-gnutella should advertise the hostname of your server to downloaders and in query hits.");
    gnet_property->props[213].ev_changed = event_new("give_server_hostname_changed");
    gnet_property->props[213].save = TRUE;
    gnet_property->props[213].vector_size = 1;
	mutex_init(&gnet_property->props[213].lock);

    /* Type specific data: */
    gnet_property->props[213].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[213].data.boolean.def   = (void *) &gnet_property_variable_give_server_hostname_default;
    gnet_property->props[213].data.boolean.value = (void *) &gnet_property_variable_give_server_hostname;


    /*
     * PROP_RESERVE_GTKG_NODES:
     *
     * General data:
     */
    gnet_property->props[214].name = "reserve_gtkg_nodes";
    gnet_property->props[214].desc = _("Percentage of the number of connections we should reserve for gtk-gnutella nodes.");
    gnet_property->props[214].ev_changed = event_new("reserve_gtkg_nodes_changed");
    gnet_property->props[214].save = TRUE;
    gnet_property->props[214].vector_size = 1;
	mutex_init(&gnet_property->props[214].lock);

    /* Type specific data: */
    gnet_property->props[214].type               = PROP_TYPE_GUINT32;
    gnet_property->props[214].data.guint32.def   = (void *) &gnet_property_variable_reserve_gtkg_nodes_default;
    gnet_property->props[214].data.guint32.value = (void *) &gnet_property_variable_reserve_gtkg_nodes;
    gnet_property->props[214].data.guint32.choices = NULL;
    gnet_property->props[214].data.guint32.max   = 90;
    gnet_property->props[214].data.guint32.min   = 0;


    /*
     * PROP_UNIQUE_NODES:
     *
     * General data:
     */
    gnet_property->props[215].name = "unique_nodes";
    gnet_property->props[215].desc = _("Maximum percentage of slots a vendor can occupy.");
    gnet_property->props[215].ev_changed = event_new("unique_nodes_changed");
    gnet_property->props[215].save = TRUE;
    gnet_property->props[215].vector_size = 1;
	mutex_init(&gnet_property->props[215].lock);

    /* Type specific data: */
    gnet_property->props[215].type               = PROP_TYPE_GUINT32;
    gnet_property->props[215].data.guint32.def   = (void *) &gnet_property_variable_unique_nodes_default;
    gnet_property->props[215].data.guint32.value = (void *) &gnet_property_variable_unique_nodes;
    gnet_property->props[215].data.guint32.choices = NULL;
    gnet_property->props[215].data.guint32.max   = 100;
    gnet_property->props[215].data.guint32.min   = 10;


    /*
     * PROP_DOWNLOAD_RX_SIZE:
     *
     * General data:
     */
    gnet_property->props[216].name = "download_rx_size";
    gnet_property->props[216].desc = _("Size of the RX socket buffer to be used for downloads, in kibibytes. If you wish to avoid Gnutella downloads using up all your bandwidth, set it to a low value (default is 64K, which is fine). If you don't mind sucking up all the available bandwidth, increasing your connection latency, set it to a greater value. Remember: the smaller the value, the more you will be able to precisely control the incoming rate.");
    gnet_property->props[216].ev_changed = event_new("download_rx_size_changed");
    gnet_property->props[216].save = TRUE;
    gnet_property->props[216].vector_size = 1;
	mutex_init(&gnet_property->props[216].lock);

    /* Type specific data: */
    gnet_property->props[216].type               = PROP_TYPE_GUINT32;
    gnet_property->props[216].data.guint32.def   = (void *) &gnet_property_variable_download_rx_size_default;
    gnet_property->props[216].data.guint32.value = (void *) &gnet_property_variable_download_rx_size;
    gnet_property->props[216].data.guint32.choices = NULL;
    gnet_property->props[216].data.guint32.max   = 1024;
    gnet_property->props[216].data.guint32.min   = 0;


    /*
     * PROP_NODE_RX_SIZE:
     *
     * General data:
     */
    gnet_property->props[217].name = "node_rx_size";
    gnet_property->props[217].desc = _("Size of the RX socket buffer to be used for nodes, in kbytes. The lower the value, the faster the remote end will flow-control at the TCP/IP level if you don't read quickly enough, which would be the case if you limit the incoming bandwidth.");
    gnet_property->props[217].ev_changed = event_new("node_rx_size_changed");
    gnet_property->props[217].save = TRUE;
    gnet_property->props[217].vector_size = 1;
	mutex_init(&gnet_property->props[217].lock);

    /* Type specific data: */
    gnet_property->props[217].type               = PROP_TYPE_GUINT32;
    gnet_property->props[217].data.guint32.def   = (void *) &gnet_property_variable_node_rx_size_default;
    gnet_property->props[217].data.guint32.value = (void *) &gnet_property_variable_node_rx_size;
    gnet_property->props[217].data.guint32.choices = NULL;
    gnet_property->props[217].data.guint32.max   = 128;
    gnet_property->props[217].data.guint32.min   = 0;


    /*
     * PROP_UPLOAD_TX_SIZE:
     *
     * General data:
     */
    gnet_property->props[218].name = "upload_tx_size";
    gnet_property->props[218].desc = _("Size of the TX socket buffer to be used for uploads, in kibibytes.");
    gnet_property->props[218].ev_changed = event_new("upload_tx_size_changed");
    gnet_property->props[218].save = TRUE;
    gnet_property->props[218].vector_size = 1;
	mutex_init(&gnet_property->props[218].lock);

    /* Type specific data: */
    gnet_property->props[218].type               = PROP_TYPE_GUINT32;
    gnet_property->props[218].data.guint32.def   = (void *) &gnet_property_variable_upload_tx_size_default;
    gnet_property->props[218].data.guint32.value = (void *) &gnet_property_variable_upload_tx_size;
    gnet_property->props[218].data.guint32.choices = NULL;
    gnet_property->props[218].data.guint32.max   = 1024;
    gnet_property->props[218].data.guint32.min   = 0;


    /*
     * PROP_DL_HTTP_LATENCY:
     *
     * General data:
     */
    gnet_property->props[219].name = "dl_http_latency";
    gnet_property->props[219].desc = _("Average recent latency between the sending of the HTTP request and the reception of the reply from the remote server, in msecs.");
    gnet_property->props[219].ev_changed = event_new("dl_http_latency_changed");
    gnet_property->props[219].save = FALSE;
    gnet_property->props[219].vector_size = 1;
	mutex_init(&gnet_property->props[219].lock);

    /* Type specific data: */
    gnet_property->props[219].type               = PROP_TYPE_GUINT32;
    gnet_property->props[219].data.guint32.def   = (void *) &gnet_property_variable_dl_http_latency_default;
    gnet_property->props[219].data.guint32.value = (void *) &gnet_property_variable_dl_http_latency;
    gnet_property->props[219].data.guint32.choices = NULL;
    gnet_property->props[219].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[219].data.guint32.min   = 0x00000000;


    /*
     * PROP_NODE_LAST_ULTRA_CHECK:
     *
     * General data:
     */
    gnet_property->props[220].name = "node_last_ultra_check";
    gnet_property->props[220].desc = _("Last time at which we performed the ultrapeer requirement checks.");
    gnet_property->props[220].ev_changed = event_new("node_last_ultra_check_changed");
    gnet_property->props[220].save = TRUE;
    gnet_property->props[220].vector_size = 1;
	mutex_init(&gnet_property->props[220].lock);

    /* Type specific data: */
    gnet_property->props[220].type               = PROP_TYPE_TIMESTAMP;
    gnet_property->props[220].data.timestamp.def   = (void *) &gnet_property_variable_node_last_ultra_check_default;
    gnet_property->props[220].data.timestamp.value = (void *) &gnet_property_variable_node_last_ultra_check;
    gnet_property->props[220].data.timestamp.choices = NULL;
    gnet_property->props[220].data.timestamp.max   = (time_t) ((1U << 31) - 1);
    gnet_property->props[220].data.timestamp.min   = 0x0000000000000000;


    /*
     * PROP_NODE_LAST_ULTRA_LEAF_SWITCH:
     *
     * General data:
     */
    gnet_property->props[221].name = "node_last_ultra_leaf_switch";
    gnet_property->props[221].desc = _("Last time an automatic switch between ultra and leaf mode occurred.");
    gnet_property->props[221].ev_changed = event_new("node_last_ultra_leaf_switch_changed");
    gnet_property->props[221].save = FALSE;
    gnet_property->props[221].vector_size = 1;
	mutex_init(&gnet_property->props[221].lock);

    /* Type specific data: */
    gnet_property->props[221].type               = PROP_TYPE_TIMESTAMP;
    gnet_property->props[221].data.timestamp.def   = (void *) &gnet_property_variable_node_last_ultra_leaf_switch_default;
    gnet_property->props[221].data.timestamp.value = (void *) &gnet_property_variable_node_last_ultra_leaf_switch;
    gnet_property->props[221].data.timestamp.choices = NULL;
    gnet_property->props[221].data.timestamp.max   = (time_t) ((1U << 31) - 1);
    gnet_property->props[221].data.timestamp.min   = 0x0000000000000000;


    /*
     * PROP_UP_REQ_AVG_SERVENT_UPTIME:
     *
     * General data:
     */
    gnet_property->props[222].name = "up_req_avg_servent_uptime";
    gnet_property->props[222].desc = _("Whether we meet the sufficient average uptime requirement to become an Ultra node.");
    gnet_property->props[222].ev_changed = event_new("up_req_avg_servent_uptime_changed");
    gnet_property->props[222].save = FALSE;
    gnet_property->props[222].vector_size = 1;
	mutex_init(&gnet_property->props[222].lock);

    /* Type specific data: */
    gnet_property->props[222].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[222].data.boolean.def   = (void *) &gnet_property_variable_up_req_avg_servent_uptime_default;
    gnet_property->props[222].data.boolean.value = (void *) &gnet_property_variable_up_req_avg_servent_uptime;


    /*
     * PROP_UP_REQ_AVG_IP_UPTIME:
     *
     * General data:
     */
    gnet_property->props[223].name = "up_req_avg_ip_uptime";
    gnet_property->props[223].desc = _("Whether we meet the sufficient average IP address uptime requirement to become an Ultra node.");
    gnet_property->props[223].ev_changed = event_new("up_req_avg_ip_uptime_changed");
    gnet_property->props[223].save = FALSE;
    gnet_property->props[223].vector_size = 1;
	mutex_init(&gnet_property->props[223].lock);

    /* Type specific data: */
    gnet_property->props[223].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[223].data.boolean.def   = (void *) &gnet_property_variable_up_req_avg_ip_uptime_default;
    gnet_property->props[223].data.boolean.value = (void *) &gnet_property_variable_up_req_avg_ip_uptime;


    /*
     * PROP_UP_REQ_NODE_UPTIME:
     *
     * General data:
     */
    gnet_property->props[224].name = "up_req_node_uptime";
    gnet_property->props[224].desc = _("Whether we meet the sufficient node uptime requirement to become an Ultra node.");
    gnet_property->props[224].ev_changed = event_new("up_req_node_uptime_changed");
    gnet_property->props[224].save = FALSE;
    gnet_property->props[224].vector_size = 1;
	mutex_init(&gnet_property->props[224].lock);

    /* Type specific data: */
    gnet_property->props[224].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[224].data.boolean.def   = (void *) &gnet_property_variable_up_req_node_uptime_default;
    gnet_property->props[224].data.boolean.value = (void *) &gnet_property_variable_up_req_node_uptime;


    /*
     * PROP_UP_REQ_NOT_FIREWALLED:
     *
     * General data:
     */
    gnet_property->props[225].name = "up_req_not_firewalled";
    gnet_property->props[225].desc = _("Whether we meet the non-firewalled requirement to become an Ultra node.");
    gnet_property->props[225].ev_changed = event_new("up_req_not_firewalled_changed");
    gnet_property->props[225].save = FALSE;
    gnet_property->props[225].vector_size = 1;
	mutex_init(&gnet_property->props[225].lock);

    /* Type specific data: */
    gnet_property->props[225].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[225].data.boolean.def   = (void *) &gnet_property_variable_up_req_not_firewalled_default;
    gnet_property->props[225].data.boolean.value = (void *) &gnet_property_variable_up_req_not_firewalled;


    /*
     * PROP_UP_REQ_ENOUGH_CONN:
     *
     * General data:
     */
    gnet_property->props[226].name = "up_req_enough_conn";
    gnet_property->props[226].desc = _("Whether we meet the minimum amount of peer connections requirement to become an Ultra node.");
    gnet_property->props[226].ev_changed = event_new("up_req_enough_conn_changed");
    gnet_property->props[226].save = FALSE;
    gnet_property->props[226].vector_size = 1;
	mutex_init(&gnet_property->props[226].lock);

    /* Type specific data: */
    gnet_property->props[226].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[226].data.boolean.def   = (void *) &gnet_property_variable_up_req_enough_conn_default;
    gnet_property->props[226].data.boolean.value = (void *) &gnet_property_variable_up_req_enough_conn;


    /*
     * PROP_UP_REQ_ENOUGH_FD:
     *
     * General data:
     */
    gnet_property->props[227].name = "up_req_enough_fd";
    gnet_property->props[227].desc = _("Whether we meet the amount of file descriptor requirement to become an Ultra node.");
    gnet_property->props[227].ev_changed = event_new("up_req_enough_fd_changed");
    gnet_property->props[227].save = FALSE;
    gnet_property->props[227].vector_size = 1;
	mutex_init(&gnet_property->props[227].lock);

    /* Type specific data: */
    gnet_property->props[227].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[227].data.boolean.def   = (void *) &gnet_property_variable_up_req_enough_fd_default;
    gnet_property->props[227].data.boolean.value = (void *) &gnet_property_variable_up_req_enough_fd;


    /*
     * PROP_UP_REQ_ENOUGH_MEM:
     *
     * General data:
     */
    gnet_property->props[228].name = "up_req_enough_mem";
    gnet_property->props[228].desc = _("Whether we meet the memory requirements to become an Ultra node.");
    gnet_property->props[228].ev_changed = event_new("up_req_enough_mem_changed");
    gnet_property->props[228].save = FALSE;
    gnet_property->props[228].vector_size = 1;
	mutex_init(&gnet_property->props[228].lock);

    /* Type specific data: */
    gnet_property->props[228].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[228].data.boolean.def   = (void *) &gnet_property_variable_up_req_enough_mem_default;
    gnet_property->props[228].data.boolean.value = (void *) &gnet_property_variable_up_req_enough_mem;


    /*
     * PROP_UP_REQ_ENOUGH_BW:
     *
     * General data:
     */
    gnet_property->props[229].name = "up_req_enough_bw";
    gnet_property->props[229].desc = _("Whether we meet the bandwidth requirements to become an Ultra node.");
    gnet_property->props[229].ev_changed = event_new("up_req_enough_bw_changed");
    gnet_property->props[229].save = FALSE;
    gnet_property->props[229].vector_size = 1;
	mutex_init(&gnet_property->props[229].lock);

    /* Type specific data: */
    gnet_property->props[229].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[229].data.boolean.def   = (void *) &gnet_property_variable_up_req_enough_bw_default;
    gnet_property->props[229].data.boolean.value = (void *) &gnet_property_variable_up_req_enough_bw;


    /*
     * PROP_UP_REQ_GOOD_UDP:
     *
     * General data:
     */
    gnet_property->props[230].name = "up_req_good_udp";
    gnet_property->props[230].desc = _("Whether we meet the UDP requirements to become an Ultra node.");
    gnet_property->props[230].ev_changed = event_new("up_req_good_udp_changed");
    gnet_property->props[230].save = FALSE;
    gnet_property->props[230].vector_size = 1;
	mutex_init(&gnet_property->props[230].lock);

    /* Type specific data: */
    gnet_property->props[230].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[230].data.boolean.def   = (void *) &gnet_property_variable_up_req_good_udp_default;
    gnet_property->props[230].data.boolean.value = (void *) &gnet_property_variable_up_req_good_udp;


    /*
     * PROP_SEARCH_QUEUE_SIZE:
     *
     * General data:
     */
    gnet_property->props[231].name = "search_queue_size";
    gnet_property->props[231].desc = _("Size of the search queue holding the locally generated queries before they are sent on a given connection.  When full, the oldest query is dropped without being sent.  Set it so that it is slightly larger than the amount of opened searches.");
    gnet_property->props[231].ev_changed = event_new("search_queue_size_changed");
    gnet_property->props[231].save = TRUE;
    gnet_property->props[231].vector_size = 1;
	mutex_init(&gnet_property->props[231].lock);

    /* Type specific data: */
    gnet_property->props[231].type               = PROP_TYPE_GUINT32;
    gnet_property->props[231].data.guint32.def   = (void *) &gnet_property_variable_search_queue_size_default;
    gnet_property->props[231].data.guint32.value = (void *) &gnet_property_variable_search_queue_size;
    gnet_property->props[231].data.guint32.choices = NULL;
    gnet_property->props[231].data.guint32.max   = 512;
    gnet_property->props[231].data.guint32.min   = 32;


    /*
     * PROP_SEARCH_QUEUE_SPACING:
     *
     * General data:
     */
    gnet_property->props[232].name = "search_queue_spacing";
    gnet_property->props[232].desc = _("Minimum amount of seconds between two consecutive queries sent to a given connection (for locally generated queries only!). The larger the value, the less negative impact it has on the network.");
    gnet_property->props[232].ev_changed = event_new("search_queue_spacing_changed");
    gnet_property->props[232].save = TRUE;
    gnet_property->props[232].vector_size = 1;
	mutex_init(&gnet_property->props[232].lock);

    /* Type specific data: */
    gnet_property->props[232].type               = PROP_TYPE_GUINT32;
    gnet_property->props[232].data.guint32.def   = (void *) &gnet_property_variable_search_queue_spacing_default;
    gnet_property->props[232].data.guint32.value = (void *) &gnet_property_variable_search_queue_spacing;
    gnet_property->props[232].data.guint32.choices = NULL;
    gnet_property->props[232].data.guint32.max   = 60;
    gnet_property->props[232].data.guint32.min   = 10;


    /*
     * PROP_ENABLE_SHELL:
     *
     * General data:
     */
    gnet_property->props[233].name = "enable_shell";
    gnet_property->props[233].desc = _("Whether connection to gtk-gnutella via the 'shell' control interface should be allowed.");
    gnet_property->props[233].ev_changed = event_new("enable_shell_changed");
    gnet_property->props[233].save = TRUE;
    gnet_property->props[233].vector_size = 1;
	mutex_init(&gnet_property->props[233].lock);

    /* Type specific data: */
    gnet_property->props[233].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[233].data.boolean.def   = (void *) &gnet_property_variable_enable_shell_default;
    gnet_property->props[233].data.boolean.value = (void *) &gnet_property_variable_enable_shell;


    /*
     * PROP_REMOTE_SHELL_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[234].name = "remote_shell_timeout";
    gnet_property->props[234].desc = _("Amount of seconds until an idle remote shell session gets disconnected. If set to zero, no timeout occurs.");
    gnet_property->props[234].ev_changed = event_new("remote_shell_timeout_changed");
    gnet_property->props[234].save = TRUE;
    gnet_property->props[234].vector_size = 1;
	mutex_init(&gnet_property->props[234].lock);

    /* Type specific data: */
    gnet_property->props[234].type               = PROP_TYPE_GUINT32;
    gnet_property->props[234].data.guint32.def   = (void *) &gnet_property_variable_remote_shell_timeout_default;
    gnet_property->props[234].data.guint32.value = (void *) &gnet_property_variable_remote_shell_timeout;
    gnet_property->props[234].data.guint32.choices = NULL;
    gnet_property->props[234].data.guint32.max   = 31536000;
    gnet_property->props[234].data.guint32.min   = 0;


    /*
     * PROP_ENTRY_REMOVAL_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[235].name = "entry_removal_timeout";
    gnet_property->props[235].desc = _("Amount of seconds to leave 'dead' entries around so that they can still be displayed by the GUI along with the termination status.");
    gnet_property->props[235].ev_changed = event_new("entry_removal_timeout_changed");
    gnet_property->props[235].save = TRUE;
    gnet_property->props[235].vector_size = 1;
	mutex_init(&gnet_property->props[235].lock);

    /* Type specific data: */
    gnet_property->props[235].type               = PROP_TYPE_GUINT32;
    gnet_property->props[235].data.guint32.def   = (void *) &gnet_property_variable_entry_removal_timeout_default;
    gnet_property->props[235].data.guint32.value = (void *) &gnet_property_variable_entry_removal_timeout;
    gnet_property->props[235].data.guint32.choices = NULL;
    gnet_property->props[235].data.guint32.max   = 60;
    gnet_property->props[235].data.guint32.min   = 1;


    /*
     * PROP_NODE_WATCH_SIMILAR_QUERIES:
     *
     * General data:
     */
    gnet_property->props[236].name = "node_watch_similar_queries";
    gnet_property->props[236].desc = _("Whether gtk-gnutella should actively monitor query strings by TTL and hop count and drop duplicates.  Only applies when not running as a leaf node, and only for queries with hop count > 0, i.e. not from our immediate neighbor.  Dropped queries will be accounted for in the 'Message throttle' counter.");
    gnet_property->props[236].ev_changed = event_new("node_watch_similar_queries_changed");
    gnet_property->props[236].save = TRUE;
    gnet_property->props[236].vector_size = 1;
	mutex_init(&gnet_property->props[236].lock);

    /* Type specific data: */
    gnet_property->props[236].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[236].data.boolean.def   = (void *) &gnet_property_variable_node_watch_similar_queries_default;
    gnet_property->props[236].data.boolean.value = (void *) &gnet_property_variable_node_watch_similar_queries;


    /*
     * PROP_NODE_QUERIES_HALF_LIFE:
     *
     * General data:
     */
    gnet_property->props[237].name = "node_queries_half_life";
    gnet_property->props[237].desc = _("Half the duration during which gtk-gnutella should remember the recently relayed queries by TTL and hop count.  The default value of 5 should be just fine, but you can experiment with different settings if you want.  The higher it is set, the more likely you are to drop legitimate queries, so be careful.");
    gnet_property->props[237].ev_changed = event_new("node_queries_half_life_changed");
    gnet_property->props[237].save = TRUE;
    gnet_property->props[237].vector_size = 1;
	mutex_init(&gnet_property->props[237].lock);

    /* Type specific data: */
    gnet_property->props[237].type               = PROP_TYPE_GUINT32;
    gnet_property->props[237].data.guint32.def   = (void *) &gnet_property_variable_node_queries_half_life_default;
    gnet_property->props[237].data.guint32.value = (void *) &gnet_property_variable_node_queries_half_life;
    gnet_property->props[237].data.guint32.choices = NULL;
    gnet_property->props[237].data.guint32.max   = 10;
    gnet_property->props[237].data.guint32.min   = 1;


    /*
     * PROP_NODE_REQUERY_THRESHOLD:
     *
     * General data:
     */
    gnet_property->props[238].name = "node_requery_threshold";
    gnet_property->props[238].desc = _("The minimum amount of seconds to enforce between two identical queries from leaf nodes.  If the requery too early, it is dropped and accounted for in the 'Message throttle' counter.  Too frequent requeries are harmful for the network, yet we must allow some amount of requerying given the dynamic nature of Gnutella connections.  You can't disable this checking, but you can lower the constraint significantly. Deviations from the default of 1700 have exponential effects on the network traffic.");
    gnet_property->props[238].ev_changed = event_new("node_requery_threshold_changed");
    gnet_property->props[238].save = TRUE;
    gnet_property->props[238].vector_size = 1;
	mutex_init(&gnet_property->props[238].lock);

    /* Type specific data: */
    gnet_property->props[238].type               = PROP_TYPE_GUINT32;
    gnet_property->props[238].data.guint32.def   = (void *) &gnet_property_variable_node_requery_threshold_default;
    gnet_property->props[238].data.guint32.value = (void *) &gnet_property_variable_node_requery_threshold;
    gnet_property->props[238].data.guint32.choices = NULL;
    gnet_property->props[238].data.guint32.max   = 1800;
    gnet_property->props[238].data.guint32.min   = 1200;


    /*
     * PROP_LIBRARY_RESCAN_STARTED:
     *
     * General data:
     */
    gnet_property->props[239].name = "library_rescan_started";
    gnet_property->props[239].desc = _("Time at which we started the last scan of the library.");
    gnet_property->props[239].ev_changed = event_new("library_rescan_started_changed");
    gnet_property->props[239].save = FALSE;
    gnet_property->props[239].vector_size = 1;
	mutex_init(&gnet_property->props[239].lock);

    /* Type specific data: */
    gnet_property->props[239].type               = PROP_TYPE_TIMESTAMP;
    gnet_property->props[239].data.timestamp.def   = (void *) &gnet_property_variable_library_rescan_started_default;
    gnet_property->props[239].data.timestamp.value = (void *) &gnet_property_variable_library_rescan_started;
    gnet_property->props[239].data.timestamp.choices = NULL;
    gnet_property->props[239].data.timestamp.max   = (time_t) ((1U << 31) - 1);
    gnet_property->props[239].data.timestamp.min   = 0x0000000000000000;


    /*
     * PROP_LIBRARY_RESCAN_FINISHED:
     *
     * General data:
     */
    gnet_property->props[240].name = "library_rescan_finished";
    gnet_property->props[240].desc = _("Time at which the last scan of the library finished.");
    gnet_property->props[240].ev_changed = event_new("library_rescan_finished_changed");
    gnet_property->props[240].save = FALSE;
    gnet_property->props[240].vector_size = 1;
	mutex_init(&gnet_property->props[240].lock);

    /* Type specific data: */
    gnet_property->props[240].type               = PROP_TYPE_TIMESTAMP;
    gnet_property->props[240].data.timestamp.def   = (void *) &gnet_property_variable_library_rescan_finished_default;
    gnet_property->props[240].data.timestamp.value = (void *) &gnet_property_variable_library_rescan_finished;
    gnet_property->props[240].data.timestamp.choices = NULL;
    gnet_property->props[240].data.timestamp.max   = (time_t) ((1U << 31) - 1);
    gnet_property->props[240].data.timestamp.min   = 0x0000000000000000;


    /*
     * PROP_LIBRARY_RESCAN_DURATION:
     *
     * General data:
     */
    gnet_property->props[241].name = "library_rescan_duration";
    gnet_property->props[241].desc = _("The number of seconds the last scan of the library took.");
    gnet_property->props[241].ev_changed = event_new("library_rescan_duration_changed");
    gnet_property->props[241].save = FALSE;
    gnet_property->props[241].vector_size = 1;
	mutex_init(&gnet_property->props[241].lock);

    /* Type specific data: */
    gnet_property->props[241].type               = PROP_TYPE_GUINT32;
    gnet_property->props[241].data.guint32.def   = (void *) &gnet_property_variable_library_rescan_duration_default;
    gnet_property->props[241].data.guint32.value = (void *) &gnet_property_variable_library_rescan_duration;
    gnet_property->props[241].data.guint32.choices = NULL;
    gnet_property->props[241].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[241].data.guint32.min   = 0x00000000;


    /*
     * PROP_QRP_INDEXING_STARTED:
     *
     * General data:
     */
    gnet_property->props[242].name = "qrp_indexing_started";
    gnet_property->props[242].desc = _("Time at which we started shared file indexing.");
    gnet_property->props[242].ev_changed = event_new("qrp_indexing_started_changed");
    gnet_property->props[242].save = FALSE;
    gnet_property->props[242].vector_size = 1;
	mutex_init(&gnet_property->props[242].lock);

    /* Type specific data: */
    gnet_property->props[242].type               = PROP_TYPE_TIMESTAMP;
    gnet_property->props[242].data.timestamp.def   = (void *) &gnet_property_variable_qrp_indexing_started_default;
    gnet_property->props[242].data.timestamp.value = (void *) &gnet_property_variable_qrp_indexing_started;
    gnet_property->props[242].data.timestamp.choices = NULL;
    gnet_property->props[242].data.timestamp.max   = (time_t) ((1U << 31) - 1);
    gnet_property->props[242].data.timestamp.min   = 0x0000000000000000;


    /*
     * PROP_QRP_INDEXING_DURATION:
     *
     * General data:
     */
    gnet_property->props[243].name = "qrp_indexing_duration";
    gnet_property->props[243].desc = _("Time spent indexing shared files.");
    gnet_property->props[243].ev_changed = event_new("qrp_indexing_duration_changed");
    gnet_property->props[243].save = FALSE;
    gnet_property->props[243].vector_size = 1;
	mutex_init(&gnet_property->props[243].lock);

    /* Type specific data: */
    gnet_property->props[243].type               = PROP_TYPE_GUINT32;
    gnet_property->props[243].data.guint32.def   = (void *) &gnet_property_variable_qrp_indexing_duration_default;
    gnet_property->props[243].data.guint32.value = (void *) &gnet_property_variable_qrp_indexing_duration;
    gnet_property->props[243].data.guint32.choices = NULL;
    gnet_property->props[243].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[243].data.guint32.min   = 0x00000000;


    /*
     * PROP_QRP_MEMORY:
     *
     * General data:
     */
    gnet_property->props[244].name = "qrp_memory";
    gnet_property->props[244].desc = _("Memory used by the QRP tables");
    gnet_property->props[244].ev_changed = event_new("qrp_memory_changed");
    gnet_property->props[244].save = FALSE;
    gnet_property->props[244].vector_size = 1;
	mutex_init(&gnet_property->props[244].lock);

    /* Type specific data: */
    gnet_property->props[244].type               = PROP_TYPE_GUINT32;
    gnet_property->props[244].data.guint32.def   = (void *) &gnet_property_variable_qrp_memory_default;
    gnet_property->props[244].data.guint32.value = (void *) &gnet_property_variable_qrp_memory;
    gnet_property->props[244].data.guint32.choices = NULL;
    gnet_property->props[244].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[244].data.guint32.min   = 0x00000000;


    /*
     * PROP_QRP_TIMESTAMP:
     *
     * General data:
     */
    gnet_property->props[245].name = "qrp_timestamp";
    gnet_property->props[245].desc = _("Time at which we started query routing table generation.");
    gnet_property->props[245].ev_changed = event_new("qrp_timestamp_changed");
    gnet_property->props[245].save = FALSE;
    gnet_property->props[245].vector_size = 1;
	mutex_init(&gnet_property->props[245].lock);

    /* Type specific data: */
    gnet_property->props[245].type               = PROP_TYPE_TIMESTAMP;
    gnet_property->props[245].data.timestamp.def   = (void *) &gnet_property_variable_qrp_timestamp_default;
    gnet_property->props[245].data.timestamp.value = (void *) &gnet_property_variable_qrp_timestamp;
    gnet_property->props[245].data.timestamp.choices = NULL;
    gnet_property->props[245].data.timestamp.max   = (time_t) ((1U << 31) - 1);
    gnet_property->props[245].data.timestamp.min   = 0x0000000000000000;


    /*
     * PROP_QRP_COMPUTATION_TIME:
     *
     * General data:
     */
    gnet_property->props[246].name = "qrp_computation_time";
    gnet_property->props[246].desc = _("Time spent computing the QRP table, in seconds.");
    gnet_property->props[246].ev_changed = event_new("qrp_computation_time_changed");
    gnet_property->props[246].save = FALSE;
    gnet_property->props[246].vector_size = 1;
	mutex_init(&gnet_property->props[246].lock);

    /* Type specific data: */
    gnet_property->props[246].type               = PROP_TYPE_GUINT32;
    gnet_property->props[246].data.guint32.def   = (void *) &gnet_property_variable_qrp_computation_time_default;
    gnet_property->props[246].data.guint32.value = (void *) &gnet_property_variable_qrp_computation_time;
    gnet_property->props[246].data.guint32.choices = NULL;
    gnet_property->props[246].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[246].data.guint32.min   = 0x00000000;


    /*
     * PROP_QRP_PATCH_TIMESTAMP:
     *
     * General data:
     */
    gnet_property->props[247].name = "qrp_patch_timestamp";
    gnet_property->props[247].desc = _("Time at which we started computing our QRP patch.");
    gnet_property->props[247].ev_changed = event_new("qrp_patch_timestamp_changed");
    gnet_property->props[247].save = FALSE;
    gnet_property->props[247].vector_size = 1;
	mutex_init(&gnet_property->props[247].lock);

    /* Type specific data: */
    gnet_property->props[247].type               = PROP_TYPE_TIMESTAMP;
    gnet_property->props[247].data.timestamp.def   = (void *) &gnet_property_variable_qrp_patch_timestamp_default;
    gnet_property->props[247].data.timestamp.value = (void *) &gnet_property_variable_qrp_patch_timestamp;
    gnet_property->props[247].data.timestamp.choices = NULL;
    gnet_property->props[247].data.timestamp.max   = (time_t) ((1U << 31) - 1);
    gnet_property->props[247].data.timestamp.min   = 0x0000000000000000;


    /*
     * PROP_QRP_PATCH_COMPUTATION_TIME:
     *
     * General data:
     */
    gnet_property->props[248].name = "qrp_patch_computation_time";
    gnet_property->props[248].desc = _("Time spent computing the QRP table patch, in seconds.");
    gnet_property->props[248].ev_changed = event_new("qrp_patch_computation_time_changed");
    gnet_property->props[248].save = FALSE;
    gnet_property->props[248].vector_size = 1;
	mutex_init(&gnet_property->props[248].lock);

    /* Type specific data: */
    gnet_property->props[248].type               = PROP_TYPE_GUINT32;
    gnet_property->props[248].data.guint32.def   = (void *) &gnet_property_variable_qrp_patch_computation_time_default;
    gnet_property->props[248].data.guint32.value = (void *) &gnet_property_variable_qrp_patch_computation_time;
    gnet_property->props[248].data.guint32.choices = NULL;
    gnet_property->props[248].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[248].data.guint32.min   = 0x00000000;


    /*
     * PROP_QRP_GENERATION:
     *
     * General data:
     */
    gnet_property->props[249].name = "qrp_generation";
    gnet_property->props[249].desc = _("Query routing table generation number.");
    gnet_property->props[249].ev_changed = event_new("qrp_generation_changed");
    gnet_property->props[249].save = FALSE;
    gnet_property->props[249].vector_size = 1;
	mutex_init(&gnet_property->props[249].lock);

    /* Type specific data: */
    gnet_property->props[249].type               = PROP_TYPE_GUINT32;
    gnet_property->props[249].data.guint32.def   = (void *) &gnet_property_variable_qrp_generation_default;
    gnet_property->props[249].data.guint32.value = (void *) &gnet_property_variable_qrp_generation;
    gnet_property->props[249].data.guint32.choices = NULL;
    gnet_property->props[249].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[249].data.guint32.min   = 0x00000000;


    /*
     * PROP_QRP_SLOTS:
     *
     * General data:
     */
    gnet_property->props[250].name = "qrp_slots";
    gnet_property->props[250].desc = _("Amount of slots used by our QRP table.");
    gnet_property->props[250].ev_changed = event_new("qrp_slots_changed");
    gnet_property->props[250].save = FALSE;
    gnet_property->props[250].vector_size = 1;
	mutex_init(&gnet_property->props[250].lock);

    /* Type specific data: */
    gnet_property->props[250].type               = PROP_TYPE_GUINT32;
    gnet_property->props[250].data.guint32.def   = (void *) &gnet_property_variable_qrp_slots_default;
    gnet_property->props[250].data.guint32.value = (void *) &gnet_property_variable_qrp_slots;
    gnet_property->props[250].data.guint32.choices = NULL;
    gnet_property->props[250].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[250].data.guint32.min   = 0x00000000;


    /*
     * PROP_QRP_SLOTS_FILLED:
     *
     * General data:
     */
    gnet_property->props[251].name = "qrp_slots_filled";
    gnet_property->props[251].desc = _("Amount of slots filled within our QRP table.");
    gnet_property->props[251].ev_changed = event_new("qrp_slots_filled_changed");
    gnet_property->props[251].save = FALSE;
    gnet_property->props[251].vector_size = 1;
	mutex_init(&gnet_property->props[251].lock);

    /* Type specific data: */
    gnet_property->props[251].type               = PROP_TYPE_GUINT32;
    gnet_property->props[251].data.guint32.def   = (void *) &gnet_property_variable_qrp_slots_filled_default;
    gnet_property->props[251].data.guint32.value = (void *) &gnet_property_variable_qrp_slots_filled;
    gnet_property->props[251].data.guint32.choices = NULL;
    gnet_property->props[251].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[251].data.guint32.min   = 0x00000000;


    /*
     * PROP_QRP_FILL_RATIO:
     *
     * General data:
     */
    gnet_property->props[252].name = "qrp_fill_ratio";
    gnet_property->props[252].desc = _("Percentage of slots filled within our QRP table.");
    gnet_property->props[252].ev_changed = event_new("qrp_fill_ratio_changed");
    gnet_property->props[252].save = FALSE;
    gnet_property->props[252].vector_size = 1;
	mutex_init(&gnet_property->props[252].lock);

    /* Type specific data: */
    gnet_property->props[252].type               = PROP_TYPE_GUINT32;
    gnet_property->props[252].data.guint32.def   = (void *) &gnet_property_variable_qrp_fill_ratio_default;
    gnet_property->props[252].data.guint32.value = (void *) &gnet_property_variable_qrp_fill_ratio;
    gnet_property->props[252].data.guint32.choices = NULL;
    gnet_property->props[252].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[252].data.guint32.min   = 0x00000000;


    /*
     * PROP_QRP_CONFLICT_RATIO:
     *
     * General data:
     */
    gnet_property->props[253].name = "qrp_conflict_ratio";
    gnet_property->props[253].desc = _("Percentage of hashing conflicts whilst inserting data in our QRP table.");
    gnet_property->props[253].ev_changed = event_new("qrp_conflict_ratio_changed");
    gnet_property->props[253].save = FALSE;
    gnet_property->props[253].vector_size = 1;
	mutex_init(&gnet_property->props[253].lock);

    /* Type specific data: */
    gnet_property->props[253].type               = PROP_TYPE_GUINT32;
    gnet_property->props[253].data.guint32.def   = (void *) &gnet_property_variable_qrp_conflict_ratio_default;
    gnet_property->props[253].data.guint32.value = (void *) &gnet_property_variable_qrp_conflict_ratio;
    gnet_property->props[253].data.guint32.choices = NULL;
    gnet_property->props[253].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[253].data.guint32.min   = 0x00000000;


    /*
     * PROP_QRP_HASHED_KEYWORDS:
     *
     * General data:
     */
    gnet_property->props[254].name = "qrp_hashed_keywords";
    gnet_property->props[254].desc = _("Amount of hashed keywords in our QRP table.");
    gnet_property->props[254].ev_changed = event_new("qrp_hashed_keywords_changed");
    gnet_property->props[254].save = FALSE;
    gnet_property->props[254].vector_size = 1;
	mutex_init(&gnet_property->props[254].lock);

    /* Type specific data: */
    gnet_property->props[254].type               = PROP_TYPE_GUINT32;
    gnet_property->props[254].data.guint32.def   = (void *) &gnet_property_variable_qrp_hashed_keywords_default;
    gnet_property->props[254].data.guint32.value = (void *) &gnet_property_variable_qrp_hashed_keywords;
    gnet_property->props[254].data.guint32.choices = NULL;
    gnet_property->props[254].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[254].data.guint32.min   = 0x00000000;


    /*
     * PROP_QRP_PATCH_RAW_LENGTH:
     *
     * General data:
     */
    gnet_property->props[255].name = "qrp_patch_raw_length";
    gnet_property->props[255].desc = _("Total raw size of the QRP table patch, in bytes.");
    gnet_property->props[255].ev_changed = event_new("qrp_patch_raw_length_changed");
    gnet_property->props[255].save = FALSE;
    gnet_property->props[255].vector_size = 1;
	mutex_init(&gnet_property->props[255].lock);

    /* Type specific data: */
    gnet_property->props[255].type               = PROP_TYPE_GUINT32;
    gnet_property->props[255].data.guint32.def   = (void *) &gnet_property_variable_qrp_patch_raw_length_default;
    gnet_property->props[255].data.guint32.value = (void *) &gnet_property_variable_qrp_patch_raw_length;
    gnet_property->props[255].data.guint32.choices = NULL;
    gnet_property->props[255].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[255].data.guint32.min   = 0x00000000;


    /*
     * PROP_QRP_PATCH_LENGTH:
     *
     * General data:
     */
    gnet_property->props[256].name = "qrp_patch_length";
    gnet_property->props[256].desc = _("Final QRP table patch length, after possible compression.");
    gnet_property->props[256].ev_changed = event_new("qrp_patch_length_changed");
    gnet_property->props[256].save = FALSE;
    gnet_property->props[256].vector_size = 1;
	mutex_init(&gnet_property->props[256].lock);

    /* Type specific data: */
    gnet_property->props[256].type               = PROP_TYPE_GUINT32;
    gnet_property->props[256].data.guint32.def   = (void *) &gnet_property_variable_qrp_patch_length_default;
    gnet_property->props[256].data.guint32.value = (void *) &gnet_property_variable_qrp_patch_length;
    gnet_property->props[256].data.guint32.choices = NULL;
    gnet_property->props[256].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[256].data.guint32.min   = 0x00000000;


    /*
     * PROP_QRP_PATCH_COMP_RATIO:
     *
     * General data:
     */
    gnet_property->props[257].name = "qrp_patch_comp_ratio";
    gnet_property->props[257].desc = _("QRP table patch compression ratio, in percent, 0 means none.");
    gnet_property->props[257].ev_changed = event_new("qrp_patch_comp_ratio_changed");
    gnet_property->props[257].save = FALSE;
    gnet_property->props[257].vector_size = 1;
	mutex_init(&gnet_property->props[257].lock);

    /* Type specific data: */
    gnet_property->props[257].type               = PROP_TYPE_GUINT32;
    gnet_property->props[257].data.guint32.def   = (void *) &gnet_property_variable_qrp_patch_comp_ratio_default;
    gnet_property->props[257].data.guint32.value = (void *) &gnet_property_variable_qrp_patch_comp_ratio;
    gnet_property->props[257].data.guint32.choices = NULL;
    gnet_property->props[257].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[257].data.guint32.min   = 0x00000000;


    /*
     * PROP_ANCIENT_VERSION_LEFT_DAYS:
     *
     * General data:
     */
    gnet_property->props[258].name = "ancient_version_left_days";
    gnet_property->props[258].desc = _("Indicates that gtk-gnutella will expire in that many days.");
    gnet_property->props[258].ev_changed = event_new("ancient_version_left_days_changed");
    gnet_property->props[258].save = FALSE;
    gnet_property->props[258].vector_size = 1;
	mutex_init(&gnet_property->props[258].lock);

    /* Type specific data: */
    gnet_property->props[258].type               = PROP_TYPE_GUINT32;
    gnet_property->props[258].data.guint32.def   = (void *) &gnet_property_variable_ancient_version_left_days_default;
    gnet_property->props[258].data.guint32.value = (void *) &gnet_property_variable_ancient_version_left_days;
    gnet_property->props[258].data.guint32.choices = NULL;
    gnet_property->props[258].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[258].data.guint32.min   = 0x00000000;


    /*
     * PROP_FILE_DESCRIPTOR_SHORTAGE:
     *
     * General data:
     */
    gnet_property->props[259].name = "file_descriptor_shortage";
    gnet_property->props[259].desc = _("When set, gtk-gnutella is running short on file descriptors, but normal operations are still possible. The condition automatically clears itself after 10 minutes without any more shortage.");
    gnet_property->props[259].ev_changed = event_new("file_descriptor_shortage_changed");
    gnet_property->props[259].save = FALSE;
    gnet_property->props[259].vector_size = 1;
	mutex_init(&gnet_property->props[259].lock);

    /* Type specific data: */
    gnet_property->props[259].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[259].data.boolean.def   = (void *) &gnet_property_variable_file_descriptor_shortage_default;
    gnet_property->props[259].data.boolean.value = (void *) &gnet_property_variable_file_descriptor_shortage;


    /*
     * PROP_FILE_DESCRIPTOR_RUNOUT:
     *
     * General data:
     */
    gnet_property->props[260].name = "file_descriptor_runout";
    gnet_property->props[260].desc = _("When set, gtk-gnutella has run out of file descriptors, and operations are necessarily degraded, if not impossible. The condition automatically clears itself after 10 minutes past the last occurrence.");
    gnet_property->props[260].ev_changed = event_new("file_descriptor_runout_changed");
    gnet_property->props[260].save = FALSE;
    gnet_property->props[260].vector_size = 1;
	mutex_init(&gnet_property->props[260].lock);

    /* Type specific data: */
    gnet_property->props[260].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[260].data.boolean.def   = (void *) &gnet_property_variable_file_descriptor_runout_default;
    gnet_property->props[260].data.boolean.value = (void *) &gnet_property_variable_file_descriptor_runout;


    /*
     * PROP_CONVERT_SPACES:
     *
     * General data:
     */
    gnet_property->props[261].name = "convert_spaces";
    gnet_property->props[261].desc = _("If set, spaces in filenames are replaced with underscores.");
    gnet_property->props[261].ev_changed = event_new("convert_spaces_changed");
    gnet_property->props[261].save = TRUE;
    gnet_property->props[261].vector_size = 1;
	mutex_init(&gnet_property->props[261].lock);

    /* Type specific data: */
    gnet_property->props[261].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[261].data.boolean.def   = (void *) &gnet_property_variable_convert_spaces_default;
    gnet_property->props[261].data.boolean.value = (void *) &gnet_property_variable_convert_spaces;


    /*
     * PROP_CONVERT_EVIL_CHARS:
     *
     * General data:
     */
    gnet_property->props[262].name = "convert_evil_chars";
    gnet_property->props[262].desc = _("If set, meta shell characters in filenames are replaced with underscores. (This must also be enabled for FAT partitions.)");
    gnet_property->props[262].ev_changed = event_new("convert_evil_chars_changed");
    gnet_property->props[262].save = TRUE;
    gnet_property->props[262].vector_size = 1;
	mutex_init(&gnet_property->props[262].lock);

    /* Type specific data: */
    gnet_property->props[262].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[262].data.boolean.def   = (void *) &gnet_property_variable_convert_evil_chars_default;
    gnet_property->props[262].data.boolean.value = (void *) &gnet_property_variable_convert_evil_chars;


    /*
     * PROP_CONVERT_OLD_FILENAMES:
     *
     * General data:
     */
    gnet_property->props[263].name = "convert_old_filenames";
    gnet_property->props[263].desc = _("If set, gtk-gnutella will, upon startup, sanitize filenames by converting spaces and/or evil characters in them, according to your settings, on existing filenames in your temporary downloading directory. By default, the above settings apply only on newly created entries, not existing ones.");
    gnet_property->props[263].ev_changed = event_new("convert_old_filenames_changed");
    gnet_property->props[263].save = TRUE;
    gnet_property->props[263].vector_size = 1;
	mutex_init(&gnet_property->props[263].lock);

    /* Type specific data: */
    gnet_property->props[263].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[263].data.boolean.def   = (void *) &gnet_property_variable_convert_old_filenames_default;
    gnet_property->props[263].data.boolean.value = (void *) &gnet_property_variable_convert_old_filenames;


    /*
     * PROP_TLS_ENFORCE:
     *
     * General data:
     */
    gnet_property->props[264].name = "tls_enforce";
    gnet_property->props[264].desc = _("If set, all outgoing connections are tunneled over TLS.");
    gnet_property->props[264].ev_changed = event_new("tls_enforce_changed");
    gnet_property->props[264].save = TRUE;
    gnet_property->props[264].vector_size = 1;
	mutex_init(&gnet_property->props[264].lock);

    /* Type specific data: */
    gnet_property->props[264].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[264].data.boolean.def   = (void *) &gnet_property_variable_tls_enforce_default;
    gnet_property->props[264].data.boolean.value = (void *) &gnet_property_variable_tls_enforce;


    /*
     * PROP_GNET_DEFLATE_ENABLED:
     *
     * General data:
     */
    gnet_property->props[265].name = "gnet_deflate_enabled";
    gnet_property->props[265].desc = _("If not set, support for Gnutella connection compression is disabled.");
    gnet_property->props[265].ev_changed = event_new("gnet_deflate_enabled_changed");
    gnet_property->props[265].save = TRUE;
    gnet_property->props[265].vector_size = 1;
	mutex_init(&gnet_property->props[265].lock);

    /* Type specific data: */
    gnet_property->props[265].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[265].data.boolean.def   = (void *) &gnet_property_variable_gnet_deflate_enabled_default;
    gnet_property->props[265].data.boolean.value = (void *) &gnet_property_variable_gnet_deflate_enabled;


    /*
     * PROP_ENABLE_UDP:
     *
     * General data:
     */
    gnet_property->props[266].name = "enable_udp";
    gnet_property->props[266].desc = _("Whether UDP shall be used in complement to TCP.  When set, gtk-gnutella will also listen for UDP traffic on the same port as the one configured for TCP and process incoming Gnutella traffic in almost the same way as if it was received via TCP.  It is safe to leave this set, which is the default behavior.");
    gnet_property->props[266].ev_changed = event_new("enable_udp_changed");
    gnet_property->props[266].save = TRUE;
    gnet_property->props[266].vector_size = 1;
	mutex_init(&gnet_property->props[266].lock);

    /* Type specific data: */
    gnet_property->props[266].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[266].data.boolean.def   = (void *) &gnet_property_variable_enable_udp_default;
    gnet_property->props[266].data.boolean.value = (void *) &gnet_property_variable_enable_udp;


    /*
     * PROP_PROCESS_OOB_QUERIES:
     *
     * General data:
     */
    gnet_property->props[267].name = "process_oob_queries";
    gnet_property->props[267].desc = _("Whether gtk-gnutella should honor the request for out-of-band delivery of query hits via UDP, provided UDP support is enabled.  It should not be necessary to add a port forwarding to enable this as your node will be the origin of the UDP traffic and can therefore receive replies sent to the transient UDP port opened by a masquerading firewall.  It is enabled by default because it is deemed safe, as your node controls the bulk of the emitted traffic and honors the bandwidth limitations.");
    gnet_property->props[267].ev_changed = event_new("process_oob_queries_changed");
    gnet_property->props[267].save = TRUE;
    gnet_property->props[267].vector_size = 1;
	mutex_init(&gnet_property->props[267].lock);

    /* Type specific data: */
    gnet_property->props[267].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[267].data.boolean.def   = (void *) &gnet_property_variable_process_oob_queries_default;
    gnet_property->props[267].data.boolean.value = (void *) &gnet_property_variable_process_oob_queries;


    /*
     * PROP_SEND_OOB_QUERIES:
     *
     * General data:
     */
    gnet_property->props[268].name = "send_oob_queries";
    gnet_property->props[268].desc = _("Whether gtk-gnutella should send queries requesting out-of-band delivery of query hits via UDP.  The setting is ignored if you seem to be UDP-firewalled, i.e. cannot receive unsolicited UDP traffic.  You need to enable UDP support first.  This can cause the reception of vast quantities of UDP replies, so you may choose to disable this feature.  If disabled, your hits will travel through the Gnutella network and can be dropped by any flow-controlled relaying node, limiting the results you can get.");
    gnet_property->props[268].ev_changed = event_new("send_oob_queries_changed");
    gnet_property->props[268].save = TRUE;
    gnet_property->props[268].vector_size = 1;
	mutex_init(&gnet_property->props[268].lock);

    /* Type specific data: */
    gnet_property->props[268].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[268].data.boolean.def   = (void *) &gnet_property_variable_send_oob_queries_default;
    gnet_property->props[268].data.boolean.value = (void *) &gnet_property_variable_send_oob_queries;


    /*
     * PROP_PROXY_OOB_QUERIES:
     *
     * General data:
     */
    gnet_property->props[269].name = "proxy_oob_queries";
    gnet_property->props[269].desc = _("Whether gtk-gnutella should, when running as ultrapeer, act as proxy for leaf queries that are not requesting OOB delivery of query hits: gtk-gnutella will claim the hits from the remote nodes and forward the hits to the proper leaf.  This is very beneficial for the leaves, but can cause huge bursts of UDP traffic coming back to you.  If you disable it all ultrapeers connected to you will have to relay the hits, possibly dropping other query messages and lowering the efficiency of the search network.");
    gnet_property->props[269].ev_changed = event_new("proxy_oob_queries_changed");
    gnet_property->props[269].save = TRUE;
    gnet_property->props[269].vector_size = 1;
	mutex_init(&gnet_property->props[269].lock);

    /* Type specific data: */
    gnet_property->props[269].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[269].data.boolean.def   = (void *) &gnet_property_variable_proxy_oob_queries_default;
    gnet_property->props[269].data.boolean.value = (void *) &gnet_property_variable_proxy_oob_queries;


    /*
     * PROP_UPLOADS_STALLING:
     *
     * General data:
     */
    gnet_property->props[270].name = "uploads_stalling";
    gnet_property->props[270].desc = _("Whether uploads are frequently stalling, indicating that the bandwidth is saturated.  Avoid running as an ultra-node under those conditions.");
    gnet_property->props[270].ev_changed = event_new("uploads_stalling_changed");
    gnet_property->props[270].save = FALSE;
    gnet_property->props[270].vector_size = 1;
	mutex_init(&gnet_property->props[270].lock);

    /* Type specific data: */
    gnet_property->props[270].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[270].data.boolean.def   = (void *) &gnet_property_variable_uploads_stalling_default;
    gnet_property->props[270].data.boolean.value = (void *) &gnet_property_variable_uploads_stalling;


    /*
     * PROP_USE_GLOBAL_HOSTILES_TXT:
     *
     * General data:
     */
    gnet_property->props[271].name = "use_global_hostiles_txt";
    gnet_property->props[271].desc = _("If set to TRUE, the global hostiles.txt is used as well as the private $GTK_GNUTELLA_DIR/hostiles.txt. This allows you to separate your private ban list from the global one distributed with gtk-gnutella.");
    gnet_property->props[271].ev_changed = event_new("use_global_hostiles_txt_changed");
    gnet_property->props[271].save = TRUE;
    gnet_property->props[271].vector_size = 1;
	mutex_init(&gnet_property->props[271].lock);

    /* Type specific data: */
    gnet_property->props[271].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[271].data.boolean.def   = (void *) &gnet_property_variable_use_global_hostiles_txt_default;
    gnet_property->props[271].data.boolean.value = (void *) &gnet_property_variable_use_global_hostiles_txt;


    /*
     * PROP_USE_SO_LINGER:
     *
     * General data:
     */
    gnet_property->props[272].name = "use_so_linger";
    gnet_property->props[272].desc = _("If set to TRUE, SO_LINGER is used for sockets.");
    gnet_property->props[272].ev_changed = event_new("use_so_linger_changed");
    gnet_property->props[272].save = TRUE;
    gnet_property->props[272].vector_size = 1;
	mutex_init(&gnet_property->props[272].lock);

    /* Type specific data: */
    gnet_property->props[272].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[272].data.boolean.def   = (void *) &gnet_property_variable_use_so_linger_default;
    gnet_property->props[272].data.boolean.value = (void *) &gnet_property_variable_use_so_linger;


    /*
     * PROP_TCP_DEFER_ACCEPT_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[273].name = "tcp_defer_accept_timeout";
    gnet_property->props[273].desc = _("See the man page for tcp(7). This feature typically only available on Linux systems.");
    gnet_property->props[273].ev_changed = event_new("tcp_defer_accept_timeout_changed");
    gnet_property->props[273].save = TRUE;
    gnet_property->props[273].vector_size = 1;
	mutex_init(&gnet_property->props[273].lock);

    /* Type specific data: */
    gnet_property->props[273].type               = PROP_TYPE_GUINT32;
    gnet_property->props[273].data.guint32.def   = (void *) &gnet_property_variable_tcp_defer_accept_timeout_default;
    gnet_property->props[273].data.guint32.value = (void *) &gnet_property_variable_tcp_defer_accept_timeout;
    gnet_property->props[273].data.guint32.choices = NULL;
    gnet_property->props[273].data.guint32.max   = 600;
    gnet_property->props[273].data.guint32.min   = 0;


    /*
     * PROP_BROWSE_HOST_ENABLED:
     *
     * General data:
     */
    gnet_property->props[274].name = "browse_host_enabled";
    gnet_property->props[274].desc = _("If TRUE, other hosts can request a complete list of all shared files.");
    gnet_property->props[274].ev_changed = event_new("browse_host_enabled_changed");
    gnet_property->props[274].save = TRUE;
    gnet_property->props[274].vector_size = 1;
	mutex_init(&gnet_property->props[274].lock);

    /* Type specific data: */
    gnet_property->props[274].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[274].data.boolean.def   = (void *) &gnet_property_variable_browse_host_enabled_default;
    gnet_property->props[274].data.boolean.value = (void *) &gnet_property_variable_browse_host_enabled;


    /*
     * PROP_HTML_BROWSE_COUNT:
     *
     * General data:
     */
    gnet_property->props[275].name = "html_browse_count";
    gnet_property->props[275].desc = _("Number of HTML browsing requests received in this session.");
    gnet_property->props[275].ev_changed = event_new("html_browse_count_changed");
    gnet_property->props[275].save = FALSE;
    gnet_property->props[275].vector_size = 1;
	mutex_init(&gnet_property->props[275].lock);

    /* Type specific data: */
    gnet_property->props[275].type               = PROP_TYPE_GUINT32;
    gnet_property->props[275].data.guint32.def   = (void *) &gnet_property_variable_html_browse_count_default;
    gnet_property->props[275].data.guint32.value = (void *) &gnet_property_variable_html_browse_count;
    gnet_property->props[275].data.guint32.choices = NULL;
    gnet_property->props[275].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[275].data.guint32.min   = 0x00000000;


    /*
     * PROP_HTML_BROWSE_SERVED:
     *
     * General data:
     */
    gnet_property->props[276].name = "html_browse_served";
    gnet_property->props[276].desc = _("Number of HTML browsing requests fully served in this session.");
    gnet_property->props[276].ev_changed = event_new("html_browse_served_changed");
    gnet_property->props[276].save = FALSE;
    gnet_property->props[276].vector_size = 1;
	mutex_init(&gnet_property->props[276].lock);

    /* Type specific data: */
    gnet_property->props[276].type               = PROP_TYPE_GUINT32;
    gnet_property->props[276].data.guint32.def   = (void *) &gnet_property_variable_html_browse_served_default;
    gnet_property->props[276].data.guint32.value = (void *) &gnet_property_variable_html_browse_served;
    gnet_property->props[276].data.guint32.choices = NULL;
    gnet_property->props[276].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[276].data.guint32.min   = 0x00000000;


    /*
     * PROP_QHITS_BROWSE_COUNT:
     *
     * General data:
     */
    gnet_property->props[277].name = "qhits_browse_count";
    gnet_property->props[277].desc = _("Number of Gnutella browsing requests received in this session.");
    gnet_property->props[277].ev_changed = event_new("qhits_browse_count_changed");
    gnet_property->props[277].save = FALSE;
    gnet_property->props[277].vector_size = 1;
	mutex_init(&gnet_property->props[277].lock);

    /* Type specific data: */
    gnet_property->props[277].type               = PROP_TYPE_GUINT32;
    gnet_property->props[277].data.guint32.def   = (void *) &gnet_property_variable_qhits_browse_count_default;
    gnet_property->props[277].data.guint32.value = (void *) &gnet_property_variable_qhits_browse_count;
    gnet_property->props[277].data.guint32.choices = NULL;
    gnet_property->props[277].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[277].data.guint32.min   = 0x00000000;


    /*
     * PROP_QHITS_BROWSE_SERVED:
     *
     * General data:
     */
    gnet_property->props[278].name = "qhits_browse_served";
    gnet_property->props[278].desc = _("Number of Gnutella browsing requests fully served in this session.");
    gnet_property->props[278].ev_changed = event_new("qhits_browse_served_changed");
    gnet_property->props[278].save = FALSE;
    gnet_property->props[278].vector_size = 1;
	mutex_init(&gnet_property->props[278].lock);

    /* Type specific data: */
    gnet_property->props[278].type               = PROP_TYPE_GUINT32;
    gnet_property->props[278].data.guint32.def   = (void *) &gnet_property_variable_qhits_browse_served_default;
    gnet_property->props[278].data.guint32.value = (void *) &gnet_property_variable_qhits_browse_served;
    gnet_property->props[278].data.guint32.choices = NULL;
    gnet_property->props[278].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[278].data.guint32.min   = 0x00000000;


    /*
     * PROP_OVERLOADED_CPU:
     *
     * General data:
     */
    gnet_property->props[279].name = "overloaded_cpu";
    gnet_property->props[279].desc = _("The average CPU usage indicates overloading, so gtk-gnutella is reducing the amount of non-critical processing it is performing. Note that the overloading can result from gtk-gnutella not getting enough CPU time because another process is competing for the CPU. Whilst the overloading condition persists, GUI refreshing is reduced and background tasks (SHA1 computation, file moving) are slowed down.");
    gnet_property->props[279].ev_changed = event_new("overloaded_cpu_changed");
    gnet_property->props[279].save = FALSE;
    gnet_property->props[279].vector_size = 1;
	mutex_init(&gnet_property->props[279].lock);

    /* Type specific data: */
    gnet_property->props[279].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[279].data.boolean.def   = (void *) &gnet_property_variable_overloaded_cpu_default;
    gnet_property->props[279].data.boolean.value = (void *) &gnet_property_variable_overloaded_cpu;


    /*
     * PROP_DOWNLOAD_BUFFER_SIZE:
     *
     * General data:
     */
    gnet_property->props[280].name = "download_buffer_size";
    gnet_property->props[280].desc = _("Amount of data per downloading source that gtk-gnutella will buffer before writing to disk.  When swarming from many sources, a larger value will help avoid using too many system calls and should also reduce the fragmentation on the filesystem.  The downside is that it uses more memory per active source.  Use 0 to disable all buffering, i.e. have gtk-gnutella write to disk as soon as it receives some data. Increase to maximum value if you have RAM.");
    gnet_property->props[280].ev_changed = event_new("download_buffer_size_changed");
    gnet_property->props[280].save = TRUE;
    gnet_property->props[280].vector_size = 1;
	mutex_init(&gnet_property->props[280].lock);

    /* Type specific data: */
    gnet_property->props[280].type               = PROP_TYPE_GUINT32;
    gnet_property->props[280].data.guint32.def   = (void *) &gnet_property_variable_download_buffer_size_default;
    gnet_property->props[280].data.guint32.value = (void *) &gnet_property_variable_download_buffer_size;
    gnet_property->props[280].data.guint32.choices = NULL;
    gnet_property->props[280].data.guint32.max   = 1048576;
    gnet_property->props[280].data.guint32.min   = 0;


    /*
     * PROP_BROWSE_COPIED_TO_PASSIVE:
     *
     * General data:
     */
    gnet_property->props[281].name = "browse_copied_to_passive";
    gnet_property->props[281].desc = _("When set, all search results from host browsing are dispatched to all opened passive searches.  This is useful if you have different selection filters on your passive searches because it lets you classify files easily, regardless of the origin of the files.");
    gnet_property->props[281].ev_changed = event_new("browse_copied_to_passive_changed");
    gnet_property->props[281].save = TRUE;
    gnet_property->props[281].vector_size = 1;
	mutex_init(&gnet_property->props[281].lock);

    /* Type specific data: */
    gnet_property->props[281].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[281].data.boolean.def   = (void *) &gnet_property_variable_browse_copied_to_passive_default;
    gnet_property->props[281].data.boolean.value = (void *) &gnet_property_variable_browse_copied_to_passive;


    /*
     * PROP_DISPLAY_METRIC_UNITS:
     *
     * General data:
     */
    gnet_property->props[282].name = "display_metric_units";
    gnet_property->props[282].desc = _("Enable this if all units should be displayed using the metric system with SI prefixes. If disabled, certain units, for example, filesizes will be displayed using the historical base2 convention with binary prefixes.");
    gnet_property->props[282].ev_changed = event_new("display_metric_units_changed");
    gnet_property->props[282].save = TRUE;
    gnet_property->props[282].vector_size = 1;
	mutex_init(&gnet_property->props[282].lock);

    /* Type specific data: */
    gnet_property->props[282].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[282].data.boolean.def   = (void *) &gnet_property_variable_display_metric_units_default;
    gnet_property->props[282].data.boolean.value = (void *) &gnet_property_variable_display_metric_units;


    /*
     * PROP_RUDP_DEBUG:
     *
     * General data:
     */
    gnet_property->props[283].name = "rudp_debug";
    gnet_property->props[283].desc = _("Debug level for Reliable UDP (RUDP) code.");
    gnet_property->props[283].ev_changed = event_new("rudp_debug_changed");
    gnet_property->props[283].save = TRUE;
    gnet_property->props[283].vector_size = 1;
	mutex_init(&gnet_property->props[283].lock);

    /* Type specific data: */
    gnet_property->props[283].type               = PROP_TYPE_GUINT32;
    gnet_property->props[283].data.guint32.def   = (void *) &gnet_property_variable_rudp_debug_default;
    gnet_property->props[283].data.guint32.value = (void *) &gnet_property_variable_rudp_debug;
    gnet_property->props[283].data.guint32.choices = NULL;
    gnet_property->props[283].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[283].data.guint32.min   = 0x00000000;


    /*
     * PROP_DHT_DEBUG:
     *
     * General data:
     */
    gnet_property->props[284].name = "dht_debug";
    gnet_property->props[284].desc = _("Debug level for the Distributed Hash Table (DHT) code.");
    gnet_property->props[284].ev_changed = event_new("dht_debug_changed");
    gnet_property->props[284].save = TRUE;
    gnet_property->props[284].vector_size = 1;
	mutex_init(&gnet_property->props[284].lock);

    /* Type specific data: */
    gnet_property->props[284].type               = PROP_TYPE_GUINT32;
    gnet_property->props[284].data.guint32.def   = (void *) &gnet_property_variable_dht_debug_default;
    gnet_property->props[284].data.guint32.value = (void *) &gnet_property_variable_dht_debug;
    gnet_property->props[284].data.guint32.choices = NULL;
    gnet_property->props[284].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[284].data.guint32.min   = 0x00000000;


    /*
     * PROP_OOB_PROXY_DEBUG:
     *
     * General data:
     */
    gnet_property->props[285].name = "oob_proxy_debug";
    gnet_property->props[285].desc = _("Debug level for the OOB-proxying of queries.");
    gnet_property->props[285].ev_changed = event_new("oob_proxy_debug_changed");
    gnet_property->props[285].save = TRUE;
    gnet_property->props[285].vector_size = 1;
	mutex_init(&gnet_property->props[285].lock);

    /* Type specific data: */
    gnet_property->props[285].type               = PROP_TYPE_GUINT32;
    gnet_property->props[285].data.guint32.def   = (void *) &gnet_property_variable_oob_proxy_debug_default;
    gnet_property->props[285].data.guint32.value = (void *) &gnet_property_variable_oob_proxy_debug;
    gnet_property->props[285].data.guint32.choices = NULL;
    gnet_property->props[285].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[285].data.guint32.min   = 0x00000000;


    /*
     * PROP_ENABLE_LOCAL_SOCKET:
     *
     * General data:
     */
    gnet_property->props[286].name = "enable_local_socket";
    gnet_property->props[286].desc = _("If set gtk-gnutella also listens on a local (unix domain) socket which is located in ~/.gtk-gnutella/socket.");
    gnet_property->props[286].ev_changed = event_new("enable_local_socket_changed");
    gnet_property->props[286].save = TRUE;
    gnet_property->props[286].vector_size = 1;
	mutex_init(&gnet_property->props[286].lock);

    /* Type specific data: */
    gnet_property->props[286].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[286].data.boolean.def   = (void *) &gnet_property_variable_enable_local_socket_default;
    gnet_property->props[286].data.boolean.value = (void *) &gnet_property_variable_enable_local_socket;


    /*
     * PROP_MAX_SIMULTANEOUS_DOWNLOADS_PER_FILE:
     *
     * General data:
     */
    gnet_property->props[287].name = "max_simultaneous_downloads_per_file";
    gnet_property->props[287].desc = _("Don't start more than this number of parallel downloads per file.");
    gnet_property->props[287].ev_changed = event_new("max_simultaneous_downloads_per_file_changed");
    gnet_property->props[287].save = TRUE;
    gnet_property->props[287].vector_size = 1;
	mutex_init(&gnet_property->props[287].lock);

    /* Type specific data: */
    gnet_property->props[287].type               = PROP_TYPE_GUINT32;
    gnet_property->props[287].data.guint32.def   = (void *) &gnet_property_variable_max_simultaneous_downloads_per_file_default;
    gnet_property->props[287].data.guint32.value = (void *) &gnet_property_variable_max_simultaneous_downloads_per_file;
    gnet_property->props[287].data.guint32.choices = NULL;
    gnet_property->props[287].data.guint32.max   = INT_MAX;
    gnet_property->props[287].data.guint32.min   = 1;


    /*
     * PROP_DUMP_RECEIVED_GNUTELLA_PACKETS:
     *
     * General data:
     */
    gnet_property->props[288].name = "dump_received_gnutella_packets";
    gnet_property->props[288].desc = _("If enabled, all received packets are dumped to $GTK_GNUTELLA_DIR/packets_rx.dump.");
    gnet_property->props[288].ev_changed = event_new("dump_received_gnutella_packets_changed");
    gnet_property->props[288].save = FALSE;
    gnet_property->props[288].vector_size = 1;
	mutex_init(&gnet_property->props[288].lock);

    /* Type specific data: */
    gnet_property->props[288].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[288].data.boolean.def   = (void *) &gnet_property_variable_dump_received_gnutella_packets_default;
    gnet_property->props[288].data.boolean.value = (void *) &gnet_property_variable_dump_received_gnutella_packets;


    /*
     * PROP_SEARCH_RESULTS_EXPOSE_RELATIVE_PATHS:
     *
     * General data:
     */
    gnet_property->props[289].name = "search_results_expose_relative_paths";
    gnet_property->props[289].desc = _("If enabled, queries are also matched against the directory names which are relative to the shared ones. Further, search results will show these. This is especially useful if the shared filenames are ambiguous or meaningless without knowing the directory names as well. However, be sure the directory names do not expose confidential information. You have to initiate a rescan of the shared files before a change becomes fully effective.");
    gnet_property->props[289].ev_changed = event_new("search_results_expose_relative_paths_changed");
    gnet_property->props[289].save = TRUE;
    gnet_property->props[289].vector_size = 1;
	mutex_init(&gnet_property->props[289].lock);

    /* Type specific data: */
    gnet_property->props[289].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[289].data.boolean.def   = (void *) &gnet_property_variable_search_results_expose_relative_paths_default;
    gnet_property->props[289].data.boolean.value = (void *) &gnet_property_variable_search_results_expose_relative_paths;


    /*
     * PROP_SHELL_DEBUG:
     *
     * General data:
     */
    gnet_property->props[290].name = "shell_debug";
    gnet_property->props[290].desc = _("Debug level for the shell.");
    gnet_property->props[290].ev_changed = event_new("shell_debug_changed");
    gnet_property->props[290].save = TRUE;
    gnet_property->props[290].vector_size = 1;
	mutex_init(&gnet_property->props[290].lock);

    /* Type specific data: */
    gnet_property->props[290].type               = PROP_TYPE_GUINT32;
    gnet_property->props[290].data.guint32.def   = (void *) &gnet_property_variable_shell_debug_default;
    gnet_property->props[290].data.guint32.value = (void *) &gnet_property_variable_shell_debug;
    gnet_property->props[290].data.guint32.choices = NULL;
    gnet_property->props[290].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[290].data.guint32.min   = 0x00000000;


    /*
     * PROP_DOWNLOAD_QUEUE_FROZEN:
     *
     * General data:
     */
    gnet_property->props[291].name = "download_queue_frozen";
    gnet_property->props[291].desc = _("If larger than zero, no downloads are started.");
    gnet_property->props[291].ev_changed = event_new("download_queue_frozen_changed");
    gnet_property->props[291].save = FALSE;
    gnet_property->props[291].vector_size = 1;
	mutex_init(&gnet_property->props[291].lock);

    /* Type specific data: */
    gnet_property->props[291].type               = PROP_TYPE_GUINT32;
    gnet_property->props[291].data.guint32.def   = (void *) &gnet_property_variable_download_queue_frozen_default;
    gnet_property->props[291].data.guint32.value = (void *) &gnet_property_variable_download_queue_frozen;
    gnet_property->props[291].data.guint32.choices = NULL;
    gnet_property->props[291].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[291].data.guint32.min   = 0x00000000;


    /*
     * PROP_SQ_DEBUG:
     *
     * General data:
     */
    gnet_property->props[292].name = "sq_debug";
    gnet_property->props[292].desc = _("Debug level for the search queue.");
    gnet_property->props[292].ev_changed = event_new("sq_debug_changed");
    gnet_property->props[292].save = TRUE;
    gnet_property->props[292].vector_size = 1;
	mutex_init(&gnet_property->props[292].lock);

    /* Type specific data: */
    gnet_property->props[292].type               = PROP_TYPE_GUINT32;
    gnet_property->props[292].data.guint32.def   = (void *) &gnet_property_variable_sq_debug_default;
    gnet_property->props[292].data.guint32.value = (void *) &gnet_property_variable_sq_debug;
    gnet_property->props[292].data.guint32.choices = NULL;
    gnet_property->props[292].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[292].data.guint32.min   = 0x00000000;


    /*
     * PROP_PUSH_PROXY_DEBUG:
     *
     * General data:
     */
    gnet_property->props[293].name = "push_proxy_debug";
    gnet_property->props[293].desc = _("Debug level for push-proxy code.");
    gnet_property->props[293].ev_changed = event_new("push_proxy_debug_changed");
    gnet_property->props[293].save = TRUE;
    gnet_property->props[293].vector_size = 1;
	mutex_init(&gnet_property->props[293].lock);

    /* Type specific data: */
    gnet_property->props[293].type               = PROP_TYPE_GUINT32;
    gnet_property->props[293].data.guint32.def   = (void *) &gnet_property_variable_push_proxy_debug_default;
    gnet_property->props[293].data.guint32.value = (void *) &gnet_property_variable_push_proxy_debug;
    gnet_property->props[293].data.guint32.choices = NULL;
    gnet_property->props[293].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[293].data.guint32.min   = 0x00000000;


    /*
     * PROP_THEX_FILES_REQUESTED:
     *
     * General data:
     */
    gnet_property->props[294].name = "thex_files_requested";
    gnet_property->props[294].desc = _("Number of THEX file requests received in this session.");
    gnet_property->props[294].ev_changed = event_new("thex_files_requested_changed");
    gnet_property->props[294].save = FALSE;
    gnet_property->props[294].vector_size = 1;
	mutex_init(&gnet_property->props[294].lock);

    /* Type specific data: */
    gnet_property->props[294].type               = PROP_TYPE_GUINT32;
    gnet_property->props[294].data.guint32.def   = (void *) &gnet_property_variable_thex_files_requested_default;
    gnet_property->props[294].data.guint32.value = (void *) &gnet_property_variable_thex_files_requested;
    gnet_property->props[294].data.guint32.choices = NULL;
    gnet_property->props[294].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[294].data.guint32.min   = 0x00000000;


    /*
     * PROP_THEX_FILES_SERVED:
     *
     * General data:
     */
    gnet_property->props[295].name = "thex_files_served";
    gnet_property->props[295].desc = _("Number of THEX file requests fully served in this session.");
    gnet_property->props[295].ev_changed = event_new("thex_files_served_changed");
    gnet_property->props[295].save = FALSE;
    gnet_property->props[295].vector_size = 1;
	mutex_init(&gnet_property->props[295].lock);

    /* Type specific data: */
    gnet_property->props[295].type               = PROP_TYPE_GUINT32;
    gnet_property->props[295].data.guint32.def   = (void *) &gnet_property_variable_thex_files_served_default;
    gnet_property->props[295].data.guint32.value = (void *) &gnet_property_variable_thex_files_served;
    gnet_property->props[295].data.guint32.choices = NULL;
    gnet_property->props[295].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[295].data.guint32.min   = 0x00000000;


    /*
     * PROP_TIGERTREE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[296].name = "tigertree_debug";
    gnet_property->props[296].desc = _("Debug level for Tigertree-related code.");
    gnet_property->props[296].ev_changed = event_new("tigertree_debug_changed");
    gnet_property->props[296].save = TRUE;
    gnet_property->props[296].vector_size = 1;
	mutex_init(&gnet_property->props[296].lock);

    /* Type specific data: */
    gnet_property->props[296].type               = PROP_TYPE_GUINT32;
    gnet_property->props[296].data.guint32.def   = (void *) &gnet_property_variable_tigertree_debug_default;
    gnet_property->props[296].data.guint32.value = (void *) &gnet_property_variable_tigertree_debug;
    gnet_property->props[296].data.guint32.choices = NULL;
    gnet_property->props[296].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[296].data.guint32.min   = 0x00000000;


    /*
     * PROP_TTH_REBUILDING:
     *
     * General data:
     */
    gnet_property->props[297].name = "tth_rebuilding";
    gnet_property->props[297].desc = _("Whether gtk-gnutella is currently computing TTH of shared files in the background.");
    gnet_property->props[297].ev_changed = event_new("tth_rebuilding_changed");
    gnet_property->props[297].save = FALSE;
    gnet_property->props[297].vector_size = 1;
	mutex_init(&gnet_property->props[297].lock);

    /* Type specific data: */
    gnet_property->props[297].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[297].data.boolean.def   = (void *) &gnet_property_variable_tth_rebuilding_default;
    gnet_property->props[297].data.boolean.value = (void *) &gnet_property_variable_tth_rebuilding;


    /*
     * PROP_TTH_VERIFYING:
     *
     * General data:
     */
    gnet_property->props[298].name = "tth_verifying";
    gnet_property->props[298].desc = _("Whether gtk-gnutella is currently verifying the TTH of downloaded files in the background.");
    gnet_property->props[298].ev_changed = event_new("tth_verifying_changed");
    gnet_property->props[298].save = FALSE;
    gnet_property->props[298].vector_size = 1;
	mutex_init(&gnet_property->props[298].lock);

    /* Type specific data: */
    gnet_property->props[298].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[298].data.boolean.def   = (void *) &gnet_property_variable_tth_verifying_default;
    gnet_property->props[298].data.boolean.value = (void *) &gnet_property_variable_tth_verifying;


    /*
     * PROP_SEARCH_MAX_RESULTS:
     *
     * General data:
     */
    gnet_property->props[299].name = "search_max_results";
    gnet_property->props[299].desc = _("Maximum number of results to show in any search.");
    gnet_property->props[299].ev_changed = event_new("search_max_results_changed");
    gnet_property->props[299].save = TRUE;
    gnet_property->props[299].vector_size = 1;
	mutex_init(&gnet_property->props[299].lock);

    /* Type specific data: */
    gnet_property->props[299].type               = PROP_TYPE_GUINT32;
    gnet_property->props[299].data.guint32.def   = (void *) &gnet_property_variable_search_max_results_default;
    gnet_property->props[299].data.guint32.value = (void *) &gnet_property_variable_search_max_results;
    gnet_property->props[299].data.guint32.choices = NULL;
    gnet_property->props[299].data.guint32.max   = 100000;
    gnet_property->props[299].data.guint32.min   = 10;


    /*
     * PROP_BROWSE_HOST_MAX_RESULTS:
     *
     * General data:
     */
    gnet_property->props[300].name = "browse_host_max_results";
    gnet_property->props[300].desc = _("Maximum number of results to show in a browse_host request.");
    gnet_property->props[300].ev_changed = event_new("browse_host_max_results_changed");
    gnet_property->props[300].save = TRUE;
    gnet_property->props[300].vector_size = 1;
	mutex_init(&gnet_property->props[300].lock);

    /* Type specific data: */
    gnet_property->props[300].type               = PROP_TYPE_GUINT32;
    gnet_property->props[300].data.guint32.def   = (void *) &gnet_property_variable_browse_host_max_results_default;
    gnet_property->props[300].data.guint32.value = (void *) &gnet_property_variable_browse_host_max_results;
    gnet_property->props[300].data.guint32.choices = NULL;
    gnet_property->props[300].data.guint32.max   = 500000;
    gnet_property->props[300].data.guint32.min   = 100;


    /*
     * PROP_LATEST_SVN_RELEASE_DATE:
     *
     * General data:
     */
    gnet_property->props[301].name = "latest_svn_release_date";
    gnet_property->props[301].desc = _("Date of the latest SVN release.");
    gnet_property->props[301].ev_changed = event_new("latest_svn_release_date_changed");
    gnet_property->props[301].save = TRUE;
    gnet_property->props[301].vector_size = 1;
	mutex_init(&gnet_property->props[301].lock);

    /* Type specific data: */
    gnet_property->props[301].type               = PROP_TYPE_TIMESTAMP;
    gnet_property->props[301].data.timestamp.def   = (void *) &gnet_property_variable_latest_svn_release_date_default;
    gnet_property->props[301].data.timestamp.value = (void *) &gnet_property_variable_latest_svn_release_date;
    gnet_property->props[301].data.timestamp.choices = NULL;
    gnet_property->props[301].data.timestamp.max   = (time_t) ((1U << 31) - 1);
    gnet_property->props[301].data.timestamp.min   = 0x0000000000000000;


    /*
     * PROP_LATEST_SVN_RELEASE_REVISION:
     *
     * General data:
     */
    gnet_property->props[302].name = "latest_svn_release_revision";
    gnet_property->props[302].desc = _("Revision of the latest SVN release.");
    gnet_property->props[302].ev_changed = event_new("latest_svn_release_revision_changed");
    gnet_property->props[302].save = TRUE;
    gnet_property->props[302].vector_size = 1;
	mutex_init(&gnet_property->props[302].lock);

    /* Type specific data: */
    gnet_property->props[302].type               = PROP_TYPE_GUINT32;
    gnet_property->props[302].data.guint32.def   = (void *) &gnet_property_variable_latest_svn_release_revision_default;
    gnet_property->props[302].data.guint32.value = (void *) &gnet_property_variable_latest_svn_release_revision;
    gnet_property->props[302].data.guint32.choices = NULL;
    gnet_property->props[302].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[302].data.guint32.min   = 0x00000000;


    /*
     * PROP_LATEST_SVN_RELEASE_SIGNATURE:
     *
     * General data:
     */
    gnet_property->props[303].name = "latest_svn_release_signature";
    gnet_property->props[303].desc = _("Signature of the latest SVN release notification.");
    gnet_property->props[303].ev_changed = event_new("latest_svn_release_signature_changed");
    gnet_property->props[303].save = TRUE;
    gnet_property->props[303].vector_size = 1;
	mutex_init(&gnet_property->props[303].lock);

    /* Type specific data: */
    gnet_property->props[303].type               = PROP_TYPE_STRING;
    gnet_property->props[303].data.string.def    = (void *) &gnet_property_variable_latest_svn_release_signature_default;
    gnet_property->props[303].data.string.value  = (void *) &gnet_property_variable_latest_svn_release_signature;
    if (gnet_property->props[303].data.string.def) {
        *gnet_property->props[303].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[303].data.string.def));
    }


    /*
     * PROP_TLS_CACHE_MAX_HOSTS:
     *
     * General data:
     */
    gnet_property->props[304].name = "tls_cache_max_hosts";
    gnet_property->props[304].desc = _("Maximum number of hosts in the TLS node cache.");
    gnet_property->props[304].ev_changed = event_new("tls_cache_max_hosts_changed");
    gnet_property->props[304].save = TRUE;
    gnet_property->props[304].vector_size = 1;
	mutex_init(&gnet_property->props[304].lock);

    /* Type specific data: */
    gnet_property->props[304].type               = PROP_TYPE_GUINT32;
    gnet_property->props[304].data.guint32.def   = (void *) &gnet_property_variable_tls_cache_max_hosts_default;
    gnet_property->props[304].data.guint32.value = (void *) &gnet_property_variable_tls_cache_max_hosts;
    gnet_property->props[304].data.guint32.choices = NULL;
    gnet_property->props[304].data.guint32.max   = 50000;
    gnet_property->props[304].data.guint32.min   = 100;


    /*
     * PROP_TLS_CACHE_MAX_TIME:
     *
     * General data:
     */
    gnet_property->props[305].name = "tls_cache_max_time";
    gnet_property->props[305].desc = _("Maximum time before removing hosts from the TLS cache.");
    gnet_property->props[305].ev_changed = event_new("tls_cache_max_time_changed");
    gnet_property->props[305].save = TRUE;
    gnet_property->props[305].vector_size = 1;
	mutex_init(&gnet_property->props[305].lock);

    /* Type specific data: */
    gnet_property->props[305].type               = PROP_TYPE_GUINT32;
    gnet_property->props[305].data.guint32.def   = (void *) &gnet_property_variable_tls_cache_max_time_default;
    gnet_property->props[305].data.guint32.value = (void *) &gnet_property_variable_tls_cache_max_time;
    gnet_property->props[305].data.guint32.choices = NULL;
    gnet_property->props[305].data.guint32.max   = 691200;
    gnet_property->props[305].data.guint32.min   = 14400;


    /*
     * PROP_TTH_AUTO_DISCOVERY:
     *
     * General data:
     */
    gnet_property->props[306].name = "tth_auto_discovery";
    gnet_property->props[306].desc = _("If set to TRUE the tigertree root hash (TTH) can be discovered on the fly. Otherwise, the TTH is only accepted if provided by the user, for example, by a magnet link.");
    gnet_property->props[306].ev_changed = event_new("tth_auto_discovery_changed");
    gnet_property->props[306].save = TRUE;
    gnet_property->props[306].vector_size = 1;
	mutex_init(&gnet_property->props[306].lock);

    /* Type specific data: */
    gnet_property->props[306].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[306].data.boolean.def   = (void *) &gnet_property_variable_tth_auto_discovery_default;
    gnet_property->props[306].data.boolean.value = (void *) &gnet_property_variable_tth_auto_discovery;


    /*
     * PROP_ENABLE_HACKAROUNDS:
     *
     * General data:
     */
    gnet_property->props[307].name = "enable_hackarounds";
    gnet_property->props[307].desc = _("If set to TRUE, gtk-gnutella will turn on some hacks which, unfortunately, have to exist at all.  The aim is to improve the overall downloading experience.");
    gnet_property->props[307].ev_changed = event_new("enable_hackarounds_changed");
    gnet_property->props[307].save = TRUE;
    gnet_property->props[307].vector_size = 1;
	mutex_init(&gnet_property->props[307].lock);

    /* Type specific data: */
    gnet_property->props[307].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[307].data.boolean.def   = (void *) &gnet_property_variable_enable_hackarounds_default;
    gnet_property->props[307].data.boolean.value = (void *) &gnet_property_variable_enable_hackarounds;


    /*
     * PROP_G2_CACHE_MAX_HOSTS:
     *
     * General data:
     */
    gnet_property->props[308].name = "g2_cache_max_hosts";
    gnet_property->props[308].desc = _("Maximum number of hosts in the G2 node cache.");
    gnet_property->props[308].ev_changed = event_new("g2_cache_max_hosts_changed");
    gnet_property->props[308].save = TRUE;
    gnet_property->props[308].vector_size = 1;
	mutex_init(&gnet_property->props[308].lock);

    /* Type specific data: */
    gnet_property->props[308].type               = PROP_TYPE_GUINT32;
    gnet_property->props[308].data.guint32.def   = (void *) &gnet_property_variable_g2_cache_max_hosts_default;
    gnet_property->props[308].data.guint32.value = (void *) &gnet_property_variable_g2_cache_max_hosts;
    gnet_property->props[308].data.guint32.choices = NULL;
    gnet_property->props[308].data.guint32.max   = 50000;
    gnet_property->props[308].data.guint32.min   = 100;


    /*
     * PROP_G2_CACHE_MAX_TIME:
     *
     * General data:
     */
    gnet_property->props[309].name = "g2_cache_max_time";
    gnet_property->props[309].desc = _("Maximum time before removing hosts from the G2 cache.");
    gnet_property->props[309].ev_changed = event_new("g2_cache_max_time_changed");
    gnet_property->props[309].save = TRUE;
    gnet_property->props[309].vector_size = 1;
	mutex_init(&gnet_property->props[309].lock);

    /* Type specific data: */
    gnet_property->props[309].type               = PROP_TYPE_GUINT32;
    gnet_property->props[309].data.guint32.def   = (void *) &gnet_property_variable_g2_cache_max_time_default;
    gnet_property->props[309].data.guint32.value = (void *) &gnet_property_variable_g2_cache_max_time;
    gnet_property->props[309].data.guint32.choices = NULL;
    gnet_property->props[309].data.guint32.max   = 691200;
    gnet_property->props[309].data.guint32.min   = 14400;


    /*
     * PROP_G2_DEBUG:
     *
     * General data:
     */
    gnet_property->props[310].name = "g2_debug";
    gnet_property->props[310].desc = _("Debug level for management of G2-only hosts.");
    gnet_property->props[310].ev_changed = event_new("g2_debug_changed");
    gnet_property->props[310].save = TRUE;
    gnet_property->props[310].vector_size = 1;
	mutex_init(&gnet_property->props[310].lock);

    /* Type specific data: */
    gnet_property->props[310].type               = PROP_TYPE_GUINT32;
    gnet_property->props[310].data.guint32.def   = (void *) &gnet_property_variable_g2_debug_default;
    gnet_property->props[310].data.guint32.value = (void *) &gnet_property_variable_g2_debug;
    gnet_property->props[310].data.guint32.choices = NULL;
    gnet_property->props[310].data.guint32.max   = 20;
    gnet_property->props[310].data.guint32.min   = 0;


    /*
     * PROP_DL_RESOURCE_SWITCHING:
     *
     * General data:
     */
    gnet_property->props[311].name = "dl_resource_switching";
    gnet_property->props[311].desc = _("Whether GTKG can switch among the several files waiting to be downloaded from a given server, when making a follow-up HTTP request.  Turn it off only if you witness problems with a particular servent you're downloading from.");
    gnet_property->props[311].ev_changed = event_new("dl_resource_switching_changed");
    gnet_property->props[311].save = TRUE;
    gnet_property->props[311].vector_size = 1;
	mutex_init(&gnet_property->props[311].lock);

    /* Type specific data: */
    gnet_property->props[311].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[311].data.boolean.def   = (void *) &gnet_property_variable_dl_resource_switching_default;
    gnet_property->props[311].data.boolean.value = (void *) &gnet_property_variable_dl_resource_switching;


    /*
     * PROP_PARQ_ENABLED:
     *
     * General data:
     */
    gnet_property->props[312].name = "parq_enabled";
    gnet_property->props[312].desc = _("If set to TRUE, PARQ (Passive/Active Remote Queuing) is enabled. Do not disable unless you know what you are doing.");
    gnet_property->props[312].ev_changed = event_new("parq_enabled_changed");
    gnet_property->props[312].save = TRUE;
    gnet_property->props[312].vector_size = 1;
	mutex_init(&gnet_property->props[312].lock);

    /* Type specific data: */
    gnet_property->props[312].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[312].data.boolean.def   = (void *) &gnet_property_variable_parq_enabled_default;
    gnet_property->props[312].data.boolean.value = (void *) &gnet_property_variable_parq_enabled;


    /*
     * PROP_PFSP_LAST_CHUNK:
     *
     * General data:
     */
    gnet_property->props[313].name = "pfsp_last_chunk";
    gnet_property->props[313].desc = _("When partial file sharing (PFSP) is enabled, gtk-gnutella will strive to download chunks in a random order, to maximize the spreading of the file in the network.  However, this may make pre-viewing of the file impossible as some file formats make use of a trailer to hold meta-information or seeking indices. GTKG will attempt to download the specified amount of data at the tail of the file as soon as possible.  Set it to 0 to disable any tail-downloading preference.");
    gnet_property->props[313].ev_changed = event_new("pfsp_last_chunk_changed");
    gnet_property->props[313].save = TRUE;
    gnet_property->props[313].vector_size = 1;
	mutex_init(&gnet_property->props[313].lock);

    /* Type specific data: */
    gnet_property->props[313].type               = PROP_TYPE_GUINT32;
    gnet_property->props[313].data.guint32.def   = (void *) &gnet_property_variable_pfsp_last_chunk_default;
    gnet_property->props[313].data.guint32.value = (void *) &gnet_property_variable_pfsp_last_chunk;
    gnet_property->props[313].data.guint32.choices = NULL;
    gnet_property->props[313].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[313].data.guint32.min   = 0x00000000;


    /*
     * PROP_BEAUTIFY_FILENAMES:
     *
     * General data:
     */
    gnet_property->props[314].name = "beautify_filenames";
    gnet_property->props[314].desc = _("Whether GTKG should post-process filenames to remove consecutive '_' in the name, or extra '_' surrounding punctuation for instance, to make the name prettier.");
    gnet_property->props[314].ev_changed = event_new("beautify_filenames_changed");
    gnet_property->props[314].save = TRUE;
    gnet_property->props[314].vector_size = 1;
	mutex_init(&gnet_property->props[314].lock);

    /* Type specific data: */
    gnet_property->props[314].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[314].data.boolean.def   = (void *) &gnet_property_variable_beautify_filenames_default;
    gnet_property->props[314].data.boolean.value = (void *) &gnet_property_variable_beautify_filenames;


    /*
     * PROP_ENABLE_DHT:
     *
     * General data:
     */
    gnet_property->props[315].name = "enable_dht";
    gnet_property->props[315].desc = _("Whether the Distributed Hash Table (DHT) should be enabled. The DHT allows you to resolve magnet: URIs and to easily locate alternate locations for files and push-proxies for firewalled hosts. It requires UDP support.");
    gnet_property->props[315].ev_changed = event_new("enable_dht_changed");
    gnet_property->props[315].save = TRUE;
    gnet_property->props[315].vector_size = 1;
	mutex_init(&gnet_property->props[315].lock);

    /* Type specific data: */
    gnet_property->props[315].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[315].data.boolean.def   = (void *) &gnet_property_variable_enable_dht_default;
    gnet_property->props[315].data.boolean.value = (void *) &gnet_property_variable_enable_dht;


    /*
     * PROP_CQ_DEBUG:
     *
     * General data:
     */
    gnet_property->props[316].name = "cq_debug";
    gnet_property->props[316].desc = _("Debug level for the callout queue.");
    gnet_property->props[316].ev_changed = event_new("cq_debug_changed");
    gnet_property->props[316].save = TRUE;
    gnet_property->props[316].vector_size = 1;
	mutex_init(&gnet_property->props[316].lock);

    /* Type specific data: */
    gnet_property->props[316].type               = PROP_TYPE_GUINT32;
    gnet_property->props[316].data.guint32.def   = (void *) &gnet_property_variable_cq_debug_default;
    gnet_property->props[316].data.guint32.value = (void *) &gnet_property_variable_cq_debug;
    gnet_property->props[316].data.guint32.choices = NULL;
    gnet_property->props[316].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[316].data.guint32.min   = 0x00000000;


    /*
     * PROP_DHT_LOOKUP_DEBUG:
     *
     * General data:
     */
    gnet_property->props[317].name = "dht_lookup_debug";
    gnet_property->props[317].desc = _("Debug level for DHT node lookups.");
    gnet_property->props[317].ev_changed = event_new("dht_lookup_debug_changed");
    gnet_property->props[317].save = TRUE;
    gnet_property->props[317].vector_size = 1;
	mutex_init(&gnet_property->props[317].lock);

    /* Type specific data: */
    gnet_property->props[317].type               = PROP_TYPE_GUINT32;
    gnet_property->props[317].data.guint32.def   = (void *) &gnet_property_variable_dht_lookup_debug_default;
    gnet_property->props[317].data.guint32.value = (void *) &gnet_property_variable_dht_lookup_debug;
    gnet_property->props[317].data.guint32.choices = NULL;
    gnet_property->props[317].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[317].data.guint32.min   = 0x00000000;


    /*
     * PROP_DHT_STORAGE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[318].name = "dht_storage_debug";
    gnet_property->props[318].desc = _("Debug level for DHT key/value storage.");
    gnet_property->props[318].ev_changed = event_new("dht_storage_debug_changed");
    gnet_property->props[318].save = TRUE;
    gnet_property->props[318].vector_size = 1;
	mutex_init(&gnet_property->props[318].lock);

    /* Type specific data: */
    gnet_property->props[318].type               = PROP_TYPE_GUINT32;
    gnet_property->props[318].data.guint32.def   = (void *) &gnet_property_variable_dht_storage_debug_default;
    gnet_property->props[318].data.guint32.value = (void *) &gnet_property_variable_dht_storage_debug;
    gnet_property->props[318].data.guint32.choices = NULL;
    gnet_property->props[318].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[318].data.guint32.min   = 0x00000000;


    /*
     * PROP_DHT_PUBLISH_DEBUG:
     *
     * General data:
     */
    gnet_property->props[319].name = "dht_publish_debug";
    gnet_property->props[319].desc = _("Debug level for DHT key/value publishing.");
    gnet_property->props[319].ev_changed = event_new("dht_publish_debug_changed");
    gnet_property->props[319].save = TRUE;
    gnet_property->props[319].vector_size = 1;
	mutex_init(&gnet_property->props[319].lock);

    /* Type specific data: */
    gnet_property->props[319].type               = PROP_TYPE_GUINT32;
    gnet_property->props[319].data.guint32.def   = (void *) &gnet_property_variable_dht_publish_debug_default;
    gnet_property->props[319].data.guint32.value = (void *) &gnet_property_variable_dht_publish_debug;
    gnet_property->props[319].data.guint32.choices = NULL;
    gnet_property->props[319].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[319].data.guint32.min   = 0x00000000;


    /*
     * PROP_BW_DHT_LOOKUP_OUT:
     *
     * General data:
     */
    gnet_property->props[320].name = "output_dht_lookup_bandwidth";
    gnet_property->props[320].desc = _("Bandwidth hint for DHT user lookups, in bytes/sec. This is used both for limiting concurrent publishing and searching.  Traffic is made on the Gnutella UDP socket. Output needs are lower than input (between 3 to 5 times less). The larger the numbers, the more values can be looked up concurrently, but the more bandwidth is used.");
    gnet_property->props[320].ev_changed = event_new("bw_dht_lookup_out_changed");
    gnet_property->props[320].save = TRUE;
    gnet_property->props[320].vector_size = 1;
	mutex_init(&gnet_property->props[320].lock);

    /* Type specific data: */
    gnet_property->props[320].type               = PROP_TYPE_GUINT32;
    gnet_property->props[320].data.guint32.def   = (void *) &gnet_property_variable_bw_dht_lookup_out_default;
    gnet_property->props[320].data.guint32.value = (void *) &gnet_property_variable_bw_dht_lookup_out;
    gnet_property->props[320].data.guint32.choices = NULL;
    gnet_property->props[320].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[320].data.guint32.min   = 512;


    /*
     * PROP_BW_DHT_LOOKUP_IN:
     *
     * General data:
     */
    gnet_property->props[321].name = "input_dht_lookup_bandwidth";
    gnet_property->props[321].desc = _("Bandwidth hint for DHT user lookups, in bytes/sec. This is used both for limiting concurrent publishing and searching.  Traffic is made on the Gnutella UDP socket and cannot therefore be truly controlled.  Input needs are much larger than output as far as lookups are concerned (between 3 to 5 times).  The larger the numbers the more values can be looked up concurrently, but the more bandwidth is used.");
    gnet_property->props[321].ev_changed = event_new("bw_dht_lookup_in_changed");
    gnet_property->props[321].save = TRUE;
    gnet_property->props[321].vector_size = 1;
	mutex_init(&gnet_property->props[321].lock);

    /* Type specific data: */
    gnet_property->props[321].type               = PROP_TYPE_GUINT32;
    gnet_property->props[321].data.guint32.def   = (void *) &gnet_property_variable_bw_dht_lookup_in_default;
    gnet_property->props[321].data.guint32.value = (void *) &gnet_property_variable_bw_dht_lookup_in;
    gnet_property->props[321].data.guint32.choices = NULL;
    gnet_property->props[321].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[321].data.guint32.min   = 2048;


    /*
     * PROP_STICKY_GUID:
     *
     * General data:
     */
    gnet_property->props[322].name = "sticky_guid";
    gnet_property->props[322].desc = _("Whether the GUID should be kept accross sessions. A sticky GUID can be helpful if you are firewalled and share files because the downloaders will be able to contact you again more easily when you come back online.");
    gnet_property->props[322].ev_changed = event_new("sticky_guid_changed");
    gnet_property->props[322].save = TRUE;
    gnet_property->props[322].vector_size = 1;
	mutex_init(&gnet_property->props[322].lock);

    /* Type specific data: */
    gnet_property->props[322].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[322].data.boolean.def   = (void *) &gnet_property_variable_sticky_guid_default;
    gnet_property->props[322].data.boolean.value = (void *) &gnet_property_variable_sticky_guid;


    /*
     * PROP_STICKY_KUID:
     *
     * General data:
     */
    gnet_property->props[323].name = "sticky_kuid";
    gnet_property->props[323].desc = _("Whether the KUID should be kept accross sessions. A sticky KUID is helpful for the DHT because it promotes routing table stability and ensures that closest nodes will keep mutual knowledge about each other");
    gnet_property->props[323].ev_changed = event_new("sticky_kuid_changed");
    gnet_property->props[323].save = TRUE;
    gnet_property->props[323].vector_size = 1;
	mutex_init(&gnet_property->props[323].lock);

    /* Type specific data: */
    gnet_property->props[323].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[323].data.boolean.def   = (void *) &gnet_property_variable_sticky_kuid_default;
    gnet_property->props[323].data.boolean.value = (void *) &gnet_property_variable_sticky_kuid;


    /*
     * PROP_DHT_ULQ_DEBUG:
     *
     * General data:
     */
    gnet_property->props[324].name = "dht_ulq_debug";
    gnet_property->props[324].desc = _("Debug level for the DHT user lookup queue.");
    gnet_property->props[324].ev_changed = event_new("dht_ulq_debug_changed");
    gnet_property->props[324].save = TRUE;
    gnet_property->props[324].vector_size = 1;
	mutex_init(&gnet_property->props[324].lock);

    /* Type specific data: */
    gnet_property->props[324].type               = PROP_TYPE_GUINT32;
    gnet_property->props[324].data.guint32.def   = (void *) &gnet_property_variable_dht_ulq_debug_default;
    gnet_property->props[324].data.guint32.value = (void *) &gnet_property_variable_dht_ulq_debug;
    gnet_property->props[324].data.guint32.choices = NULL;
    gnet_property->props[324].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[324].data.guint32.min   = 0x00000000;


    /*
     * PROP_DHT_STORAGE_IN_MEMORY:
     *
     * General data:
     */
    gnet_property->props[325].name = "dht_storage_in_memory";
    gnet_property->props[325].desc = _("If TRUE, DHT storage uses memory instead of diskspace.");
    gnet_property->props[325].ev_changed = event_new("dht_storage_in_memory_changed");
    gnet_property->props[325].save = TRUE;
    gnet_property->props[325].vector_size = 1;
	mutex_init(&gnet_property->props[325].lock);

    /* Type specific data: */
    gnet_property->props[325].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[325].data.boolean.def   = (void *) &gnet_property_variable_dht_storage_in_memory_default;
    gnet_property->props[325].data.boolean.value = (void *) &gnet_property_variable_dht_storage_in_memory;


    /*
     * PROP_DOWNLOAD_TRACE:
     *
     * General data:
     */
    gnet_property->props[326].name = "download_trace";
    gnet_property->props[326].desc = _("Defines which download HTTP header exchanges should be traced.");
    gnet_property->props[326].ev_changed = event_new("download_trace_changed");
    gnet_property->props[326].save = TRUE;
    gnet_property->props[326].vector_size = 1;
	mutex_init(&gnet_property->props[326].lock);

    /* Type specific data: */
    gnet_property->props[326].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[326].data.guint32.def   = (void *) &gnet_property_variable_download_trace_default;
    gnet_property->props[326].data.guint32.value = (void *) &gnet_property_variable_download_trace;
    gnet_property->props[326].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[326].data.guint32.min   = 0x00000000;
    gnet_property->props[326].data.guint32.choices = (void *) &gnet_property_variable_download_trace_choices;


    /*
     * PROP_UPLOAD_TRACE:
     *
     * General data:
     */
    gnet_property->props[327].name = "upload_trace";
    gnet_property->props[327].desc = _("Defines which upload HTTP header exchanges should be traced.");
    gnet_property->props[327].ev_changed = event_new("upload_trace_changed");
    gnet_property->props[327].save = TRUE;
    gnet_property->props[327].vector_size = 1;
	mutex_init(&gnet_property->props[327].lock);

    /* Type specific data: */
    gnet_property->props[327].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[327].data.guint32.def   = (void *) &gnet_property_variable_upload_trace_default;
    gnet_property->props[327].data.guint32.value = (void *) &gnet_property_variable_upload_trace;
    gnet_property->props[327].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[327].data.guint32.min   = 0x00000000;
    gnet_property->props[327].data.guint32.choices = (void *) &gnet_property_variable_upload_trace_choices;


    /*
     * PROP_GNET_TRACE:
     *
     * General data:
     */
    gnet_property->props[328].name = "gnet_trace";
    gnet_property->props[328].desc = _("Defines which Gnutella header exchanges should be traced.");
    gnet_property->props[328].ev_changed = event_new("gnet_trace_changed");
    gnet_property->props[328].save = TRUE;
    gnet_property->props[328].vector_size = 1;
	mutex_init(&gnet_property->props[328].lock);

    /* Type specific data: */
    gnet_property->props[328].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[328].data.guint32.def   = (void *) &gnet_property_variable_gnet_trace_default;
    gnet_property->props[328].data.guint32.value = (void *) &gnet_property_variable_gnet_trace;
    gnet_property->props[328].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[328].data.guint32.min   = 0x00000000;
    gnet_property->props[328].data.guint32.choices = (void *) &gnet_property_variable_gnet_trace_choices;


    /*
     * PROP_PUSH_PROXY_TRACE:
     *
     * General data:
     */
    gnet_property->props[329].name = "push_proxy_trace";
    gnet_property->props[329].desc = _("Defines which push-proxy HTTP header exchanges should be traced.");
    gnet_property->props[329].ev_changed = event_new("push_proxy_trace_changed");
    gnet_property->props[329].save = TRUE;
    gnet_property->props[329].vector_size = 1;
	mutex_init(&gnet_property->props[329].lock);

    /* Type specific data: */
    gnet_property->props[329].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[329].data.guint32.def   = (void *) &gnet_property_variable_push_proxy_trace_default;
    gnet_property->props[329].data.guint32.value = (void *) &gnet_property_variable_push_proxy_trace;
    gnet_property->props[329].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[329].data.guint32.min   = 0x00000000;
    gnet_property->props[329].data.guint32.choices = (void *) &gnet_property_variable_push_proxy_trace_choices;


    /*
     * PROP_HTTP_TRACE:
     *
     * General data:
     */
    gnet_property->props[330].name = "http_trace";
    gnet_property->props[330].desc = _("Defines which HTTP header exchanges should be traced, other than downloads, uploads and push-proxy exchanges.");
    gnet_property->props[330].ev_changed = event_new("http_trace_changed");
    gnet_property->props[330].save = TRUE;
    gnet_property->props[330].vector_size = 1;
	mutex_init(&gnet_property->props[330].lock);

    /* Type specific data: */
    gnet_property->props[330].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[330].data.guint32.def   = (void *) &gnet_property_variable_http_trace_default;
    gnet_property->props[330].data.guint32.value = (void *) &gnet_property_variable_http_trace;
    gnet_property->props[330].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[330].data.guint32.min   = 0x00000000;
    gnet_property->props[330].data.guint32.choices = (void *) &gnet_property_variable_http_trace_choices;


    /*
     * PROP_VERIFY_DEBUG:
     *
     * General data:
     */
    gnet_property->props[331].name = "verify_debug";
    gnet_property->props[331].desc = _("Debug level for (generic) file verification code.");
    gnet_property->props[331].ev_changed = event_new("verify_debug_changed");
    gnet_property->props[331].save = TRUE;
    gnet_property->props[331].vector_size = 1;
	mutex_init(&gnet_property->props[331].lock);

    /* Type specific data: */
    gnet_property->props[331].type               = PROP_TYPE_GUINT32;
    gnet_property->props[331].data.guint32.def   = (void *) &gnet_property_variable_verify_debug_default;
    gnet_property->props[331].data.guint32.value = (void *) &gnet_property_variable_verify_debug;
    gnet_property->props[331].data.guint32.choices = NULL;
    gnet_property->props[331].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[331].data.guint32.min   = 0x00000000;


    /*
     * PROP_LOCAL_ADDR_CACHE_MAX_HOSTS:
     *
     * General data:
     */
    gnet_property->props[332].name = "local_addr_cache_max_hosts";
    gnet_property->props[332].desc = _("Maximum number of hosts in the local address cache, which remembers the recent IP:port combinations we had.");
    gnet_property->props[332].ev_changed = event_new("local_addr_cache_max_hosts_changed");
    gnet_property->props[332].save = TRUE;
    gnet_property->props[332].vector_size = 1;
	mutex_init(&gnet_property->props[332].lock);

    /* Type specific data: */
    gnet_property->props[332].type               = PROP_TYPE_GUINT32;
    gnet_property->props[332].data.guint32.def   = (void *) &gnet_property_variable_local_addr_cache_max_hosts_default;
    gnet_property->props[332].data.guint32.value = (void *) &gnet_property_variable_local_addr_cache_max_hosts;
    gnet_property->props[332].data.guint32.choices = NULL;
    gnet_property->props[332].data.guint32.max   = 100;
    gnet_property->props[332].data.guint32.min   = 1;


    /*
     * PROP_LOCAL_ADDR_CACHE_MAX_TIME:
     *
     * General data:
     */
    gnet_property->props[333].name = "local_addr_cache_max_time";
    gnet_property->props[333].desc = _("Maximum time before removing hosts from the local address cache, which remembers the recent IP:port combinations we had.");
    gnet_property->props[333].ev_changed = event_new("local_addr_cache_max_time_changed");
    gnet_property->props[333].save = TRUE;
    gnet_property->props[333].vector_size = 1;
	mutex_init(&gnet_property->props[333].lock);

    /* Type specific data: */
    gnet_property->props[333].type               = PROP_TYPE_GUINT32;
    gnet_property->props[333].data.guint32.def   = (void *) &gnet_property_variable_local_addr_cache_max_time_default;
    gnet_property->props[333].data.guint32.value = (void *) &gnet_property_variable_local_addr_cache_max_time;
    gnet_property->props[333].data.guint32.choices = NULL;
    gnet_property->props[333].data.guint32.max   = 2592000;
    gnet_property->props[333].data.guint32.min   = 86400;


    /*
     * PROP_LOCAL_ADDR_DEBUG:
     *
     * General data:
     */
    gnet_property->props[334].name = "local_addr_debug";
    gnet_property->props[334].desc = _("Debug level for management of local address cache.");
    gnet_property->props[334].ev_changed = event_new("local_addr_debug_changed");
    gnet_property->props[334].save = TRUE;
    gnet_property->props[334].vector_size = 1;
	mutex_init(&gnet_property->props[334].lock);

    /* Type specific data: */
    gnet_property->props[334].type               = PROP_TYPE_GUINT32;
    gnet_property->props[334].data.guint32.def   = (void *) &gnet_property_variable_local_addr_debug_default;
    gnet_property->props[334].data.guint32.value = (void *) &gnet_property_variable_local_addr_debug;
    gnet_property->props[334].data.guint32.choices = NULL;
    gnet_property->props[334].data.guint32.max   = 20;
    gnet_property->props[334].data.guint32.min   = 0;


    /*
     * PROP_DUMP_TRANSMITTED_GNUTELLA_PACKETS:
     *
     * General data:
     */
    gnet_property->props[335].name = "dump_transmitted_gnutella_packets";
    gnet_property->props[335].desc = _("If enabled, all packets enqueued for transmission are dumped to $GTK_GNUTELLA_DIR/packets_tx.dump.");
    gnet_property->props[335].ev_changed = event_new("dump_transmitted_gnutella_packets_changed");
    gnet_property->props[335].save = FALSE;
    gnet_property->props[335].vector_size = 1;
	mutex_init(&gnet_property->props[335].lock);

    /* Type specific data: */
    gnet_property->props[335].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[335].data.boolean.def   = (void *) &gnet_property_variable_dump_transmitted_gnutella_packets_default;
    gnet_property->props[335].data.boolean.value = (void *) &gnet_property_variable_dump_transmitted_gnutella_packets;


    /*
     * PROP_MQ_TCP_DEBUG:
     *
     * General data:
     */
    gnet_property->props[336].name = "mq_tcp_debug";
    gnet_property->props[336].desc = _("Debug level the TCP message queues");
    gnet_property->props[336].ev_changed = event_new("mq_tcp_debug_changed");
    gnet_property->props[336].save = TRUE;
    gnet_property->props[336].vector_size = 1;
	mutex_init(&gnet_property->props[336].lock);

    /* Type specific data: */
    gnet_property->props[336].type               = PROP_TYPE_GUINT32;
    gnet_property->props[336].data.guint32.def   = (void *) &gnet_property_variable_mq_tcp_debug_default;
    gnet_property->props[336].data.guint32.value = (void *) &gnet_property_variable_mq_tcp_debug;
    gnet_property->props[336].data.guint32.choices = NULL;
    gnet_property->props[336].data.guint32.max   = 20;
    gnet_property->props[336].data.guint32.min   = 0;


    /*
     * PROP_MQ_UDP_DEBUG:
     *
     * General data:
     */
    gnet_property->props[337].name = "mq_udp_debug";
    gnet_property->props[337].desc = _("Debug level for the UDP message queue.");
    gnet_property->props[337].ev_changed = event_new("mq_udp_debug_changed");
    gnet_property->props[337].save = TRUE;
    gnet_property->props[337].vector_size = 1;
	mutex_init(&gnet_property->props[337].lock);

    /* Type specific data: */
    gnet_property->props[337].type               = PROP_TYPE_GUINT32;
    gnet_property->props[337].data.guint32.def   = (void *) &gnet_property_variable_mq_udp_debug_default;
    gnet_property->props[337].data.guint32.value = (void *) &gnet_property_variable_mq_udp_debug;
    gnet_property->props[337].data.guint32.choices = NULL;
    gnet_property->props[337].data.guint32.max   = 20;
    gnet_property->props[337].data.guint32.min   = 0;


    /*
     * PROP_NODE_UDP_SENDQUEUE_SIZE:
     *
     * General data:
     */
    gnet_property->props[338].name = "node_udp_sendqueue_size";
    gnet_property->props[338].desc = _("Maximum size of the UDP message queue (in bytes). Must be at least 150 percent of the maximum message size.");
    gnet_property->props[338].ev_changed = event_new("node_udp_sendqueue_size_changed");
    gnet_property->props[338].save = TRUE;
    gnet_property->props[338].vector_size = 1;
	mutex_init(&gnet_property->props[338].lock);

    /* Type specific data: */
    gnet_property->props[338].type               = PROP_TYPE_GUINT32;
    gnet_property->props[338].data.guint32.def   = (void *) &gnet_property_variable_node_udp_sendqueue_size_default;
    gnet_property->props[338].data.guint32.value = (void *) &gnet_property_variable_node_udp_sendqueue_size;
    gnet_property->props[338].data.guint32.choices = NULL;
    gnet_property->props[338].data.guint32.max   = 256000;
    gnet_property->props[338].data.guint32.min   = 98304;


    /*
     * PROP_CLOCK_DEBUG:
     *
     * General data:
     */
    gnet_property->props[339].name = "clock_debug";
    gnet_property->props[339].desc = _("Debug level for the management of the clock accuracy.");
    gnet_property->props[339].ev_changed = event_new("clock_debug_changed");
    gnet_property->props[339].save = TRUE;
    gnet_property->props[339].vector_size = 1;
	mutex_init(&gnet_property->props[339].lock);

    /* Type specific data: */
    gnet_property->props[339].type               = PROP_TYPE_GUINT32;
    gnet_property->props[339].data.guint32.def   = (void *) &gnet_property_variable_clock_debug_default;
    gnet_property->props[339].data.guint32.value = (void *) &gnet_property_variable_clock_debug;
    gnet_property->props[339].data.guint32.choices = NULL;
    gnet_property->props[339].data.guint32.max   = 20;
    gnet_property->props[339].data.guint32.min   = 0;


    /*
     * PROP_FW_DEBUG:
     *
     * General data:
     */
    gnet_property->props[340].name = "fw_debug";
    gnet_property->props[340].desc = _("Debug level for the firewalled status management.");
    gnet_property->props[340].ev_changed = event_new("fw_debug_changed");
    gnet_property->props[340].save = TRUE;
    gnet_property->props[340].vector_size = 1;
	mutex_init(&gnet_property->props[340].lock);

    /* Type specific data: */
    gnet_property->props[340].type               = PROP_TYPE_GUINT32;
    gnet_property->props[340].data.guint32.def   = (void *) &gnet_property_variable_fw_debug_default;
    gnet_property->props[340].data.guint32.value = (void *) &gnet_property_variable_fw_debug;
    gnet_property->props[340].data.guint32.choices = NULL;
    gnet_property->props[340].data.guint32.max   = 20;
    gnet_property->props[340].data.guint32.min   = 0;


    /*
     * PROP_HOST_DEBUG:
     *
     * General data:
     */
    gnet_property->props[341].name = "host_debug";
    gnet_property->props[341].desc = _("Debug level for host management.");
    gnet_property->props[341].ev_changed = event_new("host_debug_changed");
    gnet_property->props[341].save = TRUE;
    gnet_property->props[341].vector_size = 1;
	mutex_init(&gnet_property->props[341].lock);

    /* Type specific data: */
    gnet_property->props[341].type               = PROP_TYPE_GUINT32;
    gnet_property->props[341].data.guint32.def   = (void *) &gnet_property_variable_host_debug_default;
    gnet_property->props[341].data.guint32.value = (void *) &gnet_property_variable_host_debug;
    gnet_property->props[341].data.guint32.choices = NULL;
    gnet_property->props[341].data.guint32.max   = 20;
    gnet_property->props[341].data.guint32.min   = 0;


    /*
     * PROP_DHT_ROOTS_DEBUG:
     *
     * General data:
     */
    gnet_property->props[342].name = "dht_roots_debug";
    gnet_property->props[342].desc = _("Debug level for DHT root node caching.");
    gnet_property->props[342].ev_changed = event_new("dht_roots_debug_changed");
    gnet_property->props[342].save = TRUE;
    gnet_property->props[342].vector_size = 1;
	mutex_init(&gnet_property->props[342].lock);

    /* Type specific data: */
    gnet_property->props[342].type               = PROP_TYPE_GUINT32;
    gnet_property->props[342].data.guint32.def   = (void *) &gnet_property_variable_dht_roots_debug_default;
    gnet_property->props[342].data.guint32.value = (void *) &gnet_property_variable_dht_roots_debug;
    gnet_property->props[342].data.guint32.choices = NULL;
    gnet_property->props[342].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[342].data.guint32.min   = 0x00000000;


    /*
     * PROP_LIB_STATS:
     *
     * General data:
     */
    gnet_property->props[343].name = "lib_stats";
    gnet_property->props[343].desc = _("Logged statistics level for code shared between GUI and core.");
    gnet_property->props[343].ev_changed = event_new("lib_stats_changed");
    gnet_property->props[343].save = TRUE;
    gnet_property->props[343].vector_size = 1;
	mutex_init(&gnet_property->props[343].lock);

    /* Type specific data: */
    gnet_property->props[343].type               = PROP_TYPE_GUINT32;
    gnet_property->props[343].data.guint32.def   = (void *) &gnet_property_variable_lib_stats_default;
    gnet_property->props[343].data.guint32.value = (void *) &gnet_property_variable_lib_stats;
    gnet_property->props[343].data.guint32.choices = NULL;
    gnet_property->props[343].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[343].data.guint32.min   = 0x00000000;


    /*
     * PROP_SPAM_LUT_IN_MEMORY:
     *
     * General data:
     */
    gnet_property->props[344].name = "spam_lut_in_memory";
    gnet_property->props[344].desc = _("If TRUE, the spam SHA1 database is kept in memory. If FALSE, it is kept in a fast disk database, which saves a large amount of core memory and reduces the overall footprint, at the cost of an increased I/O level. However, the DB cache has a 90 percent hit rate, so the actual overhead is barely noticeable when running as an ultra node and should remain completely unnoticed when running as a leaf.");
    gnet_property->props[344].ev_changed = event_new("spam_lut_in_memory_changed");
    gnet_property->props[344].save = TRUE;
    gnet_property->props[344].vector_size = 1;
	mutex_init(&gnet_property->props[344].lock);

    /* Type specific data: */
    gnet_property->props[344].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[344].data.boolean.def   = (void *) &gnet_property_variable_spam_lut_in_memory_default;
    gnet_property->props[344].data.boolean.value = (void *) &gnet_property_variable_spam_lut_in_memory;


    /*
     * PROP_SPAM_DEBUG:
     *
     * General data:
     */
    gnet_property->props[345].name = "spam_debug";
    gnet_property->props[345].desc = _("Debug level for spam detection.");
    gnet_property->props[345].ev_changed = event_new("spam_debug_changed");
    gnet_property->props[345].save = TRUE;
    gnet_property->props[345].vector_size = 1;
	mutex_init(&gnet_property->props[345].lock);

    /* Type specific data: */
    gnet_property->props[345].type               = PROP_TYPE_GUINT32;
    gnet_property->props[345].data.guint32.def   = (void *) &gnet_property_variable_spam_debug_default;
    gnet_property->props[345].data.guint32.value = (void *) &gnet_property_variable_spam_debug;
    gnet_property->props[345].data.guint32.choices = NULL;
    gnet_property->props[345].data.guint32.max   = 20;
    gnet_property->props[345].data.guint32.min   = 0;


    /*
     * PROP_LOCKFILE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[346].name = "lockfile_debug";
    gnet_property->props[346].desc = _("Debug level for lockfile management.");
    gnet_property->props[346].ev_changed = event_new("lockfile_debug_changed");
    gnet_property->props[346].save = TRUE;
    gnet_property->props[346].vector_size = 1;
	mutex_init(&gnet_property->props[346].lock);

    /* Type specific data: */
    gnet_property->props[346].type               = PROP_TYPE_GUINT32;
    gnet_property->props[346].data.guint32.def   = (void *) &gnet_property_variable_lockfile_debug_default;
    gnet_property->props[346].data.guint32.value = (void *) &gnet_property_variable_lockfile_debug;
    gnet_property->props[346].data.guint32.choices = NULL;
    gnet_property->props[346].data.guint32.max   = 20;
    gnet_property->props[346].data.guint32.min   = 0;


    /*
     * PROP_ZALLOC_DEBUG:
     *
     * General data:
     */
    gnet_property->props[347].name = "zalloc_debug";
    gnet_property->props[347].desc = _("Debug level for the zone-based memory allocator.");
    gnet_property->props[347].ev_changed = event_new("zalloc_debug_changed");
    gnet_property->props[347].save = TRUE;
    gnet_property->props[347].vector_size = 1;
	mutex_init(&gnet_property->props[347].lock);

    /* Type specific data: */
    gnet_property->props[347].type               = PROP_TYPE_GUINT32;
    gnet_property->props[347].data.guint32.def   = (void *) &gnet_property_variable_zalloc_debug_default;
    gnet_property->props[347].data.guint32.value = (void *) &gnet_property_variable_zalloc_debug;
    gnet_property->props[347].data.guint32.choices = NULL;
    gnet_property->props[347].data.guint32.max   = 20;
    gnet_property->props[347].data.guint32.min   = 0;


    /*
     * PROP_PALLOC_DEBUG:
     *
     * General data:
     */
    gnet_property->props[348].name = "palloc_debug";
    gnet_property->props[348].desc = _("Debug level for the pool-based memory allocator.");
    gnet_property->props[348].ev_changed = event_new("palloc_debug_changed");
    gnet_property->props[348].save = TRUE;
    gnet_property->props[348].vector_size = 1;
	mutex_init(&gnet_property->props[348].lock);

    /* Type specific data: */
    gnet_property->props[348].type               = PROP_TYPE_GUINT32;
    gnet_property->props[348].data.guint32.def   = (void *) &gnet_property_variable_palloc_debug_default;
    gnet_property->props[348].data.guint32.value = (void *) &gnet_property_variable_palloc_debug;
    gnet_property->props[348].data.guint32.choices = NULL;
    gnet_property->props[348].data.guint32.max   = 20;
    gnet_property->props[348].data.guint32.min   = 0;


    /*
     * PROP_RXBUF_DEBUG:
     *
     * General data:
     */
    gnet_property->props[349].name = "rxbuf_debug";
    gnet_property->props[349].desc = _("Debug level for the RX buffer allocator.");
    gnet_property->props[349].ev_changed = event_new("rxbuf_debug_changed");
    gnet_property->props[349].save = TRUE;
    gnet_property->props[349].vector_size = 1;
	mutex_init(&gnet_property->props[349].lock);

    /* Type specific data: */
    gnet_property->props[349].type               = PROP_TYPE_GUINT32;
    gnet_property->props[349].data.guint32.def   = (void *) &gnet_property_variable_rxbuf_debug_default;
    gnet_property->props[349].data.guint32.value = (void *) &gnet_property_variable_rxbuf_debug;
    gnet_property->props[349].data.guint32.choices = NULL;
    gnet_property->props[349].data.guint32.max   = 20;
    gnet_property->props[349].data.guint32.min   = 0;


    /*
     * PROP_ZALLOC_ALWAYS_GC:
     *
     * General data:
     */
    gnet_property->props[350].name = "zalloc_always_gc";
    gnet_property->props[350].desc = _("Whether the zone-based memory allocator should always keep the zones in garbage-collecting mode, thereby maximizing the chances of being able to quickly reclaim empty zones after an allocation burst. This causes a slight CPU overhead at block free time but the memory footprint will remain much lower. To further minimize the footprint, you can also set spam_lut_in_memory to FALSE.");
    gnet_property->props[350].ev_changed = event_new("zalloc_always_gc_changed");
    gnet_property->props[350].save = TRUE;
    gnet_property->props[350].vector_size = 1;
	mutex_init(&gnet_property->props[350].lock);

    /* Type specific data: */
    gnet_property->props[350].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[350].data.boolean.def   = (void *) &gnet_property_variable_zalloc_always_gc_default;
    gnet_property->props[350].data.boolean.value = (void *) &gnet_property_variable_zalloc_always_gc;


    /*
     * PROP_VMM_DEBUG:
     *
     * General data:
     */
    gnet_property->props[351].name = "vmm_debug";
    gnet_property->props[351].desc = _("Debug level for the virtual memory manager.");
    gnet_property->props[351].ev_changed = event_new("vmm_debug_changed");
    gnet_property->props[351].save = TRUE;
    gnet_property->props[351].vector_size = 1;
	mutex_init(&gnet_property->props[351].lock);

    /* Type specific data: */
    gnet_property->props[351].type               = PROP_TYPE_GUINT32;
    gnet_property->props[351].data.guint32.def   = (void *) &gnet_property_variable_vmm_debug_default;
    gnet_property->props[351].data.guint32.value = (void *) &gnet_property_variable_vmm_debug;
    gnet_property->props[351].data.guint32.choices = NULL;
    gnet_property->props[351].data.guint32.max   = 20;
    gnet_property->props[351].data.guint32.min   = 0;


    /*
     * PROP_SHUTDOWN_DEBUG:
     *
     * General data:
     */
    gnet_property->props[352].name = "shutdown_debug";
    gnet_property->props[352].desc = _("Debug level for final shutdown.");
    gnet_property->props[352].ev_changed = event_new("shutdown_debug_changed");
    gnet_property->props[352].save = TRUE;
    gnet_property->props[352].vector_size = 1;
	mutex_init(&gnet_property->props[352].lock);

    /* Type specific data: */
    gnet_property->props[352].type               = PROP_TYPE_GUINT32;
    gnet_property->props[352].data.guint32.def   = (void *) &gnet_property_variable_shutdown_debug_default;
    gnet_property->props[352].data.guint32.value = (void *) &gnet_property_variable_shutdown_debug;
    gnet_property->props[352].data.guint32.choices = NULL;
    gnet_property->props[352].data.guint32.max   = 20;
    gnet_property->props[352].data.guint32.min   = 0;


    /*
     * PROP_COUNTRY_LIMITS:
     *
     * General data:
     */
    gnet_property->props[353].name = "country_limits";
    gnet_property->props[353].desc = _("Country preferences");
    gnet_property->props[353].ev_changed = event_new("country_limits_changed");
    gnet_property->props[353].save = TRUE;
    gnet_property->props[353].vector_size = 1;
	mutex_init(&gnet_property->props[353].lock);

    /* Type specific data: */
    gnet_property->props[353].type               = PROP_TYPE_STRING;
    gnet_property->props[353].data.string.def    = (void *) &gnet_property_variable_country_limits_default;
    gnet_property->props[353].data.string.value  = (void *) &gnet_property_variable_country_limits;
    if (gnet_property->props[353].data.string.def) {
        *gnet_property->props[353].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[353].data.string.def));
    }


    /*
     * PROP_CTL_DEBUG:
     *
     * General data:
     */
    gnet_property->props[354].name = "ctl_debug";
    gnet_property->props[354].desc = _("Debug level for country limits.");
    gnet_property->props[354].ev_changed = event_new("ctl_debug_changed");
    gnet_property->props[354].save = TRUE;
    gnet_property->props[354].vector_size = 1;
	mutex_init(&gnet_property->props[354].lock);

    /* Type specific data: */
    gnet_property->props[354].type               = PROP_TYPE_GUINT32;
    gnet_property->props[354].data.guint32.def   = (void *) &gnet_property_variable_ctl_debug_default;
    gnet_property->props[354].data.guint32.value = (void *) &gnet_property_variable_ctl_debug;
    gnet_property->props[354].data.guint32.choices = NULL;
    gnet_property->props[354].data.guint32.max   = 20;
    gnet_property->props[354].data.guint32.min   = 0;


    /*
     * PROP_LOG_DROPPED_GNUTELLA:
     *
     * General data:
     */
    gnet_property->props[355].name = "log_dropped_gnutella";
    gnet_property->props[355].desc = _("Whether to log dropped Gnutella messages");
    gnet_property->props[355].ev_changed = event_new("log_dropped_gnutella_changed");
    gnet_property->props[355].save = TRUE;
    gnet_property->props[355].vector_size = 1;
	mutex_init(&gnet_property->props[355].lock);

    /* Type specific data: */
    gnet_property->props[355].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[355].data.boolean.def   = (void *) &gnet_property_variable_log_dropped_gnutella_default;
    gnet_property->props[355].data.boolean.value = (void *) &gnet_property_variable_log_dropped_gnutella;


    /*
     * PROP_WHITELIST_DEBUG:
     *
     * General data:
     */
    gnet_property->props[356].name = "whitelist_debug";
    gnet_property->props[356].desc = _("Debug level for whitelist management.");
    gnet_property->props[356].ev_changed = event_new("whitelist_debug_changed");
    gnet_property->props[356].save = TRUE;
    gnet_property->props[356].vector_size = 1;
	mutex_init(&gnet_property->props[356].lock);

    /* Type specific data: */
    gnet_property->props[356].type               = PROP_TYPE_GUINT32;
    gnet_property->props[356].data.guint32.def   = (void *) &gnet_property_variable_whitelist_debug_default;
    gnet_property->props[356].data.guint32.value = (void *) &gnet_property_variable_whitelist_debug;
    gnet_property->props[356].data.guint32.choices = NULL;
    gnet_property->props[356].data.guint32.max   = 20;
    gnet_property->props[356].data.guint32.min   = 0;


    /*
     * PROP_DHT_TCACHE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[357].name = "dht_tcache_debug";
    gnet_property->props[357].desc = _("Debug level for DHT token caching.");
    gnet_property->props[357].ev_changed = event_new("dht_tcache_debug_changed");
    gnet_property->props[357].save = TRUE;
    gnet_property->props[357].vector_size = 1;
	mutex_init(&gnet_property->props[357].lock);

    /* Type specific data: */
    gnet_property->props[357].type               = PROP_TYPE_GUINT32;
    gnet_property->props[357].data.guint32.def   = (void *) &gnet_property_variable_dht_tcache_debug_default;
    gnet_property->props[357].data.guint32.value = (void *) &gnet_property_variable_dht_tcache_debug;
    gnet_property->props[357].data.guint32.choices = NULL;
    gnet_property->props[357].data.guint32.max   = 20;
    gnet_property->props[357].data.guint32.min   = 0;


    /*
     * PROP_PUBLISHER_DEBUG:
     *
     * General data:
     */
    gnet_property->props[358].name = "publisher_debug";
    gnet_property->props[358].desc = _("Debug level for DHT publishing from Gnutella.");
    gnet_property->props[358].ev_changed = event_new("publisher_debug_changed");
    gnet_property->props[358].save = TRUE;
    gnet_property->props[358].vector_size = 1;
	mutex_init(&gnet_property->props[358].lock);

    /* Type specific data: */
    gnet_property->props[358].type               = PROP_TYPE_GUINT32;
    gnet_property->props[358].data.guint32.def   = (void *) &gnet_property_variable_publisher_debug_default;
    gnet_property->props[358].data.guint32.value = (void *) &gnet_property_variable_publisher_debug;
    gnet_property->props[358].data.guint32.choices = NULL;
    gnet_property->props[358].data.guint32.max   = 20;
    gnet_property->props[358].data.guint32.min   = 0;


    /*
     * PROP_DHT_TRACE:
     *
     * General data:
     */
    gnet_property->props[359].name = "dht_trace";
    gnet_property->props[359].desc = _("Defines which DHT messages should be traced.");
    gnet_property->props[359].ev_changed = event_new("dht_trace_changed");
    gnet_property->props[359].save = TRUE;
    gnet_property->props[359].vector_size = 1;
	mutex_init(&gnet_property->props[359].lock);

    /* Type specific data: */
    gnet_property->props[359].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[359].data.guint32.def   = (void *) &gnet_property_variable_dht_trace_default;
    gnet_property->props[359].data.guint32.value = (void *) &gnet_property_variable_dht_trace;
    gnet_property->props[359].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[359].data.guint32.min   = 0x00000000;
    gnet_property->props[359].data.guint32.choices = (void *) &gnet_property_variable_dht_trace_choices;


    /*
     * PROP_BW_DHT_OUT_ENABLED:
     *
     * General data:
     */
    gnet_property->props[360].name = "bandwidth_dht_output_limit";
    gnet_property->props[360].desc = _("Enable bandwidth limitation for outgoing DHT traffic.");
    gnet_property->props[360].ev_changed = event_new("bw_dht_out_enabled_changed");
    gnet_property->props[360].save = TRUE;
    gnet_property->props[360].vector_size = 1;
	mutex_init(&gnet_property->props[360].lock);

    /* Type specific data: */
    gnet_property->props[360].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[360].data.boolean.def   = (void *) &gnet_property_variable_bws_dht_out_enabled_default;
    gnet_property->props[360].data.boolean.value = (void *) &gnet_property_variable_bws_dht_out_enabled;


    /*
     * PROP_BW_DHT_OUT:
     *
     * General data:
     */
    gnet_property->props[361].name = "output_dht_bandwidth";
    gnet_property->props[361].desc = _("Bandwidth limit for outgoing DHT traffic in bytes/sec. It is always pooled with the Gnutella UDP queue, regardless of whether bandwidth stealing is enabled, so that UDP queues can flush more quickly.");
    gnet_property->props[361].ev_changed = event_new("bw_dht_out_changed");
    gnet_property->props[361].save = TRUE;
    gnet_property->props[361].vector_size = 1;
	mutex_init(&gnet_property->props[361].lock);

    /* Type specific data: */
    gnet_property->props[361].type               = PROP_TYPE_GUINT32;
    gnet_property->props[361].data.guint32.def   = (void *) &gnet_property_variable_bw_dht_out_default;
    gnet_property->props[361].data.guint32.value = (void *) &gnet_property_variable_bw_dht_out;
    gnet_property->props[361].data.guint32.choices = NULL;
    gnet_property->props[361].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[361].data.guint32.min   = 8192;


    /*
     * PROP_NODE_DHT_SENDQUEUE_SIZE:
     *
     * General data:
     */
    gnet_property->props[362].name = "node_dht_sendqueue_size";
    gnet_property->props[362].desc = _("Maximum size of the DHT message queue (in bytes).");
    gnet_property->props[362].ev_changed = event_new("node_dht_sendqueue_size_changed");
    gnet_property->props[362].save = TRUE;
    gnet_property->props[362].vector_size = 1;
	mutex_init(&gnet_property->props[362].lock);

    /* Type specific data: */
    gnet_property->props[362].type               = PROP_TYPE_GUINT32;
    gnet_property->props[362].data.guint32.def   = (void *) &gnet_property_variable_node_dht_sendqueue_size_default;
    gnet_property->props[362].data.guint32.value = (void *) &gnet_property_variable_node_dht_sendqueue_size;
    gnet_property->props[362].data.guint32.choices = NULL;
    gnet_property->props[362].data.guint32.max   = 256000;
    gnet_property->props[362].data.guint32.min   = 98304;


    /*
     * PROP_BSCHED_DEBUG:
     *
     * General data:
     */
    gnet_property->props[363].name = "bsched_debug";
    gnet_property->props[363].desc = _("Debug level for bandwidth scheduler.");
    gnet_property->props[363].ev_changed = event_new("bsched_debug_changed");
    gnet_property->props[363].save = TRUE;
    gnet_property->props[363].vector_size = 1;
	mutex_init(&gnet_property->props[363].lock);

    /* Type specific data: */
    gnet_property->props[363].type               = PROP_TYPE_GUINT32;
    gnet_property->props[363].data.guint32.def   = (void *) &gnet_property_variable_bsched_debug_default;
    gnet_property->props[363].data.guint32.value = (void *) &gnet_property_variable_bsched_debug;
    gnet_property->props[363].data.guint32.choices = NULL;
    gnet_property->props[363].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[363].data.guint32.min   = 0x00000000;


    /*
     * PROP_DHT_STABLE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[364].name = "dht_stable_debug";
    gnet_property->props[364].desc = _("Debug level for the DHT stable node recorder.");
    gnet_property->props[364].ev_changed = event_new("dht_stable_debug_changed");
    gnet_property->props[364].save = TRUE;
    gnet_property->props[364].vector_size = 1;
	mutex_init(&gnet_property->props[364].lock);

    /* Type specific data: */
    gnet_property->props[364].type               = PROP_TYPE_GUINT32;
    gnet_property->props[364].data.guint32.def   = (void *) &gnet_property_variable_dht_stable_debug_default;
    gnet_property->props[364].data.guint32.value = (void *) &gnet_property_variable_dht_stable_debug;
    gnet_property->props[364].data.guint32.choices = NULL;
    gnet_property->props[364].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[364].data.guint32.min   = 0x00000000;


    /*
     * PROP_RELOAD_DEBUG:
     *
     * General data:
     */
    gnet_property->props[365].name = "reload_debug";
    gnet_property->props[365].desc = _("Debug level for the file (re)loading, on change.");
    gnet_property->props[365].ev_changed = event_new("reload_debug_changed");
    gnet_property->props[365].save = TRUE;
    gnet_property->props[365].vector_size = 1;
	mutex_init(&gnet_property->props[365].lock);

    /* Type specific data: */
    gnet_property->props[365].type               = PROP_TYPE_GUINT32;
    gnet_property->props[365].data.guint32.def   = (void *) &gnet_property_variable_reload_debug_default;
    gnet_property->props[365].data.guint32.value = (void *) &gnet_property_variable_reload_debug;
    gnet_property->props[365].data.guint32.choices = NULL;
    gnet_property->props[365].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[365].data.guint32.min   = 0x00000000;


    /*
     * PROP_MOVE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[366].name = "move_debug";
    gnet_property->props[366].desc = _("Debug level for the file moving, accross filesystems.");
    gnet_property->props[366].ev_changed = event_new("move_debug_changed");
    gnet_property->props[366].save = TRUE;
    gnet_property->props[366].vector_size = 1;
	mutex_init(&gnet_property->props[366].lock);

    /* Type specific data: */
    gnet_property->props[366].type               = PROP_TYPE_GUINT32;
    gnet_property->props[366].data.guint32.def   = (void *) &gnet_property_variable_move_debug_default;
    gnet_property->props[366].data.guint32.value = (void *) &gnet_property_variable_move_debug;
    gnet_property->props[366].data.guint32.choices = NULL;
    gnet_property->props[366].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[366].data.guint32.min   = 0x00000000;


    /*
     * PROP_QHIT_DEBUG:
     *
     * General data:
     */
    gnet_property->props[367].name = "qhit_debug";
    gnet_property->props[367].desc = _("Debug level for query hit message generation.");
    gnet_property->props[367].ev_changed = event_new("qhit_debug_changed");
    gnet_property->props[367].save = TRUE;
    gnet_property->props[367].vector_size = 1;
	mutex_init(&gnet_property->props[367].lock);

    /* Type specific data: */
    gnet_property->props[367].type               = PROP_TYPE_GUINT32;
    gnet_property->props[367].data.guint32.def   = (void *) &gnet_property_variable_qhit_debug_default;
    gnet_property->props[367].data.guint32.value = (void *) &gnet_property_variable_qhit_debug;
    gnet_property->props[367].data.guint32.choices = NULL;
    gnet_property->props[367].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[367].data.guint32.min   = 0x00000000;


    /*
     * PROP_VERSION_DEBUG:
     *
     * General data:
     */
    gnet_property->props[368].name = "version_debug";
    gnet_property->props[368].desc = _("Debug level for version management.");
    gnet_property->props[368].ev_changed = event_new("version_debug_changed");
    gnet_property->props[368].save = TRUE;
    gnet_property->props[368].vector_size = 1;
	mutex_init(&gnet_property->props[368].lock);

    /* Type specific data: */
    gnet_property->props[368].type               = PROP_TYPE_GUINT32;
    gnet_property->props[368].data.guint32.def   = (void *) &gnet_property_variable_version_debug_default;
    gnet_property->props[368].data.guint32.value = (void *) &gnet_property_variable_version_debug;
    gnet_property->props[368].data.guint32.choices = NULL;
    gnet_property->props[368].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[368].data.guint32.min   = 0x00000000;


    /*
     * PROP_CPU_FREQ_MIN:
     *
     * General data:
     */
    gnet_property->props[369].name = "cpu_freq_min";
    gnet_property->props[369].desc = _("Minimum CPU frequency, in Hz.");
    gnet_property->props[369].ev_changed = event_new("cpu_freq_min_changed");
    gnet_property->props[369].save = FALSE;
    gnet_property->props[369].vector_size = 1;
	mutex_init(&gnet_property->props[369].lock);

    /* Type specific data: */
    gnet_property->props[369].type               = PROP_TYPE_GUINT64;
    gnet_property->props[369].data.guint64.def   = (void *) &gnet_property_variable_cpu_freq_min_default;
    gnet_property->props[369].data.guint64.value = (void *) &gnet_property_variable_cpu_freq_min;
    gnet_property->props[369].data.guint64.choices = NULL;
    gnet_property->props[369].data.guint64.max   = (guint64) -1;
    gnet_property->props[369].data.guint64.min   = 0x0000000000000000;


    /*
     * PROP_CPU_FREQ_MAX:
     *
     * General data:
     */
    gnet_property->props[370].name = "cpu_freq_max";
    gnet_property->props[370].desc = _("Maximum CPU frequency, in Hz.");
    gnet_property->props[370].ev_changed = event_new("cpu_freq_max_changed");
    gnet_property->props[370].save = FALSE;
    gnet_property->props[370].vector_size = 1;
	mutex_init(&gnet_property->props[370].lock);

    /* Type specific data: */
    gnet_property->props[370].type               = PROP_TYPE_GUINT64;
    gnet_property->props[370].data.guint64.def   = (void *) &gnet_property_variable_cpu_freq_max_default;
    gnet_property->props[370].data.guint64.value = (void *) &gnet_property_variable_cpu_freq_max;
    gnet_property->props[370].data.guint64.choices = NULL;
    gnet_property->props[370].data.guint64.max   = (guint64) -1;
    gnet_property->props[370].data.guint64.min   = 0x0000000000000000;


    /*
     * PROP_DHT_BOOT_STATUS:
     *
     * General data:
     */
    gnet_property->props[371].name = "dht_boot_status";
    gnet_property->props[371].desc = _("DHT bootstrap status.");
    gnet_property->props[371].ev_changed = event_new("dht_boot_status_changed");
    gnet_property->props[371].save = FALSE;
    gnet_property->props[371].vector_size = 1;
	mutex_init(&gnet_property->props[371].lock);

    /* Type specific data: */
    gnet_property->props[371].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[371].data.guint32.def   = (void *) &gnet_property_variable_dht_boot_status_default;
    gnet_property->props[371].data.guint32.value = (void *) &gnet_property_variable_dht_boot_status;
    gnet_property->props[371].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[371].data.guint32.min   = 0x00000000;
    gnet_property->props[371].data.guint32.choices = (void *) &gnet_property_variable_dht_boot_status_choices;


    /*
     * PROP_DHT_CONFIGURED_MODE:
     *
     * General data:
     */
    gnet_property->props[372].name = "dht_configured_mode";
    gnet_property->props[372].desc = _("The DHT running mode. An active node will be able to store values and is a fully participating member of the Distributed Hash Table. A passive node can perform lookups and publish but will not store values and cannot be a member of the DHT structure. A firewalled node is necessarily passive, but you can force the passive mode even if you are not firewalled, although that is not recommended because the DHT requires far more active nodes that passive ones to be efficient.");
    gnet_property->props[372].ev_changed = event_new("dht_configured_mode_changed");
    gnet_property->props[372].save = TRUE;
    gnet_property->props[372].vector_size = 1;
	mutex_init(&gnet_property->props[372].lock);

    /* Type specific data: */
    gnet_property->props[372].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[372].data.guint32.def   = (void *) &gnet_property_variable_dht_configured_mode_default;
    gnet_property->props[372].data.guint32.value = (void *) &gnet_property_variable_dht_configured_mode;
    gnet_property->props[372].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[372].data.guint32.min   = 0x00000000;
    gnet_property->props[372].data.guint32.choices = (void *) &gnet_property_variable_dht_configured_mode_choices;


    /*
     * PROP_DHT_CURRENT_MODE:
     *
     * General data:
     */
    gnet_property->props[373].name = "dht_current_mode";
    gnet_property->props[373].desc = _("Current DHT running mode.");
    gnet_property->props[373].ev_changed = event_new("dht_current_mode_changed");
    gnet_property->props[373].save = FALSE;
    gnet_property->props[373].vector_size = 1;
	mutex_init(&gnet_property->props[373].lock);

    /* Type specific data: */
    gnet_property->props[373].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[373].data.guint32.def   = (void *) &gnet_property_variable_dht_current_mode_default;
    gnet_property->props[373].data.guint32.value = (void *) &gnet_property_variable_dht_current_mode;
    gnet_property->props[373].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[373].data.guint32.min   = 0x00000000;
    gnet_property->props[373].data.guint32.choices = (void *) &gnet_property_variable_dht_current_mode_choices;


    /*
     * PROP_OMALLOC_DEBUG:
     *
     * General data:
     */
    gnet_property->props[374].name = "omalloc_debug";
    gnet_property->props[374].desc = _("Debug level for the one-time memory allocator.");
    gnet_property->props[374].ev_changed = event_new("omalloc_debug_changed");
    gnet_property->props[374].save = TRUE;
    gnet_property->props[374].vector_size = 1;
	mutex_init(&gnet_property->props[374].lock);

    /* Type specific data: */
    gnet_property->props[374].type               = PROP_TYPE_GUINT32;
    gnet_property->props[374].data.guint32.def   = (void *) &gnet_property_variable_omalloc_debug_default;
    gnet_property->props[374].data.guint32.value = (void *) &gnet_property_variable_omalloc_debug;
    gnet_property->props[374].data.guint32.choices = NULL;
    gnet_property->props[374].data.guint32.max   = 20;
    gnet_property->props[374].data.guint32.min   = 0;


    /*
     * PROP_HCACHE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[375].name = "hcache_debug";
    gnet_property->props[375].desc = _("Debug level for the host cache.");
    gnet_property->props[375].ev_changed = event_new("hcache_debug_changed");
    gnet_property->props[375].save = TRUE;
    gnet_property->props[375].vector_size = 1;
	mutex_init(&gnet_property->props[375].lock);

    /* Type specific data: */
    gnet_property->props[375].type               = PROP_TYPE_GUINT32;
    gnet_property->props[375].data.guint32.def   = (void *) &gnet_property_variable_hcache_debug_default;
    gnet_property->props[375].data.guint32.value = (void *) &gnet_property_variable_hcache_debug;
    gnet_property->props[375].data.guint32.choices = NULL;
    gnet_property->props[375].data.guint32.max   = 20;
    gnet_property->props[375].data.guint32.min   = 0;


    /*
     * PROP_RANDOMNESS:
     *
     * General data:
     */
    gnet_property->props[376].name = "randomness";
    gnet_property->props[376].desc = _("Random bits.");
    gnet_property->props[376].ev_changed = event_new("randomness_changed");
    gnet_property->props[376].save = TRUE;
    gnet_property->props[376].vector_size = KUID_RAW_SIZE;
	mutex_init(&gnet_property->props[376].lock);

    /* Type specific data: */
    gnet_property->props[376].type               = PROP_TYPE_STORAGE;
    gnet_property->props[376].data.storage.value = gnet_property_variable_randomness;


    /*
     * PROP_AVERAGE_SERVENT_DOWNTIME:
     *
     * General data:
     */
    gnet_property->props[377].name = "average_servent_downtime";
    gnet_property->props[377].desc = _("Average servent downtime.");
    gnet_property->props[377].ev_changed = event_new("average_servent_downtime_changed");
    gnet_property->props[377].save = TRUE;
    gnet_property->props[377].vector_size = 1;
	mutex_init(&gnet_property->props[377].lock);

    /* Type specific data: */
    gnet_property->props[377].type               = PROP_TYPE_GUINT32;
    gnet_property->props[377].data.guint32.def   = (void *) &gnet_property_variable_average_servent_downtime_default;
    gnet_property->props[377].data.guint32.value = (void *) &gnet_property_variable_average_servent_downtime;
    gnet_property->props[377].data.guint32.choices = NULL;
    gnet_property->props[377].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[377].data.guint32.min   = 0x00000000;


    /*
     * PROP_SHUTDOWN_TIME:
     *
     * General data:
     */
    gnet_property->props[378].name = "shutdown_time";
    gnet_property->props[378].desc = _("Time when last shutdown occurred.");
    gnet_property->props[378].ev_changed = event_new("shutdown_time_changed");
    gnet_property->props[378].save = TRUE;
    gnet_property->props[378].vector_size = 1;
	mutex_init(&gnet_property->props[378].lock);

    /* Type specific data: */
    gnet_property->props[378].type               = PROP_TYPE_TIMESTAMP;
    gnet_property->props[378].data.timestamp.def   = (void *) &gnet_property_variable_shutdown_time_default;
    gnet_property->props[378].data.timestamp.value = (void *) &gnet_property_variable_shutdown_time;
    gnet_property->props[378].data.timestamp.choices = NULL;
    gnet_property->props[378].data.timestamp.max   = (time_t) ((1U << 31) - 1);
    gnet_property->props[378].data.timestamp.min   = 0x0000000000000000;


    /*
     * PROP_ALIVE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[379].name = "alive_debug";
    gnet_property->props[379].desc = _("Debug level for alive pings.");
    gnet_property->props[379].ev_changed = event_new("alive_debug_changed");
    gnet_property->props[379].save = TRUE;
    gnet_property->props[379].vector_size = 1;
	mutex_init(&gnet_property->props[379].lock);

    /* Type specific data: */
    gnet_property->props[379].type               = PROP_TYPE_GUINT32;
    gnet_property->props[379].data.guint32.def   = (void *) &gnet_property_variable_alive_debug_default;
    gnet_property->props[379].data.guint32.value = (void *) &gnet_property_variable_alive_debug;
    gnet_property->props[379].data.guint32.choices = NULL;
    gnet_property->props[379].data.guint32.max   = 20;
    gnet_property->props[379].data.guint32.min   = 0;


    /*
     * PROP_VXML_DEBUG:
     *
     * General data:
     */
    gnet_property->props[380].name = "vxml_debug";
    gnet_property->props[380].desc = _("Debug level for the versatile XML layer.");
    gnet_property->props[380].ev_changed = event_new("vxml_debug_changed");
    gnet_property->props[380].save = TRUE;
    gnet_property->props[380].vector_size = 1;
	mutex_init(&gnet_property->props[380].lock);

    /* Type specific data: */
    gnet_property->props[380].type               = PROP_TYPE_GUINT32;
    gnet_property->props[380].data.guint32.def   = (void *) &gnet_property_variable_vxml_debug_default;
    gnet_property->props[380].data.guint32.value = (void *) &gnet_property_variable_vxml_debug;
    gnet_property->props[380].data.guint32.choices = NULL;
    gnet_property->props[380].data.guint32.max   = 20;
    gnet_property->props[380].data.guint32.min   = 0;


    /*
     * PROP_UPNP_DEBUG:
     *
     * General data:
     */
    gnet_property->props[381].name = "upnp_debug";
    gnet_property->props[381].desc = _("Debug level for the UPnP layer.");
    gnet_property->props[381].ev_changed = event_new("upnp_debug_changed");
    gnet_property->props[381].save = TRUE;
    gnet_property->props[381].vector_size = 1;
	mutex_init(&gnet_property->props[381].lock);

    /* Type specific data: */
    gnet_property->props[381].type               = PROP_TYPE_GUINT32;
    gnet_property->props[381].data.guint32.def   = (void *) &gnet_property_variable_upnp_debug_default;
    gnet_property->props[381].data.guint32.value = (void *) &gnet_property_variable_upnp_debug;
    gnet_property->props[381].data.guint32.choices = NULL;
    gnet_property->props[381].data.guint32.max   = 20;
    gnet_property->props[381].data.guint32.min   = 0;


    /*
     * PROP_SOAP_DEBUG:
     *
     * General data:
     */
    gnet_property->props[382].name = "soap_debug";
    gnet_property->props[382].desc = _("Debug level for the SOAP layer.");
    gnet_property->props[382].ev_changed = event_new("soap_debug_changed");
    gnet_property->props[382].save = TRUE;
    gnet_property->props[382].vector_size = 1;
	mutex_init(&gnet_property->props[382].lock);

    /* Type specific data: */
    gnet_property->props[382].type               = PROP_TYPE_GUINT32;
    gnet_property->props[382].data.guint32.def   = (void *) &gnet_property_variable_soap_debug_default;
    gnet_property->props[382].data.guint32.value = (void *) &gnet_property_variable_soap_debug;
    gnet_property->props[382].data.guint32.choices = NULL;
    gnet_property->props[382].data.guint32.max   = 20;
    gnet_property->props[382].data.guint32.min   = 0;


    /*
     * PROP_SOAP_TRACE:
     *
     * General data:
     */
    gnet_property->props[383].name = "soap_trace";
    gnet_property->props[383].desc = _("Defines SOAP exchanges tracing type.");
    gnet_property->props[383].ev_changed = event_new("soap_trace_changed");
    gnet_property->props[383].save = TRUE;
    gnet_property->props[383].vector_size = 1;
	mutex_init(&gnet_property->props[383].lock);

    /* Type specific data: */
    gnet_property->props[383].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[383].data.guint32.def   = (void *) &gnet_property_variable_soap_trace_default;
    gnet_property->props[383].data.guint32.value = (void *) &gnet_property_variable_soap_trace;
    gnet_property->props[383].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[383].data.guint32.min   = 0x00000000;
    gnet_property->props[383].data.guint32.choices = (void *) &gnet_property_variable_soap_trace_choices;


    /*
     * PROP_ALLOW_FIREWALLED_ULTRA:
     *
     * General data:
     */
    gnet_property->props[384].name = "allow_firewalled_ultra";
    gnet_property->props[384].desc = _("For testing purposes, allow to run as an ultranode even if the node cannot accept incoming TCP connections.");
    gnet_property->props[384].ev_changed = event_new("allow_firewalled_ultra_changed");
    gnet_property->props[384].save = TRUE;
    gnet_property->props[384].vector_size = 1;
	mutex_init(&gnet_property->props[384].lock);

    /* Type specific data: */
    gnet_property->props[384].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[384].data.boolean.def   = (void *) &gnet_property_variable_allow_firewalled_ultra_default;
    gnet_property->props[384].data.boolean.value = (void *) &gnet_property_variable_allow_firewalled_ultra;


    /*
     * PROP_ENABLE_UPNP:
     *
     * General data:
     */
    gnet_property->props[385].name = "enable_upnp";
    gnet_property->props[385].desc = _("Whether UPnP (Universal Plug and Play) should be enabled. Support for UPnP means gtk-gnutella will be able to discover your Internet Gateway Device (router) and request that the listening port be opened and redirected to your machine, thereby auto-configuring to make sure you are not firewalled.  By default you should leave it enabled unless you know how to configure your network equipment manually to prevent the firewalled condition for both TCP and UDP.");
    gnet_property->props[385].ev_changed = event_new("enable_upnp_changed");
    gnet_property->props[385].save = TRUE;
    gnet_property->props[385].vector_size = 1;
	mutex_init(&gnet_property->props[385].lock);

    /* Type specific data: */
    gnet_property->props[385].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[385].data.boolean.def   = (void *) &gnet_property_variable_enable_upnp_default;
    gnet_property->props[385].data.boolean.value = (void *) &gnet_property_variable_enable_upnp;


    /*
     * PROP_UPNP_POSSIBLE:
     *
     * General data:
     */
    gnet_property->props[386].name = "upnp_possible";
    gnet_property->props[386].desc = _("Whether gtk-gnutella was able to locate an Internet Gateway Device to install port mappings, if required.");
    gnet_property->props[386].ev_changed = event_new("upnp_possible_changed");
    gnet_property->props[386].save = FALSE;
    gnet_property->props[386].vector_size = 1;
	mutex_init(&gnet_property->props[386].lock);

    /* Type specific data: */
    gnet_property->props[386].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[386].data.boolean.def   = (void *) &gnet_property_variable_upnp_possible_default;
    gnet_property->props[386].data.boolean.value = (void *) &gnet_property_variable_upnp_possible;


    /*
     * PROP_PORT_MAPPING_REQUIRED:
     *
     * General data:
     */
    gnet_property->props[387].name = "port_mapping_required";
    gnet_property->props[387].desc = _("Whether gtk-gnutella thinks it needs to install port mappings on your network router to avoid the firewalled condition.");
    gnet_property->props[387].ev_changed = event_new("port_mapping_required_changed");
    gnet_property->props[387].save = TRUE;
    gnet_property->props[387].vector_size = 1;
	mutex_init(&gnet_property->props[387].lock);

    /* Type specific data: */
    gnet_property->props[387].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[387].data.boolean.def   = (void *) &gnet_property_variable_port_mapping_required_default;
    gnet_property->props[387].data.boolean.value = (void *) &gnet_property_variable_port_mapping_required;


    /*
     * PROP_PORT_MAPPING_POSSIBLE:
     *
     * General data:
     */
    gnet_property->props[388].name = "port_mapping_possible";
    gnet_property->props[388].desc = _("Whether gtk-gnutella can install port mappings, if needed.");
    gnet_property->props[388].ev_changed = event_new("port_mapping_possible_changed");
    gnet_property->props[388].save = FALSE;
    gnet_property->props[388].vector_size = 1;
	mutex_init(&gnet_property->props[388].lock);

    /* Type specific data: */
    gnet_property->props[388].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[388].data.boolean.def   = (void *) &gnet_property_variable_port_mapping_possible_default;
    gnet_property->props[388].data.boolean.value = (void *) &gnet_property_variable_port_mapping_possible;


    /*
     * PROP_NATPMP_DEBUG:
     *
     * General data:
     */
    gnet_property->props[389].name = "natpmp_debug";
    gnet_property->props[389].desc = _("Debug level for the NAT-PMP layer.");
    gnet_property->props[389].ev_changed = event_new("natpmp_debug_changed");
    gnet_property->props[389].save = TRUE;
    gnet_property->props[389].vector_size = 1;
	mutex_init(&gnet_property->props[389].lock);

    /* Type specific data: */
    gnet_property->props[389].type               = PROP_TYPE_GUINT32;
    gnet_property->props[389].data.guint32.def   = (void *) &gnet_property_variable_natpmp_debug_default;
    gnet_property->props[389].data.guint32.value = (void *) &gnet_property_variable_natpmp_debug;
    gnet_property->props[389].data.guint32.choices = NULL;
    gnet_property->props[389].data.guint32.max   = 20;
    gnet_property->props[389].data.guint32.min   = 0;


    /*
     * PROP_ENABLE_NATPMP:
     *
     * General data:
     */
    gnet_property->props[390].name = "enable_natpmp";
    gnet_property->props[390].desc = _("Whether NAT-PMP (NAT Port Mapping Protocol) should be enabled. Support for NAT-PMP means gtk-gnutella will be able to look whether your default gateway (router) supports the Port Mapping Protocol to allow transparent redirection of the external ports on the router to the local machine, thereby making sure you are not firewalled. By default you should leave it enabled unless you know how to configure your network equipment manually to prevent the firewalled condition for both TCP and UDP.");
    gnet_property->props[390].ev_changed = event_new("enable_natpmp_changed");
    gnet_property->props[390].save = TRUE;
    gnet_property->props[390].vector_size = 1;
	mutex_init(&gnet_property->props[390].lock);

    /* Type specific data: */
    gnet_property->props[390].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[390].data.boolean.def   = (void *) &gnet_property_variable_enable_natpmp_default;
    gnet_property->props[390].data.boolean.value = (void *) &gnet_property_variable_enable_natpmp;


    /*
     * PROP_NATPMP_POSSIBLE:
     *
     * General data:
     */
    gnet_property->props[391].name = "natpmp_possible";
    gnet_property->props[391].desc = _("Whether gtk-gnutella was able to locate a NAT-PMP gateway to install port mappings, if required.");
    gnet_property->props[391].ev_changed = event_new("natpmp_possible_changed");
    gnet_property->props[391].save = FALSE;
    gnet_property->props[391].vector_size = 1;
	mutex_init(&gnet_property->props[391].lock);

    /* Type specific data: */
    gnet_property->props[391].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[391].data.boolean.def   = (void *) &gnet_property_variable_natpmp_possible_default;
    gnet_property->props[391].data.boolean.value = (void *) &gnet_property_variable_natpmp_possible;


    /*
     * PROP_TX_DEBUG:
     *
     * General data:
     */
    gnet_property->props[392].name = "tx_debug";
    gnet_property->props[392].desc = _("Debug level for the TX (transmit) network layer.");
    gnet_property->props[392].ev_changed = event_new("tx_debug_changed");
    gnet_property->props[392].save = TRUE;
    gnet_property->props[392].vector_size = 1;
	mutex_init(&gnet_property->props[392].lock);

    /* Type specific data: */
    gnet_property->props[392].type               = PROP_TYPE_GUINT32;
    gnet_property->props[392].data.guint32.def   = (void *) &gnet_property_variable_tx_debug_default;
    gnet_property->props[392].data.guint32.value = (void *) &gnet_property_variable_tx_debug;
    gnet_property->props[392].data.guint32.choices = NULL;
    gnet_property->props[392].data.guint32.max   = 20;
    gnet_property->props[392].data.guint32.min   = 0;


    /*
     * PROP_RX_DEBUG:
     *
     * General data:
     */
    gnet_property->props[393].name = "rx_debug";
    gnet_property->props[393].desc = _("Debug level for the RX (receive) network layer.");
    gnet_property->props[393].ev_changed = event_new("rx_debug_changed");
    gnet_property->props[393].save = TRUE;
    gnet_property->props[393].vector_size = 1;
	mutex_init(&gnet_property->props[393].lock);

    /* Type specific data: */
    gnet_property->props[393].type               = PROP_TYPE_GUINT32;
    gnet_property->props[393].data.guint32.def   = (void *) &gnet_property_variable_rx_debug_default;
    gnet_property->props[393].data.guint32.value = (void *) &gnet_property_variable_rx_debug;
    gnet_property->props[393].data.guint32.choices = NULL;
    gnet_property->props[393].data.guint32.max   = 20;
    gnet_property->props[393].data.guint32.min   = 0;


    /*
     * PROP_INPUTEVT_DEBUG:
     *
     * General data:
     */
    gnet_property->props[394].name = "inputevt_debug";
    gnet_property->props[394].desc = _("Debug level for the I/O input event layer.");
    gnet_property->props[394].ev_changed = event_new("inputevt_debug_changed");
    gnet_property->props[394].save = TRUE;
    gnet_property->props[394].vector_size = 1;
	mutex_init(&gnet_property->props[394].lock);

    /* Type specific data: */
    gnet_property->props[394].type               = PROP_TYPE_GUINT32;
    gnet_property->props[394].data.guint32.def   = (void *) &gnet_property_variable_inputevt_debug_default;
    gnet_property->props[394].data.guint32.value = (void *) &gnet_property_variable_inputevt_debug;
    gnet_property->props[394].data.guint32.choices = NULL;
    gnet_property->props[394].data.guint32.max   = 20;
    gnet_property->props[394].data.guint32.min   = 0;


    /*
     * PROP_BG_DEBUG:
     *
     * General data:
     */
    gnet_property->props[395].name = "bg_debug";
    gnet_property->props[395].desc = _("Debug level for the background task scheduler.");
    gnet_property->props[395].ev_changed = event_new("bg_debug_changed");
    gnet_property->props[395].save = TRUE;
    gnet_property->props[395].vector_size = 1;
	mutex_init(&gnet_property->props[395].lock);

    /* Type specific data: */
    gnet_property->props[395].type               = PROP_TYPE_GUINT32;
    gnet_property->props[395].data.guint32.def   = (void *) &gnet_property_variable_bg_debug_default;
    gnet_property->props[395].data.guint32.value = (void *) &gnet_property_variable_bg_debug;
    gnet_property->props[395].data.guint32.choices = NULL;
    gnet_property->props[395].data.guint32.max   = 20;
    gnet_property->props[395].data.guint32.min   = 0;


    /*
     * PROP_PORT_MAPPING_SUCCESSFUL:
     *
     * General data:
     */
    gnet_property->props[396].name = "port_mapping_successful";
    gnet_property->props[396].desc = _("Whether gtk-gnutella was able to configure port mappings.");
    gnet_property->props[396].ev_changed = event_new("port_mapping_successful_changed");
    gnet_property->props[396].save = FALSE;
    gnet_property->props[396].vector_size = 1;
	mutex_init(&gnet_property->props[396].lock);

    /* Type specific data: */
    gnet_property->props[396].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[396].data.boolean.def   = (void *) &gnet_property_variable_port_mapping_successful_default;
    gnet_property->props[396].data.boolean.value = (void *) &gnet_property_variable_port_mapping_successful;


    /*
     * PROP_UPLOADS_BW_NO_STEALING:
     *
     * General data:
     */
    gnet_property->props[397].name = "uploads_bw_no_stealing";
    gnet_property->props[397].desc = _("Whether gtk-gnutella disabled HTTP bandwidth stealing.");
    gnet_property->props[397].ev_changed = event_new("uploads_bw_no_stealing_changed");
    gnet_property->props[397].save = FALSE;
    gnet_property->props[397].vector_size = 1;
	mutex_init(&gnet_property->props[397].lock);

    /* Type specific data: */
    gnet_property->props[397].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[397].data.boolean.def   = (void *) &gnet_property_variable_uploads_bw_no_stealing_default;
    gnet_property->props[397].data.boolean.value = (void *) &gnet_property_variable_uploads_bw_no_stealing;


    /*
     * PROP_UPLOADS_BW_IGNORE_STOLEN:
     *
     * General data:
     */
    gnet_property->props[398].name = "uploads_bw_ignore_stolen";
    gnet_property->props[398].desc = _("Whether gtk-gnutella ignores HTTP stolen bandwidth.");
    gnet_property->props[398].ev_changed = event_new("uploads_bw_ignore_stolen_changed");
    gnet_property->props[398].save = FALSE;
    gnet_property->props[398].vector_size = 1;
	mutex_init(&gnet_property->props[398].lock);

    /* Type specific data: */
    gnet_property->props[398].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[398].data.boolean.def   = (void *) &gnet_property_variable_uploads_bw_ignore_stolen_default;
    gnet_property->props[398].data.boolean.value = (void *) &gnet_property_variable_uploads_bw_ignore_stolen;


    /*
     * PROP_UPLOADS_BW_UNIFORM:
     *
     * General data:
     */
    gnet_property->props[399].name = "uploads_bw_uniform";
    gnet_property->props[399].desc = _("Whether gtk-gnutella enforces uniform HTTP outgoing bandwidth.");
    gnet_property->props[399].ev_changed = event_new("uploads_bw_uniform_changed");
    gnet_property->props[399].save = FALSE;
    gnet_property->props[399].vector_size = 1;
	mutex_init(&gnet_property->props[399].lock);

    /* Type specific data: */
    gnet_property->props[399].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[399].data.boolean.def   = (void *) &gnet_property_variable_uploads_bw_uniform_default;
    gnet_property->props[399].data.boolean.value = (void *) &gnet_property_variable_uploads_bw_uniform;


    /*
     * PROP_ENABLE_HTTP_PIPELINING:
     *
     * General data:
     */
    gnet_property->props[400].name = "enable_http_pipelining";
    gnet_property->props[400].desc = _("Whether gtk-gnutella should use HTTP request pipelining when possible, in order to decrease downloading latency.");
    gnet_property->props[400].ev_changed = event_new("enable_http_pipelining_changed");
    gnet_property->props[400].save = TRUE;
    gnet_property->props[400].vector_size = 1;
	mutex_init(&gnet_property->props[400].lock);

    /* Type specific data: */
    gnet_property->props[400].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[400].data.boolean.def   = (void *) &gnet_property_variable_enable_http_pipelining_default;
    gnet_property->props[400].data.boolean.value = (void *) &gnet_property_variable_enable_http_pipelining;


    /*
     * PROP_DL_PIPELINE_MAXCHUNKSIZE:
     *
     * General data:
     */
    gnet_property->props[401].name = "dl_pipeline_maxchunksize";
    gnet_property->props[401].desc = _("Maximum chunk size when swarming with HTTP pipelining.");
    gnet_property->props[401].ev_changed = event_new("dl_pipeline_maxchunksize_changed");
    gnet_property->props[401].save = TRUE;
    gnet_property->props[401].vector_size = 1;
	mutex_init(&gnet_property->props[401].lock);

    /* Type specific data: */
    gnet_property->props[401].type               = PROP_TYPE_GUINT32;
    gnet_property->props[401].data.guint32.def   = (void *) &gnet_property_variable_dl_pipeline_maxchunksize_default;
    gnet_property->props[401].data.guint32.value = (void *) &gnet_property_variable_dl_pipeline_maxchunksize;
    gnet_property->props[401].data.guint32.choices = NULL;
    gnet_property->props[401].data.guint32.max   = 10*1024*1024;
    gnet_property->props[401].data.guint32.min   = 64*1024;


    /*
     * PROP_ENABLE_GUESS:
     *
     * General data:
     */
    gnet_property->props[402].name = "enable_guess";
    gnet_property->props[402].desc = _("Whether the Gnutella UDP Extension for Scalable Searches (GUESS) should be enabled.  With GUESS enabled, gtk-gnutella offers the network the ability to perform iterative Ultrapeer queries instead of just broadcasting, allowing searches to more places within the Gnutella network.  If you want gtk-gnutella to issue GUESS queries, you need to make sure the client-side is enabled as well as this setting only governs mostly the server-side of GUESS (required to allow the client-side).");
    gnet_property->props[402].ev_changed = event_new("enable_guess_changed");
    gnet_property->props[402].save = TRUE;
    gnet_property->props[402].vector_size = 1;
	mutex_init(&gnet_property->props[402].lock);

    /* Type specific data: */
    gnet_property->props[402].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[402].data.boolean.def   = (void *) &gnet_property_variable_enable_guess_default;
    gnet_property->props[402].data.boolean.value = (void *) &gnet_property_variable_enable_guess;


    /*
     * PROP_GUESS_SERVER_DEBUG:
     *
     * General data:
     */
    gnet_property->props[403].name = "guess_server_debug";
    gnet_property->props[403].desc = _("Debug level for server-side GUESS (Gnutella UDP Extension for Scalable Searches).");
    gnet_property->props[403].ev_changed = event_new("guess_server_debug_changed");
    gnet_property->props[403].save = TRUE;
    gnet_property->props[403].vector_size = 1;
	mutex_init(&gnet_property->props[403].lock);

    /* Type specific data: */
    gnet_property->props[403].type               = PROP_TYPE_GUINT32;
    gnet_property->props[403].data.guint32.def   = (void *) &gnet_property_variable_guess_server_debug_default;
    gnet_property->props[403].data.guint32.value = (void *) &gnet_property_variable_guess_server_debug;
    gnet_property->props[403].data.guint32.choices = NULL;
    gnet_property->props[403].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[403].data.guint32.min   = 0x00000000;


    /*
     * PROP_GUESS_CLIENT_DEBUG:
     *
     * General data:
     */
    gnet_property->props[404].name = "guess_client_debug";
    gnet_property->props[404].desc = _("Debug level for client-side GUESS (Gnutella UDP Extension for Scalable Searches).");
    gnet_property->props[404].ev_changed = event_new("guess_client_debug_changed");
    gnet_property->props[404].save = TRUE;
    gnet_property->props[404].vector_size = 1;
	mutex_init(&gnet_property->props[404].lock);

    /* Type specific data: */
    gnet_property->props[404].type               = PROP_TYPE_GUINT32;
    gnet_property->props[404].data.guint32.def   = (void *) &gnet_property_variable_guess_client_debug_default;
    gnet_property->props[404].data.guint32.value = (void *) &gnet_property_variable_guess_client_debug;
    gnet_property->props[404].data.guint32.choices = NULL;
    gnet_property->props[404].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[404].data.guint32.min   = 0x00000000;


    /*
     * PROP_MAX_GUESS_HOSTS_CACHED:
     *
     * General data:
     */
    gnet_property->props[405].name = "max_guess_hosts_cached";
    gnet_property->props[405].desc = _("Maximum number of IPv4 hosts in the regular GUESS cache.");
    gnet_property->props[405].ev_changed = event_new("max_guess_hosts_cached_changed");
    gnet_property->props[405].save = TRUE;
    gnet_property->props[405].vector_size = 1;
	mutex_init(&gnet_property->props[405].lock);

    /* Type specific data: */
    gnet_property->props[405].type               = PROP_TYPE_GUINT32;
    gnet_property->props[405].data.guint32.def   = (void *) &gnet_property_variable_max_guess_hosts_cached_default;
    gnet_property->props[405].data.guint32.value = (void *) &gnet_property_variable_max_guess_hosts_cached;
    gnet_property->props[405].data.guint32.choices = NULL;
    gnet_property->props[405].data.guint32.max   = 10000;
    gnet_property->props[405].data.guint32.min   = 100;


    /*
     * PROP_HOSTS_IN_GUESS_CATCHER:
     *
     * General data:
     */
    gnet_property->props[406].name = "hosts_in_guess_catcher";
    gnet_property->props[406].desc = _("Current number of IPv4 hosts in the regular GUESS cache.");
    gnet_property->props[406].ev_changed = event_new("hosts_in_guess_catcher_changed");
    gnet_property->props[406].save = FALSE;
    gnet_property->props[406].vector_size = 1;
	mutex_init(&gnet_property->props[406].lock);

    /* Type specific data: */
    gnet_property->props[406].type               = PROP_TYPE_GUINT32;
    gnet_property->props[406].data.guint32.def   = (void *) &gnet_property_variable_hosts_in_guess_catcher_default;
    gnet_property->props[406].data.guint32.value = (void *) &gnet_property_variable_hosts_in_guess_catcher;
    gnet_property->props[406].data.guint32.choices = NULL;
    gnet_property->props[406].data.guint32.max   = INT_MAX;
    gnet_property->props[406].data.guint32.min   = 0;


    /*
     * PROP_MAX_GUESS_INTRO_HOSTS_CACHED:
     *
     * General data:
     */
    gnet_property->props[407].name = "max_guess_intro_hosts_cached";
    gnet_property->props[407].desc = _("Maximum number of IPv4 hosts in the introduction GUESS cache.");
    gnet_property->props[407].ev_changed = event_new("max_guess_intro_hosts_cached_changed");
    gnet_property->props[407].save = TRUE;
    gnet_property->props[407].vector_size = 1;
	mutex_init(&gnet_property->props[407].lock);

    /* Type specific data: */
    gnet_property->props[407].type               = PROP_TYPE_GUINT32;
    gnet_property->props[407].data.guint32.def   = (void *) &gnet_property_variable_max_guess_intro_hosts_cached_default;
    gnet_property->props[407].data.guint32.value = (void *) &gnet_property_variable_max_guess_intro_hosts_cached;
    gnet_property->props[407].data.guint32.choices = NULL;
    gnet_property->props[407].data.guint32.max   = 50000;
    gnet_property->props[407].data.guint32.min   = 1000;


    /*
     * PROP_HOSTS_IN_GUESS_INTRO_CATCHER:
     *
     * General data:
     */
    gnet_property->props[408].name = "hosts_in_guess_intro_catcher";
    gnet_property->props[408].desc = _("Current number of IPv4 hosts in the introduction GUESS cache.");
    gnet_property->props[408].ev_changed = event_new("hosts_in_guess_intro_catcher_changed");
    gnet_property->props[408].save = FALSE;
    gnet_property->props[408].vector_size = 1;
	mutex_init(&gnet_property->props[408].lock);

    /* Type specific data: */
    gnet_property->props[408].type               = PROP_TYPE_GUINT32;
    gnet_property->props[408].data.guint32.def   = (void *) &gnet_property_variable_hosts_in_guess_intro_catcher_default;
    gnet_property->props[408].data.guint32.value = (void *) &gnet_property_variable_hosts_in_guess_intro_catcher;
    gnet_property->props[408].data.guint32.choices = NULL;
    gnet_property->props[408].data.guint32.max   = INT_MAX;
    gnet_property->props[408].data.guint32.min   = 0;


    /*
     * PROP_DBSTORE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[409].name = "dbstore_debug";
    gnet_property->props[409].desc = _("Debug level for the DB disk/RAM storage layer.");
    gnet_property->props[409].ev_changed = event_new("dbstore_debug_changed");
    gnet_property->props[409].save = TRUE;
    gnet_property->props[409].vector_size = 1;
	mutex_init(&gnet_property->props[409].lock);

    /* Type specific data: */
    gnet_property->props[409].type               = PROP_TYPE_GUINT32;
    gnet_property->props[409].data.guint32.def   = (void *) &gnet_property_variable_dbstore_debug_default;
    gnet_property->props[409].data.guint32.value = (void *) &gnet_property_variable_dbstore_debug;
    gnet_property->props[409].data.guint32.choices = NULL;
    gnet_property->props[409].data.guint32.max   = 20;
    gnet_property->props[409].data.guint32.min   = 0;


    /*
     * PROP_SESSION_ID:
     *
     * General data:
     */
    gnet_property->props[410].name = "session_id";
    gnet_property->props[410].desc = _("The current Session ID.  This is a unique ID generated each time gtk-gnutella starts and it can be monitored from the shell interface to check whether gtk-gnutella has been restarted since the last check.");
    gnet_property->props[410].ev_changed = event_new("session_id_changed");
    gnet_property->props[410].save = FALSE;
    gnet_property->props[410].vector_size = GUID_RAW_SIZE;
	mutex_init(&gnet_property->props[410].lock);

    /* Type specific data: */
    gnet_property->props[410].type               = PROP_TYPE_STORAGE;
    gnet_property->props[410].data.storage.value = gnet_property_variable_session_id;


    /*
     * PROP_PFSP_RARE_SERVER:
     *
     * General data:
     */
    gnet_property->props[411].name = "pfsp_rare_server";
    gnet_property->props[411].desc = _("Whether gtk-gnutella should serve partial files which are rare on the network to increase their spreading rate.  It is good for the health of the network to always leave this enabled. This setting supersedes the disabling of global partial file sharing for rare files only.");
    gnet_property->props[411].ev_changed = event_new("pfsp_rare_server_changed");
    gnet_property->props[411].save = TRUE;
    gnet_property->props[411].vector_size = 1;
	mutex_init(&gnet_property->props[411].lock);

    /* Type specific data: */
    gnet_property->props[411].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[411].data.boolean.def   = (void *) &gnet_property_variable_pfsp_rare_server_default;
    gnet_property->props[411].data.boolean.value = (void *) &gnet_property_variable_pfsp_rare_server;


    /*
     * PROP_ENABLE_GUESS_CLIENT:
     *
     * General data:
     */
    gnet_property->props[412].name = "enable_guess_client";
    gnet_property->props[412].desc = _("Whether the Gnutella UDP Extension for Scalable Searches (GUESS) client side should be enabled, so that gtk-gnutella can indeed issue iterative Ultrapeer queries instead of just broadcasting them. If enabled, it requires general GUESS support enabled as well or it will simply be ignored.");
    gnet_property->props[412].ev_changed = event_new("enable_guess_client_changed");
    gnet_property->props[412].save = TRUE;
    gnet_property->props[412].vector_size = 1;
	mutex_init(&gnet_property->props[412].lock);

    /* Type specific data: */
    gnet_property->props[412].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[412].data.boolean.def   = (void *) &gnet_property_variable_enable_guess_client_default;
    gnet_property->props[412].data.boolean.value = (void *) &gnet_property_variable_enable_guess_client;


    /*
     * PROP_BW_GUESS_OUT:
     *
     * General data:
     */
    gnet_property->props[413].name = "guess_output_bandwidth";
    gnet_property->props[413].desc = _("Bandwidth hint for GUESS querying, in bytes/sec, limiting the amount of concurrency that can be used for GUESS.  Lower numbers mean slower querying overall");
    gnet_property->props[413].ev_changed = event_new("bw_guess_out_changed");
    gnet_property->props[413].save = TRUE;
    gnet_property->props[413].vector_size = 1;
	mutex_init(&gnet_property->props[413].lock);

    /* Type specific data: */
    gnet_property->props[413].type               = PROP_TYPE_GUINT32;
    gnet_property->props[413].data.guint32.def   = (void *) &gnet_property_variable_bw_guess_out_default;
    gnet_property->props[413].data.guint32.value = (void *) &gnet_property_variable_bw_guess_out;
    gnet_property->props[413].data.guint32.choices = NULL;
    gnet_property->props[413].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[413].data.guint32.min   = 256;


    /*
     * PROP_MATCHING_DEBUG:
     *
     * General data:
     */
    gnet_property->props[414].name = "matching_debug";
    gnet_property->props[414].desc = _("Debug level for the matching code.");
    gnet_property->props[414].ev_changed = event_new("matching_debug_changed");
    gnet_property->props[414].save = TRUE;
    gnet_property->props[414].vector_size = 1;
	mutex_init(&gnet_property->props[414].lock);

    /* Type specific data: */
    gnet_property->props[414].type               = PROP_TYPE_GUINT32;
    gnet_property->props[414].data.guint32.def   = (void *) &gnet_property_variable_matching_debug_default;
    gnet_property->props[414].data.guint32.value = (void *) &gnet_property_variable_matching_debug;
    gnet_property->props[414].data.guint32.choices = NULL;
    gnet_property->props[414].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[414].data.guint32.min   = 0x00000000;


    /*
     * PROP_TSYNC_DEBUG:
     *
     * General data:
     */
    gnet_property->props[415].name = "tsync_debug";
    gnet_property->props[415].desc = _("Debug level for the time synchronization code.");
    gnet_property->props[415].ev_changed = event_new("tsync_debug_changed");
    gnet_property->props[415].save = TRUE;
    gnet_property->props[415].vector_size = 1;
	mutex_init(&gnet_property->props[415].lock);

    /* Type specific data: */
    gnet_property->props[415].type               = PROP_TYPE_GUINT32;
    gnet_property->props[415].data.guint32.def   = (void *) &gnet_property_variable_tsync_debug_default;
    gnet_property->props[415].data.guint32.value = (void *) &gnet_property_variable_tsync_debug;
    gnet_property->props[415].data.guint32.choices = NULL;
    gnet_property->props[415].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[415].data.guint32.min   = 0x00000000;


    /*
     * PROP_QUERY_REQUEST_PARTIALS:
     *
     * General data:
     */
    gnet_property->props[416].name = "query_request_partials";
    gnet_property->props[416].desc = _("Whether queries can request partial results hits, i.e. files which are incompletely available on remote hosts.");
    gnet_property->props[416].ev_changed = event_new("query_request_partials_changed");
    gnet_property->props[416].save = TRUE;
    gnet_property->props[416].vector_size = 1;
	mutex_init(&gnet_property->props[416].lock);

    /* Type specific data: */
    gnet_property->props[416].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[416].data.boolean.def   = (void *) &gnet_property_variable_query_request_partials_default;
    gnet_property->props[416].data.boolean.value = (void *) &gnet_property_variable_query_request_partials;


    /*
     * PROP_QUERY_ANSWER_PARTIALS:
     *
     * General data:
     */
    gnet_property->props[417].name = "query_answer_partials";
    gnet_property->props[417].desc = _("Whether queries for partial files should be answered to.When Partial File Sharing is disabled this setting is of course ignored and no partial results are returned.");
    gnet_property->props[417].ev_changed = event_new("query_answer_partials_changed");
    gnet_property->props[417].save = TRUE;
    gnet_property->props[417].vector_size = 1;
	mutex_init(&gnet_property->props[417].lock);

    /* Type specific data: */
    gnet_property->props[417].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[417].data.boolean.def   = (void *) &gnet_property_variable_query_answer_partials_default;
    gnet_property->props[417].data.boolean.value = (void *) &gnet_property_variable_query_answer_partials;


    /*
     * PROP_QUERY_ANSWER_WHATS_NEW:
     *
     * General data:
     */
    gnet_property->props[418].name = "query_answer_whats_new";
    gnet_property->props[418].desc = _("Whether what's-new? queries should be answered to.");
    gnet_property->props[418].ev_changed = event_new("query_answer_whats_new_changed");
    gnet_property->props[418].save = TRUE;
    gnet_property->props[418].vector_size = 1;
	mutex_init(&gnet_property->props[418].lock);

    /* Type specific data: */
    gnet_property->props[418].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[418].data.boolean.def   = (void *) &gnet_property_variable_query_answer_whats_new_default;
    gnet_property->props[418].data.boolean.value = (void *) &gnet_property_variable_query_answer_whats_new;


    /*
     * PROP_SEARCH_SMART_STOP:
     *
     * General data:
     */
    gnet_property->props[419].name = "search_smart_stop";
    gnet_property->props[419].desc = _("When set, gtk-gnutella will automatically stop opened searches from which all the requested downloads have been completed, regardless of the initially configured expiration time.");
    gnet_property->props[419].ev_changed = event_new("search_smart_stop_changed");
    gnet_property->props[419].save = TRUE;
    gnet_property->props[419].vector_size = 1;
	mutex_init(&gnet_property->props[419].lock);

    /* Type specific data: */
    gnet_property->props[419].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[419].data.boolean.def   = (void *) &gnet_property_variable_search_smart_stop_default;
    gnet_property->props[419].data.boolean.value = (void *) &gnet_property_variable_search_smart_stop;


    /*
     * PROP_WHATS_NEW_SEARCH_MAX_RESULTS:
     *
     * General data:
     */
    gnet_property->props[420].name = "whats_new_search_max_results";
    gnet_property->props[420].desc = _("Maximum number of results to show in a What's New? request.");
    gnet_property->props[420].ev_changed = event_new("whats_new_search_max_results_changed");
    gnet_property->props[420].save = TRUE;
    gnet_property->props[420].vector_size = 1;
	mutex_init(&gnet_property->props[420].lock);

    /* Type specific data: */
    gnet_property->props[420].type               = PROP_TYPE_GUINT32;
    gnet_property->props[420].data.guint32.def   = (void *) &gnet_property_variable_whats_new_search_max_results_default;
    gnet_property->props[420].data.guint32.value = (void *) &gnet_property_variable_whats_new_search_max_results;
    gnet_property->props[420].data.guint32.choices = NULL;
    gnet_property->props[420].data.guint32.max   = 500000;
    gnet_property->props[420].data.guint32.min   = 100;


    /*
     * PROP_PASSIVE_SEARCH_MAX_RESULTS:
     *
     * General data:
     */
    gnet_property->props[421].name = "passive_search_max_results";
    gnet_property->props[421].desc = _("Maximum number of results to show in a passive search request.");
    gnet_property->props[421].ev_changed = event_new("passive_search_max_results_changed");
    gnet_property->props[421].save = TRUE;
    gnet_property->props[421].vector_size = 1;
	mutex_init(&gnet_property->props[421].lock);

    /* Type specific data: */
    gnet_property->props[421].type               = PROP_TYPE_GUINT32;
    gnet_property->props[421].data.guint32.def   = (void *) &gnet_property_variable_passive_search_max_results_default;
    gnet_property->props[421].data.guint32.value = (void *) &gnet_property_variable_passive_search_max_results;
    gnet_property->props[421].data.guint32.choices = NULL;
    gnet_property->props[421].data.guint32.max   = 500000;
    gnet_property->props[421].data.guint32.min   = 100;


    /*
     * PROP_LOG_DUP_GNUTELLA_SAME_NODE:
     *
     * General data:
     */
    gnet_property->props[422].name = "log_dup_gnutella_same_node";
    gnet_property->props[422].desc = _("Whether to log duplicate Gnutella messages from same node.");
    gnet_property->props[422].ev_changed = event_new("log_dup_gnutella_same_node_changed");
    gnet_property->props[422].save = TRUE;
    gnet_property->props[422].vector_size = 1;
	mutex_init(&gnet_property->props[422].lock);

    /* Type specific data: */
    gnet_property->props[422].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[422].data.boolean.def   = (void *) &gnet_property_variable_log_dup_gnutella_same_node_default;
    gnet_property->props[422].data.boolean.value = (void *) &gnet_property_variable_log_dup_gnutella_same_node;


    /*
     * PROP_LOG_DUP_GNUTELLA_HIGHER_TTL:
     *
     * General data:
     */
    gnet_property->props[423].name = "log_dup_gnutella_higher_ttl";
    gnet_property->props[423].desc = _("Whether to log duplicate Gnutella messages with a higher TTL.");
    gnet_property->props[423].ev_changed = event_new("log_dup_gnutella_higher_ttl_changed");
    gnet_property->props[423].save = TRUE;
    gnet_property->props[423].vector_size = 1;
	mutex_init(&gnet_property->props[423].lock);

    /* Type specific data: */
    gnet_property->props[423].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[423].data.boolean.def   = (void *) &gnet_property_variable_log_dup_gnutella_higher_ttl_default;
    gnet_property->props[423].data.boolean.value = (void *) &gnet_property_variable_log_dup_gnutella_higher_ttl;


    /*
     * PROP_LOG_DUP_GNUTELLA_OTHER_NODE:
     *
     * General data:
     */
    gnet_property->props[424].name = "log_dup_gnutella_other_node";
    gnet_property->props[424].desc = _("Whether to log duplicate Gnutella messages (not from same node).");
    gnet_property->props[424].ev_changed = event_new("log_dup_gnutella_other_node_changed");
    gnet_property->props[424].save = TRUE;
    gnet_property->props[424].vector_size = 1;
	mutex_init(&gnet_property->props[424].lock);

    /* Type specific data: */
    gnet_property->props[424].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[424].data.boolean.def   = (void *) &gnet_property_variable_log_dup_gnutella_other_node_default;
    gnet_property->props[424].data.boolean.value = (void *) &gnet_property_variable_log_dup_gnutella_other_node;


    /*
     * PROP_LOG_NEW_GNUTELLA:
     *
     * General data:
     */
    gnet_property->props[425].name = "log_new_gnutella";
    gnet_property->props[425].desc = _("Whether to log new Gnutella messages, never seen before.");
    gnet_property->props[425].ev_changed = event_new("log_new_gnutella_changed");
    gnet_property->props[425].save = TRUE;
    gnet_property->props[425].vector_size = 1;
	mutex_init(&gnet_property->props[425].lock);

    /* Type specific data: */
    gnet_property->props[425].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[425].data.boolean.def   = (void *) &gnet_property_variable_log_new_gnutella_default;
    gnet_property->props[425].data.boolean.value = (void *) &gnet_property_variable_log_new_gnutella;


    /*
     * PROP_LOG_GNUTELLA_ROUTING:
     *
     * General data:
     */
    gnet_property->props[426].name = "log_gnutella_routing";
    gnet_property->props[426].desc = _("Whether to log Gnutella routing decisions.");
    gnet_property->props[426].ev_changed = event_new("log_gnutella_routing_changed");
    gnet_property->props[426].save = TRUE;
    gnet_property->props[426].vector_size = 1;
	mutex_init(&gnet_property->props[426].lock);

    /* Type specific data: */
    gnet_property->props[426].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[426].data.boolean.def   = (void *) &gnet_property_variable_log_gnutella_routing_default;
    gnet_property->props[426].data.boolean.value = (void *) &gnet_property_variable_log_gnutella_routing;


    /*
     * PROP_LOG_BAD_GNUTELLA:
     *
     * General data:
     */
    gnet_property->props[427].name = "log_bad_gnutella";
    gnet_property->props[427].desc = _("Whether to log bad Gnutella messages, corrupted or unexpected.");
    gnet_property->props[427].ev_changed = event_new("log_bad_gnutella_changed");
    gnet_property->props[427].save = TRUE;
    gnet_property->props[427].vector_size = 1;
	mutex_init(&gnet_property->props[427].lock);

    /* Type specific data: */
    gnet_property->props[427].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[427].data.boolean.def   = (void *) &gnet_property_variable_log_bad_gnutella_default;
    gnet_property->props[427].data.boolean.value = (void *) &gnet_property_variable_log_bad_gnutella;


    /*
     * PROP_LOG_SPAM_QUERY_HIT:
     *
     * General data:
     */
    gnet_property->props[428].name = "log_spam_query_hit";
    gnet_property->props[428].desc = _("Whether to log conditions triggering query hit spam flagging.");
    gnet_property->props[428].ev_changed = event_new("log_spam_query_hit_changed");
    gnet_property->props[428].save = TRUE;
    gnet_property->props[428].vector_size = 1;
	mutex_init(&gnet_property->props[428].lock);

    /* Type specific data: */
    gnet_property->props[428].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[428].data.boolean.def   = (void *) &gnet_property_variable_log_spam_query_hit_default;
    gnet_property->props[428].data.boolean.value = (void *) &gnet_property_variable_log_spam_query_hit;


    /*
     * PROP_MAX_ULTRA6_HOSTS_CACHED:
     *
     * General data:
     */
    gnet_property->props[429].name = "max_ultra6_hosts_cached";
    gnet_property->props[429].desc = _("Maximum number of IPv6 hosts in the ultra node cache.");
    gnet_property->props[429].ev_changed = event_new("max_ultra6_hosts_cached_changed");
    gnet_property->props[429].save = TRUE;
    gnet_property->props[429].vector_size = 1;
	mutex_init(&gnet_property->props[429].lock);

    /* Type specific data: */
    gnet_property->props[429].type               = PROP_TYPE_GUINT32;
    gnet_property->props[429].data.guint32.def   = (void *) &gnet_property_variable_max_ultra6_hosts_cached_default;
    gnet_property->props[429].data.guint32.value = (void *) &gnet_property_variable_max_ultra6_hosts_cached;
    gnet_property->props[429].data.guint32.choices = NULL;
    gnet_property->props[429].data.guint32.max   = 50000;
    gnet_property->props[429].data.guint32.min   = 100;


    /*
     * PROP_HOSTS_IN_ULTRA6_CATCHER:
     *
     * General data:
     */
    gnet_property->props[430].name = "hosts_in_ultra6_catcher";
    gnet_property->props[430].desc = _("Current number of IPv6 hosts in ultra node caches.");
    gnet_property->props[430].ev_changed = event_new("hosts_in_ultra6_catcher_changed");
    gnet_property->props[430].save = FALSE;
    gnet_property->props[430].vector_size = 1;
	mutex_init(&gnet_property->props[430].lock);

    /* Type specific data: */
    gnet_property->props[430].type               = PROP_TYPE_GUINT32;
    gnet_property->props[430].data.guint32.def   = (void *) &gnet_property_variable_hosts_in_ultra6_catcher_default;
    gnet_property->props[430].data.guint32.value = (void *) &gnet_property_variable_hosts_in_ultra6_catcher;
    gnet_property->props[430].data.guint32.choices = NULL;
    gnet_property->props[430].data.guint32.max   = INT_MAX;
    gnet_property->props[430].data.guint32.min   = 0;


    /*
     * PROP_HOSTS_IN_GUESS6_CATCHER:
     *
     * General data:
     */
    gnet_property->props[431].name = "hosts_in_guess6_catcher";
    gnet_property->props[431].desc = _("Current number of IPv6 hosts in the regular GUESS cache.");
    gnet_property->props[431].ev_changed = event_new("hosts_in_guess6_catcher_changed");
    gnet_property->props[431].save = FALSE;
    gnet_property->props[431].vector_size = 1;
	mutex_init(&gnet_property->props[431].lock);

    /* Type specific data: */
    gnet_property->props[431].type               = PROP_TYPE_GUINT32;
    gnet_property->props[431].data.guint32.def   = (void *) &gnet_property_variable_hosts_in_guess6_catcher_default;
    gnet_property->props[431].data.guint32.value = (void *) &gnet_property_variable_hosts_in_guess6_catcher;
    gnet_property->props[431].data.guint32.choices = NULL;
    gnet_property->props[431].data.guint32.max   = INT_MAX;
    gnet_property->props[431].data.guint32.min   = 0;


    /*
     * PROP_HOSTS_IN_GUESS6_INTRO_CATCHER:
     *
     * General data:
     */
    gnet_property->props[432].name = "hosts_in_guess6_intro_catcher";
    gnet_property->props[432].desc = _("Current number of IPv6 hosts in the introduction GUESS cache.");
    gnet_property->props[432].ev_changed = event_new("hosts_in_guess6_intro_catcher_changed");
    gnet_property->props[432].save = FALSE;
    gnet_property->props[432].vector_size = 1;
	mutex_init(&gnet_property->props[432].lock);

    /* Type specific data: */
    gnet_property->props[432].type               = PROP_TYPE_GUINT32;
    gnet_property->props[432].data.guint32.def   = (void *) &gnet_property_variable_hosts_in_guess6_intro_catcher_default;
    gnet_property->props[432].data.guint32.value = (void *) &gnet_property_variable_hosts_in_guess6_intro_catcher;
    gnet_property->props[432].data.guint32.choices = NULL;
    gnet_property->props[432].data.guint32.max   = INT_MAX;
    gnet_property->props[432].data.guint32.min   = 0;


    /*
     * PROP_MAX_GUESS6_HOSTS_CACHED:
     *
     * General data:
     */
    gnet_property->props[433].name = "max_guess6_hosts_cached";
    gnet_property->props[433].desc = _("Maximum number of IPv6 hosts in the regular GUESS cache.");
    gnet_property->props[433].ev_changed = event_new("max_guess6_hosts_cached_changed");
    gnet_property->props[433].save = TRUE;
    gnet_property->props[433].vector_size = 1;
	mutex_init(&gnet_property->props[433].lock);

    /* Type specific data: */
    gnet_property->props[433].type               = PROP_TYPE_GUINT32;
    gnet_property->props[433].data.guint32.def   = (void *) &gnet_property_variable_max_guess6_hosts_cached_default;
    gnet_property->props[433].data.guint32.value = (void *) &gnet_property_variable_max_guess6_hosts_cached;
    gnet_property->props[433].data.guint32.choices = NULL;
    gnet_property->props[433].data.guint32.max   = 10000;
    gnet_property->props[433].data.guint32.min   = 100;


    /*
     * PROP_MAX_GUESS6_INTRO_HOSTS_CACHED:
     *
     * General data:
     */
    gnet_property->props[434].name = "max_guess6_intro_hosts_cached";
    gnet_property->props[434].desc = _("Maximum number of IPv6 hosts in the introduction GUESS cache.");
    gnet_property->props[434].ev_changed = event_new("max_guess6_intro_hosts_cached_changed");
    gnet_property->props[434].save = TRUE;
    gnet_property->props[434].vector_size = 1;
	mutex_init(&gnet_property->props[434].lock);

    /* Type specific data: */
    gnet_property->props[434].type               = PROP_TYPE_GUINT32;
    gnet_property->props[434].data.guint32.def   = (void *) &gnet_property_variable_max_guess6_intro_hosts_cached_default;
    gnet_property->props[434].data.guint32.value = (void *) &gnet_property_variable_max_guess6_intro_hosts_cached;
    gnet_property->props[434].data.guint32.choices = NULL;
    gnet_property->props[434].data.guint32.max   = 50000;
    gnet_property->props[434].data.guint32.min   = 1000;


    /*
     * PROP_XMALLOC_DEBUG:
     *
     * General data:
     */
    gnet_property->props[435].name = "xmalloc_debug";
    gnet_property->props[435].desc = _("Debug level for the malloc() replacement allocator.");
    gnet_property->props[435].ev_changed = event_new("xmalloc_debug_changed");
    gnet_property->props[435].save = TRUE;
    gnet_property->props[435].vector_size = 1;
	mutex_init(&gnet_property->props[435].lock);

    /* Type specific data: */
    gnet_property->props[435].type               = PROP_TYPE_GUINT32;
    gnet_property->props[435].data.guint32.def   = (void *) &gnet_property_variable_xmalloc_debug_default;
    gnet_property->props[435].data.guint32.value = (void *) &gnet_property_variable_xmalloc_debug;
    gnet_property->props[435].data.guint32.choices = NULL;
    gnet_property->props[435].data.guint32.max   = 20;
    gnet_property->props[435].data.guint32.min   = 0;


    /*
     * PROP_QHIT_BAD_DEBUG:
     *
     * General data:
     */
    gnet_property->props[436].name = "qhit_bad_debug";
    gnet_property->props[436].desc = _("Debug level for bad query hit messages.");
    gnet_property->props[436].ev_changed = event_new("qhit_bad_debug_changed");
    gnet_property->props[436].save = TRUE;
    gnet_property->props[436].vector_size = 1;
	mutex_init(&gnet_property->props[436].lock);

    /* Type specific data: */
    gnet_property->props[436].type               = PROP_TYPE_GUINT32;
    gnet_property->props[436].data.guint32.def   = (void *) &gnet_property_variable_qhit_bad_debug_default;
    gnet_property->props[436].data.guint32.value = (void *) &gnet_property_variable_qhit_bad_debug;
    gnet_property->props[436].data.guint32.choices = NULL;
    gnet_property->props[436].data.guint32.max   = 20;
    gnet_property->props[436].data.guint32.min   = 0;


    /*
     * PROP_GUID_DEBUG:
     *
     * General data:
     */
    gnet_property->props[437].name = "guid_debug";
    gnet_property->props[437].desc = _("Debug level for GUID management.");
    gnet_property->props[437].ev_changed = event_new("guid_debug_changed");
    gnet_property->props[437].save = TRUE;
    gnet_property->props[437].vector_size = 1;
	mutex_init(&gnet_property->props[437].lock);

    /* Type specific data: */
    gnet_property->props[437].type               = PROP_TYPE_GUINT32;
    gnet_property->props[437].data.guint32.def   = (void *) &gnet_property_variable_guid_debug_default;
    gnet_property->props[437].data.guint32.value = (void *) &gnet_property_variable_guid_debug;
    gnet_property->props[437].data.guint32.choices = NULL;
    gnet_property->props[437].data.guint32.max   = 20;
    gnet_property->props[437].data.guint32.min   = 0;


    /*
     * PROP_TX_DEFLATE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[438].name = "tx_deflate_debug";
    gnet_property->props[438].desc = _("Debug level for the TX (transmit) deflating network layer.");
    gnet_property->props[438].ev_changed = event_new("tx_deflate_debug_changed");
    gnet_property->props[438].save = TRUE;
    gnet_property->props[438].vector_size = 1;
	mutex_init(&gnet_property->props[438].lock);

    /* Type specific data: */
    gnet_property->props[438].type               = PROP_TYPE_GUINT32;
    gnet_property->props[438].data.guint32.def   = (void *) &gnet_property_variable_tx_deflate_debug_default;
    gnet_property->props[438].data.guint32.value = (void *) &gnet_property_variable_tx_deflate_debug;
    gnet_property->props[438].data.guint32.choices = NULL;
    gnet_property->props[438].data.guint32.max   = 20;
    gnet_property->props[438].data.guint32.min   = 0;


    /*
     * PROP_TX_DEBUG_ADDRS:
     *
     * General data:
     */
    gnet_property->props[439].name = "tx_debug_addrs";
    gnet_property->props[439].desc = _("Comma-separated list of TX debugging hosts (IP addresses only)");
    gnet_property->props[439].ev_changed = event_new("tx_debug_addrs_changed");
    gnet_property->props[439].save = TRUE;
    gnet_property->props[439].vector_size = 1;
	mutex_init(&gnet_property->props[439].lock);

    /* Type specific data: */
    gnet_property->props[439].type               = PROP_TYPE_STRING;
    gnet_property->props[439].data.string.def    = (void *) &gnet_property_variable_tx_debug_addrs_default;
    gnet_property->props[439].data.string.value  = (void *) &gnet_property_variable_tx_debug_addrs;
    if (gnet_property->props[439].data.string.def) {
        *gnet_property->props[439].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[439].data.string.def));
    }


    /*
     * PROP_DUMP_RX_ADDRS:
     *
     * General data:
     */
    gnet_property->props[440].name = "dump_rx_addrs";
    gnet_property->props[440].desc = _("Comma-separated list of hosts for whom we want to dump RX traffic (IP addresses only)");
    gnet_property->props[440].ev_changed = event_new("dump_rx_addrs_changed");
    gnet_property->props[440].save = TRUE;
    gnet_property->props[440].vector_size = 1;
	mutex_init(&gnet_property->props[440].lock);

    /* Type specific data: */
    gnet_property->props[440].type               = PROP_TYPE_STRING;
    gnet_property->props[440].data.string.def    = (void *) &gnet_property_variable_dump_rx_addrs_default;
    gnet_property->props[440].data.string.value  = (void *) &gnet_property_variable_dump_rx_addrs;
    if (gnet_property->props[440].data.string.def) {
        *gnet_property->props[440].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[440].data.string.def));
    }


    /*
     * PROP_DUMP_TX_FROM_ADDRS:
     *
     * General data:
     */
    gnet_property->props[441].name = "dump_tx_from_addrs";
    gnet_property->props[441].desc = _("Comma-separated list of hosts for whom we want to dump TX traffic  they emit (IP addresses only)");
    gnet_property->props[441].ev_changed = event_new("dump_tx_from_addrs_changed");
    gnet_property->props[441].save = TRUE;
    gnet_property->props[441].vector_size = 1;
	mutex_init(&gnet_property->props[441].lock);

    /* Type specific data: */
    gnet_property->props[441].type               = PROP_TYPE_STRING;
    gnet_property->props[441].data.string.def    = (void *) &gnet_property_variable_dump_tx_from_addrs_default;
    gnet_property->props[441].data.string.value  = (void *) &gnet_property_variable_dump_tx_from_addrs;
    if (gnet_property->props[441].data.string.def) {
        *gnet_property->props[441].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[441].data.string.def));
    }


    /*
     * PROP_DUMP_TX_TO_ADDRS:
     *
     * General data:
     */
    gnet_property->props[442].name = "dump_tx_to_addrs";
    gnet_property->props[442].desc = _("Comma-separated list of hosts for whom we want to dump TX traffic they receive (IP addresses only)");
    gnet_property->props[442].ev_changed = event_new("dump_tx_to_addrs_changed");
    gnet_property->props[442].save = TRUE;
    gnet_property->props[442].vector_size = 1;
	mutex_init(&gnet_property->props[442].lock);

    /* Type specific data: */
    gnet_property->props[442].type               = PROP_TYPE_STRING;
    gnet_property->props[442].data.string.def    = (void *) &gnet_property_variable_dump_tx_to_addrs_default;
    gnet_property->props[442].data.string.value  = (void *) &gnet_property_variable_dump_tx_to_addrs;
    if (gnet_property->props[442].data.string.def) {
        *gnet_property->props[442].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[442].data.string.def));
    }


    /*
     * PROP_GUESS_MAXIMIZE_BW:
     *
     * General data:
     */
    gnet_property->props[443].name = "guess_maximize_bw";
    gnet_property->props[443].desc = _("Allow GUESS to use some of the unused Gnutella outgoing bandwidth regardless of the GUESS bandwidth hint.  If FALSE, only the configured bandwidth hint will be used.  When running as a leaf this should be set to TRUE to make GUESS queries run faster.");
    gnet_property->props[443].ev_changed = event_new("guess_maximize_bw_changed");
    gnet_property->props[443].save = TRUE;
    gnet_property->props[443].vector_size = 1;
	mutex_init(&gnet_property->props[443].lock);

    /* Type specific data: */
    gnet_property->props[443].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[443].data.boolean.def   = (void *) &gnet_property_variable_guess_maximize_bw_default;
    gnet_property->props[443].data.boolean.value = (void *) &gnet_property_variable_guess_maximize_bw;


    /*
     * PROP_UDP_SCHED_DEBUG:
     *
     * General data:
     */
    gnet_property->props[444].name = "udp_sched_debug";
    gnet_property->props[444].desc = _("Debug level for the UDP TX scheduler.");
    gnet_property->props[444].ev_changed = event_new("udp_sched_debug_changed");
    gnet_property->props[444].save = TRUE;
    gnet_property->props[444].vector_size = 1;
	mutex_init(&gnet_property->props[444].lock);

    /* Type specific data: */
    gnet_property->props[444].type               = PROP_TYPE_GUINT32;
    gnet_property->props[444].data.guint32.def   = (void *) &gnet_property_variable_udp_sched_debug_default;
    gnet_property->props[444].data.guint32.value = (void *) &gnet_property_variable_udp_sched_debug;
    gnet_property->props[444].data.guint32.choices = NULL;
    gnet_property->props[444].data.guint32.max   = 20;
    gnet_property->props[444].data.guint32.min   = 0;


    /*
     * PROP_TX_UT_DEBUG_FLAGS:
     *
     * General data:
     */
    gnet_property->props[445].name = "tx_ut_debug_flags";
    gnet_property->props[445].desc = _("Debugging flags for the semi-reliable UDP TX layer: 1: messages, 2: fragments, 4: acknowledgments, 8: transmissions, 16: timeouts.");
    gnet_property->props[445].ev_changed = event_new("tx_ut_debug_flags_changed");
    gnet_property->props[445].save = TRUE;
    gnet_property->props[445].vector_size = 1;
	mutex_init(&gnet_property->props[445].lock);

    /* Type specific data: */
    gnet_property->props[445].type               = PROP_TYPE_GUINT32;
    gnet_property->props[445].data.guint32.def   = (void *) &gnet_property_variable_tx_ut_debug_flags_default;
    gnet_property->props[445].data.guint32.value = (void *) &gnet_property_variable_tx_ut_debug_flags;
    gnet_property->props[445].data.guint32.choices = NULL;
    gnet_property->props[445].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[445].data.guint32.min   = 0x00000000;


    /*
     * PROP_RX_DEBUG_ADDRS:
     *
     * General data:
     */
    gnet_property->props[446].name = "rx_debug_addrs";
    gnet_property->props[446].desc = _("Comma-separated list of RX debugging hosts (IP addresses only)");
    gnet_property->props[446].ev_changed = event_new("rx_debug_addrs_changed");
    gnet_property->props[446].save = TRUE;
    gnet_property->props[446].vector_size = 1;
	mutex_init(&gnet_property->props[446].lock);

    /* Type specific data: */
    gnet_property->props[446].type               = PROP_TYPE_STRING;
    gnet_property->props[446].data.string.def    = (void *) &gnet_property_variable_rx_debug_addrs_default;
    gnet_property->props[446].data.string.value  = (void *) &gnet_property_variable_rx_debug_addrs;
    if (gnet_property->props[446].data.string.def) {
        *gnet_property->props[446].data.string.value =
            g_strdup(eval_subst(*gnet_property->props[446].data.string.def));
    }


    /*
     * PROP_RX_UT_DEBUG_FLAGS:
     *
     * General data:
     */
    gnet_property->props[447].name = "rx_ut_debug_flags";
    gnet_property->props[447].desc = _("Debugging flags for the semi-reliable UDP RX layer: 1: messages, 2: fragments, 4: acknowledgments, 8: receptions, 16: timeouts.");
    gnet_property->props[447].ev_changed = event_new("rx_ut_debug_flags_changed");
    gnet_property->props[447].save = TRUE;
    gnet_property->props[447].vector_size = 1;
	mutex_init(&gnet_property->props[447].lock);

    /* Type specific data: */
    gnet_property->props[447].type               = PROP_TYPE_GUINT32;
    gnet_property->props[447].data.guint32.def   = (void *) &gnet_property_variable_rx_ut_debug_flags_default;
    gnet_property->props[447].data.guint32.value = (void *) &gnet_property_variable_rx_ut_debug_flags;
    gnet_property->props[447].data.guint32.choices = NULL;
    gnet_property->props[447].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[447].data.guint32.min   = 0x00000000;


    /*
     * PROP_LOG_SR_UDP_TX:
     *
     * General data:
     */
    gnet_property->props[448].name = "log_sr_udp_tx";
    gnet_property->props[448].desc = _("Whether to log sent semi-reliable UDP messages.");
    gnet_property->props[448].ev_changed = event_new("log_sr_udp_tx_changed");
    gnet_property->props[448].save = TRUE;
    gnet_property->props[448].vector_size = 1;
	mutex_init(&gnet_property->props[448].lock);

    /* Type specific data: */
    gnet_property->props[448].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[448].data.boolean.def   = (void *) &gnet_property_variable_log_sr_udp_tx_default;
    gnet_property->props[448].data.boolean.value = (void *) &gnet_property_variable_log_sr_udp_tx;


    /*
     * PROP_LOG_SR_UDP_RX:
     *
     * General data:
     */
    gnet_property->props[449].name = "log_sr_udp_rx";
    gnet_property->props[449].desc = _("Whether to log received semi-reliable UDP messages.");
    gnet_property->props[449].ev_changed = event_new("log_sr_udp_rx_changed");
    gnet_property->props[449].save = TRUE;
    gnet_property->props[449].vector_size = 1;
	mutex_init(&gnet_property->props[449].lock);

    /* Type specific data: */
    gnet_property->props[449].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[449].data.boolean.def   = (void *) &gnet_property_variable_log_sr_udp_rx_default;
    gnet_property->props[449].data.boolean.value = (void *) &gnet_property_variable_log_sr_udp_rx;


    /*
     * PROP_SECURE_OOB_DEBUG:
     *
     * General data:
     */
    gnet_property->props[450].name = "secure_oob_debug";
    gnet_property->props[450].desc = _("Debug level for the secured OOB query hit claiming.");
    gnet_property->props[450].ev_changed = event_new("secure_oob_debug_changed");
    gnet_property->props[450].save = TRUE;
    gnet_property->props[450].vector_size = 1;
	mutex_init(&gnet_property->props[450].lock);

    /* Type specific data: */
    gnet_property->props[450].type               = PROP_TYPE_GUINT32;
    gnet_property->props[450].data.guint32.def   = (void *) &gnet_property_variable_secure_oob_debug_default;
    gnet_property->props[450].data.guint32.value = (void *) &gnet_property_variable_secure_oob_debug;
    gnet_property->props[450].data.guint32.choices = NULL;
    gnet_property->props[450].data.guint32.max   = 20;
    gnet_property->props[450].data.guint32.min   = 0;


    /*
     * PROP_LOG_VMSG_TX:
     *
     * General data:
     */
    gnet_property->props[451].name = "log_vmsg_tx";
    gnet_property->props[451].desc = _("Whether to log sent vendor messages.");
    gnet_property->props[451].ev_changed = event_new("log_vmsg_tx_changed");
    gnet_property->props[451].save = TRUE;
    gnet_property->props[451].vector_size = 1;
	mutex_init(&gnet_property->props[451].lock);

    /* Type specific data: */
    gnet_property->props[451].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[451].data.boolean.def   = (void *) &gnet_property_variable_log_vmsg_tx_default;
    gnet_property->props[451].data.boolean.value = (void *) &gnet_property_variable_log_vmsg_tx;


    /*
     * PROP_LOG_VMSG_RX:
     *
     * General data:
     */
    gnet_property->props[452].name = "log_vmsg_rx";
    gnet_property->props[452].desc = _("Whether to log received vendor messages.");
    gnet_property->props[452].ev_changed = event_new("log_vmsg_rx_changed");
    gnet_property->props[452].save = TRUE;
    gnet_property->props[452].vector_size = 1;
	mutex_init(&gnet_property->props[452].lock);

    /* Type specific data: */
    gnet_property->props[452].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[452].data.boolean.def   = (void *) &gnet_property_variable_log_vmsg_rx_default;
    gnet_property->props[452].data.boolean.value = (void *) &gnet_property_variable_log_vmsg_rx;


    /*
     * PROP_DHT_TCACHE_DEBUG_FLAGS:
     *
     * General data:
     */
    gnet_property->props[453].name = "dht_tcache_debug_flags";
    gnet_property->props[453].desc = _("Debugging flags for the DHT token cache (developers only).");
    gnet_property->props[453].ev_changed = event_new("dht_tcache_debug_flags_changed");
    gnet_property->props[453].save = TRUE;
    gnet_property->props[453].vector_size = 1;
	mutex_init(&gnet_property->props[453].lock);

    /* Type specific data: */
    gnet_property->props[453].type               = PROP_TYPE_GUINT32;
    gnet_property->props[453].data.guint32.def   = (void *) &gnet_property_variable_dht_tcache_debug_flags_default;
    gnet_property->props[453].data.guint32.value = (void *) &gnet_property_variable_dht_tcache_debug_flags;
    gnet_property->props[453].data.guint32.choices = NULL;
    gnet_property->props[453].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[453].data.guint32.min   = 0x00000000;


    /*
     * PROP_LOG_WEIRD_DHT_HEADERS:
     *
     * General data:
     */
    gnet_property->props[454].name = "log_weird_dht_headers";
    gnet_property->props[454].desc = _("Whether to log weird DHT message headers when debugging.");
    gnet_property->props[454].ev_changed = event_new("log_weird_dht_headers_changed");
    gnet_property->props[454].save = TRUE;
    gnet_property->props[454].vector_size = 1;
	mutex_init(&gnet_property->props[454].lock);

    /* Type specific data: */
    gnet_property->props[454].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[454].data.boolean.def   = (void *) &gnet_property_variable_log_weird_dht_headers_default;
    gnet_property->props[454].data.boolean.value = (void *) &gnet_property_variable_log_weird_dht_headers;


    /*
     * PROP_DHT_RPC_DEBUG:
     *
     * General data:
     */
    gnet_property->props[455].name = "dht_rpc_debug";
    gnet_property->props[455].desc = _("Debug level for the DHT Remote Procedure Call (RPC) code.");
    gnet_property->props[455].ev_changed = event_new("dht_rpc_debug_changed");
    gnet_property->props[455].save = TRUE;
    gnet_property->props[455].vector_size = 1;
	mutex_init(&gnet_property->props[455].lock);

    /* Type specific data: */
    gnet_property->props[455].type               = PROP_TYPE_GUINT32;
    gnet_property->props[455].data.guint32.def   = (void *) &gnet_property_variable_dht_rpc_debug_default;
    gnet_property->props[455].data.guint32.value = (void *) &gnet_property_variable_dht_rpc_debug;
    gnet_property->props[455].data.guint32.choices = NULL;
    gnet_property->props[455].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[455].data.guint32.min   = 0x00000000;


    /*
     * PROP_LOG_UHC_PINGS_RX:
     *
     * General data:
     */
    gnet_property->props[456].name = "log_uhc_pings_rx";
    gnet_property->props[456].desc = _("Whether to log UHC pings we receive.");
    gnet_property->props[456].ev_changed = event_new("log_uhc_pings_rx_changed");
    gnet_property->props[456].save = TRUE;
    gnet_property->props[456].vector_size = 1;
	mutex_init(&gnet_property->props[456].lock);

    /* Type specific data: */
    gnet_property->props[456].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[456].data.boolean.def   = (void *) &gnet_property_variable_log_uhc_pings_rx_default;
    gnet_property->props[456].data.boolean.value = (void *) &gnet_property_variable_log_uhc_pings_rx;


    /*
     * PROP_LOG_UHC_PINGS_TX:
     *
     * General data:
     */
    gnet_property->props[457].name = "log_uhc_pings_tx";
    gnet_property->props[457].desc = _("Whether to log UHC pings we emit.");
    gnet_property->props[457].ev_changed = event_new("log_uhc_pings_tx_changed");
    gnet_property->props[457].save = TRUE;
    gnet_property->props[457].vector_size = 1;
	mutex_init(&gnet_property->props[457].lock);

    /* Type specific data: */
    gnet_property->props[457].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[457].data.boolean.def   = (void *) &gnet_property_variable_log_uhc_pings_tx_default;
    gnet_property->props[457].data.boolean.value = (void *) &gnet_property_variable_log_uhc_pings_tx;


    /*
     * PROP_CLEAN_SHUTDOWN:
     *
     * General data:
     */
    gnet_property->props[458].name = "clean_shutdown";
    gnet_property->props[458].desc = _("Whether the program was properly shutdown.");
    gnet_property->props[458].ev_changed = event_new("clean_shutdown_changed");
    gnet_property->props[458].save = TRUE;
    gnet_property->props[458].vector_size = 1;
	mutex_init(&gnet_property->props[458].lock);

    /* Type specific data: */
    gnet_property->props[458].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[458].data.boolean.def   = (void *) &gnet_property_variable_clean_shutdown_default;
    gnet_property->props[458].data.boolean.value = (void *) &gnet_property_variable_clean_shutdown;


    /*
     * PROP_CLEAN_RESTART:
     *
     * General data:
     */
    gnet_property->props[459].name = "clean_restart";
    gnet_property->props[459].desc = _("Whether the program restarted after a clean shutdown.");
    gnet_property->props[459].ev_changed = event_new("clean_restart_changed");
    gnet_property->props[459].save = FALSE;
    gnet_property->props[459].vector_size = 1;
	mutex_init(&gnet_property->props[459].lock);

    /* Type specific data: */
    gnet_property->props[459].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[459].data.boolean.def   = (void *) &gnet_property_variable_clean_restart_default;
    gnet_property->props[459].data.boolean.value = (void *) &gnet_property_variable_clean_restart;


    /*
     * PROP_DHT_KEYS_DEBUG:
     *
     * General data:
     */
    gnet_property->props[460].name = "dht_keys_debug";
    gnet_property->props[460].desc = _("Debug level for DHT key management.");
    gnet_property->props[460].ev_changed = event_new("dht_keys_debug_changed");
    gnet_property->props[460].save = TRUE;
    gnet_property->props[460].vector_size = 1;
	mutex_init(&gnet_property->props[460].lock);

    /* Type specific data: */
    gnet_property->props[460].type               = PROP_TYPE_GUINT32;
    gnet_property->props[460].data.guint32.def   = (void *) &gnet_property_variable_dht_keys_debug_default;
    gnet_property->props[460].data.guint32.value = (void *) &gnet_property_variable_dht_keys_debug;
    gnet_property->props[460].data.guint32.choices = NULL;
    gnet_property->props[460].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[460].data.guint32.min   = 0x00000000;


    /*
     * PROP_DHT_VALUES_DEBUG:
     *
     * General data:
     */
    gnet_property->props[461].name = "dht_values_debug";
    gnet_property->props[461].desc = _("Debug level for DHT value management.");
    gnet_property->props[461].ev_changed = event_new("dht_values_debug_changed");
    gnet_property->props[461].save = TRUE;
    gnet_property->props[461].vector_size = 1;
	mutex_init(&gnet_property->props[461].lock);

    /* Type specific data: */
    gnet_property->props[461].type               = PROP_TYPE_GUINT32;
    gnet_property->props[461].data.guint32.def   = (void *) &gnet_property_variable_dht_values_debug_default;
    gnet_property->props[461].data.guint32.value = (void *) &gnet_property_variable_dht_values_debug;
    gnet_property->props[461].data.guint32.choices = NULL;
    gnet_property->props[461].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[461].data.guint32.min   = 0x00000000;


    /*
     * PROP_PID:
     *
     * General data:
     */
    gnet_property->props[462].name = "pid";
    gnet_property->props[462].desc = _("ID of the current process.");
    gnet_property->props[462].ev_changed = event_new("pid_changed");
    gnet_property->props[462].save = TRUE;
    gnet_property->props[462].vector_size = 1;
	mutex_init(&gnet_property->props[462].lock);

    /* Type specific data: */
    gnet_property->props[462].type               = PROP_TYPE_GUINT32;
    gnet_property->props[462].data.guint32.def   = (void *) &gnet_property_variable_pid_default;
    gnet_property->props[462].data.guint32.value = (void *) &gnet_property_variable_pid;
    gnet_property->props[462].data.guint32.choices = NULL;
    gnet_property->props[462].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[462].data.guint32.min   = 0x00000000;


    /*
     * PROP_HTTP_RANGE_DEBUG:
     *
     * General data:
     */
    gnet_property->props[463].name = "http_range_debug";
    gnet_property->props[463].desc = _("Debug level for HTTP range parsing / handling.");
    gnet_property->props[463].ev_changed = event_new("http_range_debug_changed");
    gnet_property->props[463].save = TRUE;
    gnet_property->props[463].vector_size = 1;
	mutex_init(&gnet_property->props[463].lock);

    /* Type specific data: */
    gnet_property->props[463].type               = PROP_TYPE_GUINT32;
    gnet_property->props[463].data.guint32.def   = (void *) &gnet_property_variable_http_range_debug_default;
    gnet_property->props[463].data.guint32.value = (void *) &gnet_property_variable_http_range_debug;
    gnet_property->props[463].data.guint32.choices = NULL;
    gnet_property->props[463].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[463].data.guint32.min   = 0x00000000;


    /*
     * PROP_UPNP_MAPPING_LEASE_TIME:
     *
     * General data:
     */
    gnet_property->props[464].name = "upnp_mapping_lease_time";
    gnet_property->props[464].desc = _("Lease time when installing port mappings via UPnP or NAT-PMP, in seconds.  A value of 0 requests permanent mappings.");
    gnet_property->props[464].ev_changed = event_new("upnp_mapping_lease_time_changed");
    gnet_property->props[464].save = TRUE;
    gnet_property->props[464].vector_size = 1;
	mutex_init(&gnet_property->props[464].lock);

    /* Type specific data: */
    gnet_property->props[464].type               = PROP_TYPE_GUINT32;
    gnet_property->props[464].data.guint32.def   = (void *) &gnet_property_variable_upnp_mapping_lease_time_default;
    gnet_property->props[464].data.guint32.value = (void *) &gnet_property_variable_upnp_mapping_lease_time;
    gnet_property->props[464].data.guint32.choices = NULL;
    gnet_property->props[464].data.guint32.max   = 31536000;
    gnet_property->props[464].data.guint32.min   = 0;


    /*
     * PROP_USER_AUTO_RESTART:
     *
     * General data:
     */
    gnet_property->props[465].name = "user_auto_restart";
    gnet_property->props[465].desc = _("Whether the program is auto-restarting at the user's request.");
    gnet_property->props[465].ev_changed = event_new("user_auto_restart_changed");
    gnet_property->props[465].save = TRUE;
    gnet_property->props[465].vector_size = 1;
	mutex_init(&gnet_property->props[465].lock);

    /* Type specific data: */
    gnet_property->props[465].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[465].data.boolean.def   = (void *) &gnet_property_variable_user_auto_restart_default;
    gnet_property->props[465].data.boolean.value = (void *) &gnet_property_variable_user_auto_restart;


    /*
     * PROP_TM_DEBUG:
     *
     * General data:
     */
    gnet_property->props[466].name = "tm_debug";
    gnet_property->props[466].desc = _("Debug level for time management.");
    gnet_property->props[466].ev_changed = event_new("tm_debug_changed");
    gnet_property->props[466].save = TRUE;
    gnet_property->props[466].vector_size = 1;
	mutex_init(&gnet_property->props[466].lock);

    /* Type specific data: */
    gnet_property->props[466].type               = PROP_TYPE_GUINT32;
    gnet_property->props[466].data.guint32.def   = (void *) &gnet_property_variable_tm_debug_default;
    gnet_property->props[466].data.guint32.value = (void *) &gnet_property_variable_tm_debug;
    gnet_property->props[466].data.guint32.choices = NULL;
    gnet_property->props[466].data.guint32.max   = 20;
    gnet_property->props[466].data.guint32.min   = 0;

    gnet_property->by_name = htable_create(HASH_KEY_STRING, 0);
    for (n = 0; n < GNET_PROPERTY_NUM; n ++) {
        htable_insert(gnet_property->by_name,
            gnet_property->props[n].name, int_to_pointer(n+(NO_PROP+1)));
    }

    return gnet_property;
}

/**
 * Free memory allocated by the property set.
 */
G_GNUC_COLD void
gnet_prop_shutdown(void) {
    guint32 n;

    htable_free_null(&gnet_property->by_name);

    for (n = 0; n < GNET_PROPERTY_NUM; n ++) {
        if (gnet_property->props[n].type == PROP_TYPE_STRING) {
			char **p = gnet_property->props[n].data.string.value;
            struct event *e = gnet_property->props[n].ev_changed;
	    G_FREE_NULL(*p);
            if (e)
                event_destroy(e);
        }
    }

	/*
	 * We don't free gnet_property->props and gnet_property.
	 * They are allocated via omalloc().
	 *
	 * Prevent further access to the now shutdown properties, that's all.
	 */

	gnet_property = NULL;
}

prop_def_t *
gnet_prop_get_def(property_t p)
{
    return prop_get_def(gnet_property, p);
}

/**
 * Lock property.
 */
void
gnet_prop_lock(property_t p)
{
    prop_lock(gnet_property, p);
}

/**
 * Unlock property.
 */
void
gnet_prop_unlock(property_t p)
{
    prop_unlock(gnet_property, p);
}

/**
 * Add a change listener to a given property. If init is TRUE then
 * the listener is immediately called.
 */
void
gnet_prop_add_prop_changed_listener(
    property_t prop, prop_changed_listener_t l, gboolean init)
{
    prop_add_prop_changed_listener(gnet_property, prop, l, init);
}

/**
 * Add a change listener to a given property. If init is TRUE then
 * the listener is immediately called.
 */
void
gnet_prop_add_prop_changed_listener_full(
    property_t prop, prop_changed_listener_t l, gboolean init,
    enum frequency_type freq, guint32 interval)
{
    prop_add_prop_changed_listener_full(gnet_property, prop, l, init,
        freq, interval);
}

void
gnet_prop_remove_prop_changed_listener(
    property_t prop, prop_changed_listener_t l)
{
    prop_remove_prop_changed_listener(gnet_property, prop, l);
}

void
gnet_prop_set_boolean(
    property_t prop, const gboolean *src, size_t offset, size_t length)
{
    prop_set_boolean(gnet_property, prop, src, offset, length);
}

gboolean *
gnet_prop_get_boolean(
    property_t prop, gboolean *t, size_t offset, size_t length)
{
    return prop_get_boolean(gnet_property, prop, t, offset, length);
}

void
gnet_prop_set_guint32(
    property_t prop, const guint32 *src, size_t offset, size_t length)
{
    prop_set_guint32(gnet_property, prop, src, offset, length);
}

guint32 *
gnet_prop_get_guint32(
    property_t prop, guint32 *t, size_t offset, size_t length)
{
    return prop_get_guint32(gnet_property, prop, t, offset, length);
}

void
gnet_prop_set_guint64(
    property_t prop, const guint64 *src, size_t offset, size_t length)
{
    prop_set_guint64(gnet_property, prop, src, offset, length);
}

guint64 *
gnet_prop_get_guint64(
    property_t prop, guint64 *t, size_t offset, size_t length)
{
    return prop_get_guint64(gnet_property, prop, t, offset, length);
}

void
gnet_prop_set_timestamp(
    property_t prop, const time_t *src, size_t offset, size_t length)
{
    prop_set_timestamp(gnet_property, prop, src, offset, length);
}

time_t *
gnet_prop_get_timestamp(
    property_t prop, time_t *t, size_t offset, size_t length)
{
    return prop_get_timestamp(gnet_property, prop, t, offset, length);
}

void
gnet_prop_set_ip(
    property_t prop, const host_addr_t *src, size_t offset, size_t length)
{
    prop_set_ip(gnet_property, prop, src, offset, length);
}

host_addr_t *
gnet_prop_get_ip(
    property_t prop, host_addr_t *t, size_t offset, size_t length)
{
    return prop_get_ip(gnet_property, prop, t, offset, length);
}


void
gnet_prop_set_string(property_t prop, const char *val)
{
    prop_set_string(gnet_property, prop, val);
}

char *
gnet_prop_get_string(property_t prop, char *t, size_t size)
{
    return prop_get_string(gnet_property, prop, t, size);
}

void
gnet_prop_set_storage(property_t p, gconstpointer v, size_t l)
{
    prop_set_storage(gnet_property, p, v, l);
}

gpointer
gnet_prop_get_storage(property_t p, gpointer t, size_t l)
{
    return prop_get_storage(gnet_property, p, t, l);
}

const char *
gnet_prop_to_string(property_t prop)
{
    return prop_to_string(gnet_property, prop);
}

const char *
gnet_prop_default_to_string(property_t prop)
{
    return prop_default_to_string(gnet_property, prop);
}

const char *
gnet_prop_name(property_t p)
{
    return prop_name(gnet_property, p);
}

prop_type_t
gnet_prop_type(property_t p)
{
    return prop_type(gnet_property, p);
}

const char *
gnet_prop_type_to_string(property_t p)
{
    return prop_type_to_string(gnet_property, p);
}

const char *
gnet_prop_description(property_t p)
{
    return prop_description(gnet_property, p);
}

gboolean
gnet_prop_is_saved(property_t p)
{
    return prop_is_saved(gnet_property, p);
}

property_t
gnet_prop_get_by_name(const char *name)
{
    return pointer_to_uint(htable_lookup(gnet_property->by_name, name));
}

GSList *
gnet_prop_get_by_regex(const char *pattern, int *error)
{
    return prop_get_by_regex(gnet_property, pattern, error);
}

void
gnet_prop_set_from_string(property_t prop, const char *val)
{
	prop_set_from_string(gnet_property, prop, val, FALSE);	
}

/**
 * Returns a new stub struct for this property set. Just g_free it
 * when it is no longer needed. All fields are read only!
 */
const prop_set_stub_t *
gnet_prop_get_stub(void)
{
	static prop_set_stub_t stub;
	static gboolean inited;

	if G_LIKELY(inited)
		return &stub;

	stub.size    = GNET_PROPERTY_NUM;
	stub.offset  = GNET_PROPERTY_MIN;
	stub.get_def = gnet_prop_get_def;
	stub.get_by_name = gnet_prop_get_by_name;
	stub.to_string = gnet_prop_to_string;

	stub.prop_changed_listener.add =
		gnet_prop_add_prop_changed_listener;
	stub.prop_changed_listener.add_full =
		gnet_prop_add_prop_changed_listener_full;
	stub.prop_changed_listener.remove =
		gnet_prop_remove_prop_changed_listener;

	stub.boolean.get = gnet_prop_get_boolean;
	stub.boolean.set = gnet_prop_set_boolean;

	stub.guint32.get = gnet_prop_get_guint32;
	stub.guint32.set = gnet_prop_set_guint32;

	stub.guint64.get = gnet_prop_get_guint64;
	stub.guint64.set = gnet_prop_set_guint64;

	stub.string.get = gnet_prop_get_string;
	stub.string.set = gnet_prop_set_string;

	stub.storage.get = gnet_prop_get_storage;
	stub.storage.set = gnet_prop_set_storage;

	stub.timestamp.get = gnet_prop_get_timestamp;
	stub.timestamp.set = gnet_prop_set_timestamp;

	stub.ip.get = gnet_prop_get_ip;
	stub.ip.set = gnet_prop_set_ip;

	inited = TRUE;
	return &stub;
}



/* vi: set ts=4 sw=4 cindent: */
